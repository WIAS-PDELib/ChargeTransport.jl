<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Perovskite solar cell · ChargeTransport.jl</title><meta name="title" content="Perovskite solar cell · ChargeTransport.jl"/><meta property="og:title" content="Perovskite solar cell · ChargeTransport.jl"/><meta property="twitter:title" content="Perovskite solar cell · ChargeTransport.jl"/><meta name="description" content="Documentation for ChargeTransport.jl."/><meta property="og:description" content="Documentation for ChargeTransport.jl."/><meta property="twitter:description" content="Documentation for ChargeTransport.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../general/">ChargeTransport.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../general/">Home</a></li><li><a class="tocitem" href="../changes/">Changelog</a></li><li><a class="tocitem" href="../backgroundinfo/">Mathematical drift-diffusion models</a></li><li><span class="tocitem">How to get started</span><ul><li><a class="tocitem" href="../GaAs/">van Roosbroeck system</a></li><li class="is-active"><a class="tocitem" href>Perovskite solar cell</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Simulating-electronic-ionic-charge-transport"><span>Simulating electronic-ionic charge transport</span></a></li><li><a class="tocitem" href="#Quasi-Fermi-potential-notation"><span>Quasi Fermi potential notation</span></a></li><li><a class="tocitem" href="#Current-way-of-handling-E_\\text{a}"><span>Current way of handling <span>$E_\text{a}$</span></span></a></li><li><a class="tocitem" href="#Remarks"><span>Remarks</span></a></li><li class="toplevel"><a class="tocitem" href="#Example-1:-Graded-interfaces"><span>Example 1: Graded interfaces</span></a></li><li><a class="tocitem" href="#Example-2:-Linear-IV-scan-protocol"><span>Example 2: Linear IV scan protocol</span></a></li><li><a class="tocitem" href="#Example-3:-Illumination"><span>Example 3: Illumination</span></a></li><li><a class="tocitem" href="#Example-4:-Multi-dimensional-problems"><span>Example 4: Multi-dimensional problems</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../allindex/">Types, Constructors and Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../module_examples/Ex101_PIN/">GaAs diode (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex102_PIN_nodal_doping/">GaAs diode with spatially varying doping (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex103_PSC_IVMeasurement/">PSC device with ions and different I-V scan protocols (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex104_PSC_Photogeneration/">PSC device with photogeneration rate (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex105_PSC_gradedFlux/">Three-layer PSC device with graded interfaces &amp; Ohmic contacts (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex106_PSC_SurfaceRecombination/">PSC device with surface recombination (1D).</a></li><li><a class="tocitem" href="../module_examples/Ex107_MoS2_withIons_BarrierLowering/">MoS2 with moving defects and Schottky Barrier Lowering.</a></li><li><a class="tocitem" href="../module_examples/Ex108_CIGS/">CIGS: stationary with Schottky contacts.</a></li><li><a class="tocitem" href="../module_examples/Ex109_PSC_NonDimensional/">Nondimensionalized perovskite solar cell.</a></li><li><a class="tocitem" href="../module_examples/Ex201_PSC_tensorGrid/">PSC device on 2D domain (Tensor grid).</a></li><li><a class="tocitem" href="../module_examples/Ex202_Laser_simple/">Simple laser structure with 5 layers.</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to get started</a></li><li class="is-active"><a href>Perovskite solar cell</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Perovskite solar cell</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/WIAS-PDELib/ChargeTransport.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Perovskite-solar-cell"><a class="docs-heading-anchor" href="#Perovskite-solar-cell">Perovskite solar cell</a><a id="Perovskite-solar-cell-1"></a><a class="docs-heading-anchor-permalink" href="#Perovskite-solar-cell" title="Permalink"></a></h1><p>We simulate charge transport in perovskite solar cells (PSCs), where we have apart from holes and electrons also ionic charge carriers. Here, we assume to have three domains, denoted by <span>$\mathbf{\Omega} = \mathbf{\Omega}_{\text{HTL}} \cup \mathbf{\Omega}_{\text{PVK}} \cup \mathbf{\Omega}_{\text{ETL}}  $. The unknowns are the quasi Fermi potentials of electrons, holes and anion vacancies $\varphi_n, \varphi_p, \varphi_a$</span> as well as the electric potential <span>$\psi$</span>. The underlying PDEs are given by</p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( (n_\text{p}(\psi, \varphi_\text{p}) - C_\text{p} ) - (n_\text{n}(\psi, \varphi_\text{n}) - C_\text{n}) \Big),\\
	q \partial_t n_\text{n}(\psi, \varphi_\text{n}) - \nabla \cdot \mathbf{j}_\text{n} &amp;= q\Bigl(G(\mathbf{x}) - R(n_\text{n},n_\text{p}) \Bigr), \\
	q \partial_t n_\text{p}(\psi, \varphi_\text{p}) + \nabla \cdot \mathbf{j}_\text{p} &amp;= \Bigl(G(\mathbf{x}) - R(n_\text{n},n_\text{p}) \Bigr),
\end{aligned}\]</p><p>for <span>$\mathbf{x} \in \mathbf{\Omega}_{\text{HTL}} \cup  \mathbf{\Omega}_{\text{ETL}} $, $t \in [0, t_F]$</span>. In the middle, intrinsic region ($ \mathbf{x} \in \mathbf{\Omega}_{\text{PVK}} $), we have</p><p class="math-container">\[\begin{aligned}
	- \nabla \cdot (\varepsilon_s \nabla \psi) &amp;= q \Big( n_\text{p}(\psi, \varphi_\text{p})  - n_\text{n}(\psi, \varphi_\text{n}) + n_\text{a}(\psi, \varphi_\text{a}) - C_\text{a} \Big),\\
q \partial_t n_\text{n}(\psi, \varphi_\text{n})	- \nabla \cdot \mathbf{j}_\text{n} &amp;= \Bigl(G(\mathbf{x}) - R(n_\text{n},n_\text{p}) \Bigr), \\
	q \partial_t n_\text{p}(\psi, \varphi_\text{p}) + \nabla \cdot \mathbf{j}_\text{p} &amp;= \Bigl(G(\mathbf{x}) - R(n_\text{n},n_\text{p}) \Bigr),\\
	q \partial_t n_\text{a}(\psi, \varphi_\text{a}) + \nabla \cdot \mathbf{j}_\text{a} &amp;= 0,
\end{aligned}\]</p><p>see <a href="https://www.sciencedirect.com/science/article/abs/pii/S0013468621009865">Abdel2021</a>.</p><p>Differences to the previous example include</p><ul><li>an additional charge carrier (the anion vacancy)</li><li>parameter jumps across heterojunctions</li><li>the transient case</li><li>a generation rate <span>$G$</span></li><li>higher dimensional problem.</li></ul><h1 id="Simulating-electronic-ionic-charge-transport"><a class="docs-heading-anchor" href="#Simulating-electronic-ionic-charge-transport">Simulating electronic-ionic charge transport</a><a id="Simulating-electronic-ionic-charge-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Simulating-electronic-ionic-charge-transport" title="Permalink"></a></h1><p>For example, for perovskite solar cells an average vacancy density is given in literature. If the charge carrier densities are used as the set of unknowns, the initial condition for the anion vacancy density can be given by</p><p class="math-container">\[\begin{aligned}
	n_{\text{a}}^0 = C_{\text{a}},
\end{aligned}\]</p><p>where <span>$C_{\text{a}}$</span> corresponds to the uniform density of cation vacancies and is set equal to the average anion vacancy density to ensure global charge neutrality. With homogeneous no-flow Neumann boundary conditions around the perovskite layer for the anion vacancies, the total mass of anions is conserved at all times, i.e.</p><p class="math-container">\[\begin{aligned}
	\frac{1}{|\Omega_{\text{PVK}} |} \int_{\Omega_{\text{PVK}}} n_{\text{a}} (\mathbf{x}, t)\, d\mathbf{x}
    = \frac{1}{|\Omega_{\text{PVK}} |}  \int_{\Omega_{\text{PVK}}} n_{\text{a}}^0 (\mathbf{x})\, d\mathbf{x}
    = C_{\text{a}}, \quad \text{for all} \quad t \geq 0.
\end{aligned}\]</p><p>Since we do not use charge carrier densities directly but instead employ quasi Fermi potentials as the unknowns, due to mathematical, physical, and numerical advantages, we must find a workaround to properly fix the initial condition for the vacancy density.</p><h2 id="Quasi-Fermi-potential-notation"><a class="docs-heading-anchor" href="#Quasi-Fermi-potential-notation">Quasi Fermi potential notation</a><a id="Quasi-Fermi-potential-notation-1"></a><a class="docs-heading-anchor-permalink" href="#Quasi-Fermi-potential-notation" title="Permalink"></a></h2><p>The statistical relation between the vacancy density and the potentials (our chosen unknowns) reads</p><p class="math-container">\[\begin{aligned}
    n_{\text{a}}  = N_{\text{a}}  F_{-1} \Bigl(\eta_{\text{a}} (\psi, \varphi_{\text{a}} ) \Bigr), \quad \eta_{\text{a}}  = z_{\text{a}}  \frac{q (\varphi_{\text{a}}  - \psi) + E_{\text{a}} }{k_B T},
\end{aligned}\]</p><p>where <span>$N_{\text{a}}$</span> denotes the maximum vacancy density allowed, <span>$F_{-1} = (\exp(-x) +1)^{-1}$</span> is the Fermi-Dirac integral of order <span>$-1$</span>, and we refer to <span>$E_{\text{a}}$</span> is the intrinsic vacancy energy level (somehow a model parameter). In equilibrium, we set the vacancy quasi-Fermi potential to zero, i.e., <span>$\varphi_{\text{a}} = 0$</span>, when the applied voltage is <span>$V = 0$</span>. Because the initial condition for the vacancy density is prescribed as <span>$C_\text{a}$</span> and the electric potential <span>$\psi$</span> is an unknown, the only remaining free parameter is the vacancy energy <span>$E_{\text{a}}$</span>.</p><blockquote><p>The value of <span>$E_{\text{a}}$</span> must be chosen such that the average vacancy density remains conserved for all time steps.</p></blockquote><h2 id="Current-way-of-handling-E_\\text{a}"><a class="docs-heading-anchor" href="#Current-way-of-handling-E_\\text{a}">Current way of handling <span>$E_\text{a}$</span></a><a id="Current-way-of-handling-E_\\text{a}-1"></a><a class="docs-heading-anchor-permalink" href="#Current-way-of-handling-E_\\text{a}" title="Permalink"></a></h2><p>We implement a method that calculates the appropriate <code>Ea</code> values internally via the secant method. To make use of this feature, you can add in the equilibrium solving the flag <code>vacancyEnergyCalculation=true</code>.</p><pre><code class="language-julia hljs">solution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = true)</code></pre><p>To check, if, indeed, the average vacancy density is maintained, you can calculate that value and print the chosen vacancy energy level.</p><pre><code class="language-julia hljs">integral = integrated_density(ctsys, sol = solution, icc = iphia, ireg = regionIntrinsic)

println(&quot;Calculated average vacancy density is: &quot;, integral / data.regionVolumes[regionIntrinsic])

vacancyEnergy = data.params.bandEdgeEnergy[iphia, regionIntrinsic] / data.constants.q
println(&quot;Value for vacancy energy is: &quot;, vacancyEnergy, &quot; eV&quot;)</code></pre><h2 id="Remarks"><a class="docs-heading-anchor" href="#Remarks">Remarks</a><a id="Remarks-1"></a><a class="docs-heading-anchor-permalink" href="#Remarks" title="Permalink"></a></h2><ul><li>For <strong>1D simulations</strong>, this approach is sufficient.</li><li>For <strong>multi-dimensional simulations</strong>, however, we recommend precomputing the <code>Ea</code> values and storing them in case of multiple computations with the same parameter set.</li></ul><p>Next, we give a quick survey on how to use <code>ChargeTransport.jl</code> to adjust the input parameters such that all mentioned features can be simulated will be given in the following.</p><h1 id="Example-1:-Graded-interfaces"><a class="docs-heading-anchor" href="#Example-1:-Graded-interfaces">Example 1: Graded interfaces</a><a id="Example-1:-Graded-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Graded-interfaces" title="Permalink"></a></h1><p>By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to <a href="https://github.com/WIAS-PDELib/ChargeTransport.jl/blob/master/examples/Ex105_PSC_gradedFlux.jl">this</a> example.</p><p>We sketch the relevant parts here. First, we need to import the constants and units.</p><pre><code class="language-julia hljs"># unit factors
@local_unitfactors μm cm s ns V K

# constants
constants = ChargeTransport.constants
(; q, k_B, ε_0) = constants

eV = q * V</code></pre><p>Then, we need to define two additional thin interface layers</p><pre><code class="language-julia hljs">
# region numbers
regionDonor = 1      # n doped region
regionJunction1 = 2
regionIntrinsic = 3  # intrinsic region
regionJunction2 = 4
regionAcceptor = 5   # p doped region</code></pre><p>which need to be taken into account by the initialization of the grid.</p><p>Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be chosen accordingly and we need to construct a nodally dependent parameter struct</p><pre><code class="language-julia hljs">data.fluxApproximation = ScharfetterGummelGraded

paramsnodal = ParamsNodal(grid, numberOfCarriers)</code></pre><p>Finally, we introduce graded parameters. Currently, only a linear grading is implemented.</p><pre><code class="language-julia hljs">paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(
    paramsnodal.bandEdgeEnergy[iphin, :],
    coord, regionTransportLayers, regionJunctions, h,
    heightLayers, lengthLayers, EC
)</code></pre><h2 id="Example-2:-Linear-IV-scan-protocol"><a class="docs-heading-anchor" href="#Example-2:-Linear-IV-scan-protocol">Example 2: Linear IV scan protocol</a><a id="Example-2:-Linear-IV-scan-protocol-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Linear-IV-scan-protocol" title="Permalink"></a></h2><p>Here, we summarize the main parts of <a href="https://github.com/WIAS-PDELib/ChargeTransport.jl/blob/master/examples/Ex103_PSC_IVMeasurement.jl">this</a> example. Define three charge carriers.</p><pre><code class="language-julia hljs">iphin = 1 # electrons
iphip = 2 # holes
iphia = 3 # anion vacancies
numberOfCarriers = 3</code></pre><p>Consider the transient problem and enable the ionic charge carriers only in the active layer:</p><pre><code class="language-julia hljs">data.modelType = Transient
enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])</code></pre><p>Following specification is needed for a linear I-V scan protocol.</p><pre><code class="language-julia hljs">scanrate = 1.0 * V / s
number_tsteps = 31
endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary
tend = endVoltage / scanrate</code></pre><h3 id="Variant-A:-Solve-the-transient-problem-manually"><a class="docs-heading-anchor" href="#Variant-A:-Solve-the-transient-problem-manually">Variant A: Solve the transient problem manually</a><a id="Variant-A:-Solve-the-transient-problem-manually-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-A:-Solve-the-transient-problem-manually" title="Permalink"></a></h3><pre><code class="language-julia hljs">## with fixed timestep sizes we can calculate the times a priori
tvalues = range(0, stop = tend, length = number_tsteps)

for istep = 2:number_tsteps

    t  = tvalues[istep]                  # current time
    Δu = t * scanrate                    # applied voltage
    Δt = t - tvalues[istep-1]            # time step
    set_contact!(ctsys, bregionAcceptor, Δu = Δu)
    solution = solve(ctsys, inival = inival, control = control, tstep = Δt) # provide time step
    inival   = solution

end</code></pre><h3 id="Variant-B:-Use-internal-time-stepping"><a class="docs-heading-anchor" href="#Variant-B:-Use-internal-time-stepping">Variant B: Use internal time stepping</a><a id="Variant-B:-Use-internal-time-stepping-1"></a><a class="docs-heading-anchor-permalink" href="#Variant-B:-Use-internal-time-stepping" title="Permalink"></a></h3><p>To make use of internal time stepping, the scan protocol need to be previously defined, e.g.</p><pre><code class="language-julia hljs">function linearScanProtocol(t)
    if t == Inf
        0.0
    else
        scanrate * t
    end
end

## Apply zero voltage on left boundary and a linear scan protocol on right boundary
contactVoltageFunction = [zeroVoltage, linearScanProtocol]</code></pre><p>And then, need to be parsed into the data construction method</p><pre><code class="language-julia hljs">data = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)</code></pre><p>This makes it possible to use the internal time solving method</p><pre><code class="language-julia hljs">sol = solve(ctsys, inival = inival, times=(0.0, tend), control = control)</code></pre><h2 id="Example-3:-Illumination"><a class="docs-heading-anchor" href="#Example-3:-Illumination">Example 3: Illumination</a><a id="Example-3:-Illumination-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Illumination" title="Permalink"></a></h2><p>Add uniform photogeneration to the previous code by setting</p><pre><code class="language-julia hljs">data.generationModel = GenerationUniform</code></pre><p>and specify the uniform generation rate in each region, i.e.</p><pre><code class="language-julia hljs">for ireg in 1:numberOfRegions
    params.generationUniform[ireg] = generationUniform[ireg]
end</code></pre><p>for given data stored in <code>generationUniform</code>. If one wishes to use the Beer-Lambert generation, then the corresponding code would be</p><pre><code class="language-julia hljs">data.generationModel = GenerationBeerLambert

for ireg in 1:numberOfRegions
    params.generationIncidentPhotonFlux[ireg] = incidentPhotonFlux[ireg]
    params.generationAbsorption[ireg] = absorption[ireg]
end

params.generationPeak = generationPeak</code></pre><p>If one wishes to invert the illumination, one needs to define</p><pre><code class="language-julia hljs">params.invertedIllumination = -1</code></pre><p>where this value is by default set to one (for light entering from the left). Furthermore, we recommend performing a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see this <a href="https://github.com/WIAS-PDELib/ChargeTransport.jl/blob/master/examples/Ex104_PSC_Photogeneration.jl">example</a>.</p><h2 id="Example-4:-Multi-dimensional-problems"><a class="docs-heading-anchor" href="#Example-4:-Multi-dimensional-problems">Example 4: Multi-dimensional problems</a><a id="Example-4:-Multi-dimensional-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Multi-dimensional-problems" title="Permalink"></a></h2><p>It is also possible to perform multi-dimensional simulations.</p><p>For a 2D mesh you may use a structured grid via <a href="https://github.com/WIAS-PDELib/ExtendableGrids.jl">ExtendableGrids.jl</a> or an unstructured mesh via the Julia wrapper <a href="https://github.com/JuliaGeometry/Triangulate.jl">Triangulate.jl</a> for Jonathan Richard Shewchuk&#39;s Triangle mesh generator. Respective examples can be likewise found within this package.</p><p>Lastly, with help of the <a href="https://github.com/JuliaGeometry/TetGen.jl">TetGen.jl</a> wrapper, three-dimensional tetrahedral meshes can be generated, see <a href="https://github.com/WIAS-PDELib/ChargeTransport.jl/blob/master/examples/Grid_3D.jl">this</a> example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../GaAs/">« van Roosbroeck system</a><a class="docs-footer-nextpage" href="../allindex/">Types, Constructors and Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 20 October 2025 13:26">Monday 20 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
