var documenterSearchIndex = {"docs":
[{"location":"GeneralInformation/#[Code-overview]-(@id-generalDescription)","page":"[Code overview] (@id generalDescription)","title":"[Code overview] (@id generalDescription)","text":"The following flow chart explains what needs to be defined when designing new examples. The important information is stored in the Data struct with the most important components listed here.\n\n(Image: Code Structure)","category":"section"},{"location":"module_examples/Ex201_PSC_Textured/#2D-textured-perovskite-solar-cell.","page":"2D textured perovskite solar cell.","title":"2D textured perovskite solar cell.","text":"(source code)\n\nSimulating a three layer textured PSC device with mobile ions. The simulations are performed in 2D on an unstructured grid. This is a minimal example related to the manuscript https://doi.org/10.48550/arXiv.2506.10691.\n\nENV[\"LC_NUMERIC\"] = \"C\" # put this in to work with Triangulate.jl, which is originally written in c++\n\nmodule Ex201_PSC_Textured\n\n    using ChargeTransport\n    using ExtendableGrids\n    using VoronoiFVM\n\n    # For using this example one additionally needs to add Triangulate.\n    # SimplexGridFactory is a wrapper for using this meshgenerator.\n    using SimplexGridFactory\n    using Triangulate\n\n    function generate_grid(; parameter_set, amplitude = 4.0e-7)\n\n        @local_unitfactors nm\n\nuse the destructuring operator to extract all the necessary parameters\n\n        (;\n            h_ETL, h_HTL, regionETL, regionPero, regionHTL, bregionLeft,\n            bregionRight, bregionJ1, bregionJ2, heightDev,\n        ) = parameter_set()\n\nlength of perovskite region depends on amplitude of cos\n\n        h_active = 400 * nm - amplitude / 2 # perovskite\n        heightLayers = [h_ETL, h_ETL + h_active, h_ETL + h_active + h_HTL]\n        h_total = heightLayers[end]\n\n        maxvolume = 2.0e-15\n        eps = 2.0e-10\n\n        # ETL1  C60\n        heightETL1Bottom = 0.0 + 3.0e1 * eps\n\n        heightETL1Top = heightLayers[1] - 20.0 * eps\n        heightETL1Top2 = heightLayers[1] - 20.0 * eps\n        heightETL1Top3 = heightLayers[1] - 20.0 * eps\n        heightETL1Top4 = heightLayers[1] - 20.0 * eps\n        heightETL1Top5 = heightLayers[1] - 20.0 * eps\n        heightETL1Top6 = heightLayers[1] - 20.0 * eps\n\n        # pero\n        heightPeroBottom = heightLayers[1] + 20.0 * eps\n        heightPeroBottom2 = heightLayers[1] + 20.0 * eps\n        heightPeroBottom3 = heightLayers[1] + 20.0 * eps\n        heightPeroBottom4 = heightLayers[1] + 20.0 * eps\n        heightPeroBottom5 = heightLayers[1] + 20.0 * eps\n        heightPeroBottom6 = heightLayers[1] + 20.0 * eps\n\n        heightPeroTop = heightLayers[2] - 20.0 * eps\n        heightPeroTop2 = heightLayers[2] - 20.0 * eps\n        heightPeroTop3 = heightLayers[2] - 20.0 * eps\n        heightPeroTop4 = heightLayers[2] - 20.0 * eps\n        heightPeroTop5 = heightLayers[2] - 20.0 * eps\n        heightPeroTop6 = heightLayers[2] - 20.0 * eps\n\n        heightPero1MaxBottom = 60.0 * nm - 5.0 * nm\n        heightPero1MaxTop = 60.0 * nm + 5.0 * nm\n        heightPero2MaxBottom = 200.0 * nm - 5.0 * nm\n        heightPero2MaxTop = 200.0 * nm + 5.0 * nm\n        heightPero3MaxBottom = 350.0 * nm - 5.0 * nm\n        heightPero3MaxTop = 350.0 * nm + 5.0 * nm\n\nHTL\n\n        heightHTLBottom = heightLayers[2] + 20 * eps\n        heightHTLBottom2 = heightLayers[2] + 20 * eps\n        heightHTLBottom3 = heightLayers[2] + 20 * eps\n        heightHTLBottom4 = heightLayers[2] + 20 * eps\n        heightHTLBottom5 = heightLayers[2] + 20 * eps\n        heightHTLBottom6 = heightLayers[2] + 20 * eps\n\n        heightHTLTop = heightLayers[3] - 3.0e1 * eps\n\n        #############################################\n        ampl = 0.5 * amplitude; phase = pi; period = 7.5e-7\n\n        fCos(x, heightLayer) = ampl .* cos.(phase .+ 2 .* pi .* x ./ period) .+ ampl .+ heightLayer\n        fPlanar(x, heightLayer) = heightLayer\n\n        XFine = collect(range(0.0, heightDev, length = 140))\n\n        b = SimplexGridBuilder(Generator = Triangulate)\n        ###############################################################\n        # first region (SnO2)\n        ###############################################################\n\n        # nodes\n        height_0 = point!(b, heightDev, 0.0)\n        height_n = point!(b, heightDev, heightLayers[1])\n\n        length_0 = point!(b, 0.0, 0.0)\n        length_n = point!(b, 0.0, heightLayers[1])\n\n        # facets\n        facetregion!(b, bregionLeft); facet!(b, height_0, length_0)\n        facetregion!(b, bregionJ1); facet!(b, height_n, length_n)\n        facetregion!(b, 0); facet!(b, length_0, length_n)\n        facet!(b, height_0, height_n)\n\n        # refinement\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightETL1Bottom))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightETL1Bottom))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightETL1Top2))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightETL1Top2))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightETL1Top3))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightETL1Top3))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightETL1Top4))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightETL1Top4))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightETL1Top5))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightETL1Top5))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # regions\n        cellregion!(b, regionETL)\n        regionpoint!(b, 0.0, 0.6 * heightLayers[1])\n        regionpoint!(b, 0.0, 0.99999 * heightETL1Bottom)\n\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top)\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top2)\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top3)\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top4)\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top5)\n        regionpoint!(b, 0.0, 1.00001 * heightETL1Top6)\n\n\n        ###############################################################\n        # second region (perovskite)\n        ###############################################################\n\n        # nodes\n        length_ni = point!(b, 0.0, heightLayers[2])\n        height_ni = point!(b, heightDev, heightLayers[2])\n\n        # facets\n        facet!(b, length_n, length_ni)\n        facet!(b, height_n, height_ni)\n\n        # sinusoidal boundary\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightLayers[2]))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightLayers[2]))\n            facetregion!(b, bregionJ2); facet!(b, A, B)\n        end\n\n        # refinement\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightPeroBottom))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightPeroBottom))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightPeroBottom3))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightPeroBottom3))\n            facet!(b, A, B)\n        end\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightPeroBottom4))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightPeroBottom4))\n            facet!(b, A, B)\n        end\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fPlanar(XFine[ix - 1], heightPeroBottom5))\n            B = point!(b, XFine[ix], fPlanar(XFine[ix], heightPeroBottom5))\n            facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop))\n            facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop2))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop2))\n            facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop3))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop3))\n            facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop4))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop4))\n            facet!(b, A, B)\n        end\n\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop5))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop5))\n            facet!(b, A, B)\n        end\n\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightPeroTop6))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightPeroTop6))\n            facet!(b, A, B)\n        end\n\n        # regions\n        cellregion!(b, regionPero)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom2)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom3)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom4)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom5)\n        regionpoint!(b, 0.0, 0.9999 * heightPeroBottom6)\n        regionpoint!(b, 0.0, 1.5 * heightLayers[1])\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop2)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop3)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop4)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop5)\n        regionpoint!(b, 0.0, 1.0001 * heightPeroTop6)\n\n        regionpoint!(b, 0.0, 0.9999 * heightPero1MaxBottom)\n        regionpoint!(b, 0.0, 0.9999 * heightPero1MaxTop)\n        regionpoint!(b, 0.0, 0.9999 * heightPero2MaxBottom)\n        regionpoint!(b, 0.0, 0.9999 * heightPero2MaxTop)\n        regionpoint!(b, 0.0, 0.9999 * heightPero3MaxBottom)\n        regionpoint!(b, 0.0, 1.0001 * heightPero3MaxBottom)\n        regionpoint!(b, 0.0, 1.0001 * heightPero3MaxTop)\n\n        ###############################################################\n        # third region (PTAA)\n        ###############################################################\n\n        # nodes\n        length_nip = point!(b, 0.0, heightLayers[3])\n        height_nip = point!(b, heightDev, heightLayers[3])\n\n        # facets\n        facet!(b, length_ni, length_nip)\n        facet!(b, height_ni, height_nip)\n\n        # sinusoidal boundary\n        for ix in 2:length(XFine)\n\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightLayers[3]))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightLayers[3]))\n\n            facetregion!(b, bregionRight); facet!(b, A, B)\n\n        end\n\nrefinement\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightHTLBottom))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightHTLBottom))\n            facetregion!(b, 0); facet!(b, A, B)\n        end\n\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightHTLBottom3))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightHTLBottom3))\n            facet!(b, A, B)\n        end\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightHTLBottom4))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightHTLBottom4))\n            facet!(b, A, B)\n        end\n\n        # bottom\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightHTLBottom5))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightHTLBottom5))\n            facet!(b, A, B)\n        end\n\n        # top\n        for ix in 2:length(XFine)\n            A = point!(b, XFine[ix - 1], fCos(XFine[ix - 1], heightHTLTop))\n            B = point!(b, XFine[ix], fCos(XFine[ix], heightHTLTop))\n            facet!(b, A, B)\n        end\n\n\n        # regions\n        cellregion!(b, regionHTL)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom2)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom3)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom4)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom5)\n        regionpoint!(b, 0.0, 0.9999 * heightHTLBottom6)\n\n        regionpoint!(b, 0.0, 1.00001 * heightHTLTop)\n        regionpoint!(b, 0.0, heightLayers[2] + 0.5 * h_HTL)\n\n        ###############################################################\n        # final\n        ###############################################################\n\n        options!(b, maxvolume = maxvolume)\n\n        grid = simplexgrid(b)\n\n        bfacemask!(grid, [0.0, 0.0], [0.0, heightLayers[3]], 0, tol = 1.0e-20)\n        bfacemask!(grid, [heightDev, 0.0], [heightDev, heightLayers[3]], 0, tol = 1.0e-20)\n\n        return grid\n\n    end\n\nyou can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information\n\n    function main(;\n            Plotter = nothing, # only Plotter = PythonPlot or Plotter = PyPlot are supported in this example\n            verbose = false, test = false,\n            amplitude = 0.5e-7,\n            parameter_set = Params_PSC_C60_TripleCation_PTAA, # choose the parameter set\n            vacancyEnergyCalculation = false,                 # assume the vacancy energy level is either given or not\n            vETL = 2000 * ufac\"cm\" / ufac\"s\",                 # surface reco velocity at ETL\n            vHTL = 500 * ufac\"cm\" / ufac\"s\",                  # surface reco velocity at HTL\n        )\n\n        if Plotter !== nothing && (nameof(Plotter) ∉ [:PyPlot, :PythonPlot])\n            error(\"Plotting in Ex201_PSC_Textured is only possible for Plotter = PythonPlot\")\n        end\n\n        if Plotter !== nothing\n            Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n            Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n            Plotter.close(\"all\")\n        end\n\n        ################################################################################\n        if test == false\n            println(\"Define physical parameters and model\")\n        end\n        ################################################################################\n\n        @local_unitfactors V cm m s W nm\n\n        (; q) = ChargeTransport.constants\n\n        ######### primary data for I-V scan protocol ##########\n        endVoltage = 1.2 * V\n        tPrecond = 0.001\n        scanrate = 1.0e3 * V / s\n        tend = endVoltage / scanrate\n\n        # Define scan protocol function\n        function scanProtocolPrecond(t)\n            biasVal = 0.0\n            if data.calculationType == InEquilibrium\n                biasVal = 0.0\n            else\n                if 0.0 <= t && t <= tPrecond\n                    biasVal = endVoltage\n                elseif tPrecond <= t  && t <= tPrecond + tend\n                    biasVal = endVoltage .- scanrate * (t - tPrecond)\n                elseif tend + tPrecond < t  && t <= tPrecond + 2 * tend\n                    biasVal = scanrate * (t - endVoltage / scanrate - tPrecond) # tend = endVoltage / scanrate\n                else\n                    biasVal = 0.0\n                end\n            end\n\nwe need this such that during the computation of the equilibrium solution, we are safe that no bias is applied.\n\n            if !data.generationComplete\n                biasVal = 0.0\n            end\n            return biasVal\n        end\n\nApply zero voltage on left boundary and scan protocol on right boundary\n\n        contactVoltageFunction = [zeroVoltage, scanProtocolPrecond]\n\nparameter\n\n        p = parameter_set()\n\n        ################################################################################\n        if test == false\n            println(\"Set up grid and regions\")\n        end\n        ################################################################################\n\n        grid = generate_grid(parameter_set = parameter_set, amplitude = amplitude)\n\n        if Plotter !== nothing\n            gridplot(grid; Plotter, resolution = (600, 400), linewidth = 0.5, legend = :rc)\n        end\n\n        if !test\n            println(\"*** done\\n\")\n        end\n\n        function BeerLamb(x, y)\n\n            ampl = 0.5 * amplitude\n            phase = pi\n            period = 7.5e-7\n\nlength of perovskite region depends on amplitude of cos\n\n            h_active = 400 * nm - amplitude / 2 # perovskite\n            heightLayers = [p.h_ETL, p.h_ETL + h_active, p.h_ETL + h_active + p.h_HTL]\n\noptical Parameters\n\n            Fph = p.incidentPhotonFlux[p.regionPero]\n            ag = p.absorption[p.regionPero]\n            inv = p.invertedIllumination\n            genPeak = ampl .* cos.(phase .+ 2 .* pi .* x ./ period) .+ ampl .+ heightLayers[2]\n\n            if heightLayers[1] <= y <= ampl .* cos.(phase .+ 2 .* pi .* x ./ period) .+ ampl .+ heightLayers[2]\n                G = Fph .* ag .* exp.(- inv .* ag .* (y .- genPeak))\n            else\n                G = 0\n            end\n\n            return G\n        end\n\n        generationData = zeros(length(grid[Coordinates][1, :]))\n\n        i = 0\n        for  coord in eachcol(grid[Coordinates])\n            i = i + 1\n            x0 = coord[1]\n            y0 = coord[2]\n\n            generationData[i] = BeerLamb(x0, y0)\n\n        end\n\n        # Plot of photogeneration\n\nXX = grid[Coordinates][1, :] YY = grid[Coordinates][2, :]\n\nfigure() tricontourf(XX ./ nm, YY ./ nm, generationData, levels = 40)\n\ncolorbar()\n\n        ################################################################################\n        if test == false\n            println(\"Define System and fill in information about model\")\n        end\n        ################################################################################\n\n        # Initialize Data instance and fill in data\n        data = Data(grid, p.numberOfCarriers, contactVoltageFunction = contactVoltageFunction, generationData = generationData)\n\n        # Possible choices: Stationary, Transient\n        data.modelType = Transient\n\n        data.bulkRecombination = set_bulk_recombination(;\n            iphin = p.iphin, iphip = p.iphip,\n            bulk_recomb_Auger = false,\n            bulk_recomb_radiative = true,\n            bulk_recomb_SRH = true\n        )\n\n        # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n        data.boundaryType[p.bregionLeft] = MixedOhmicSchottkyContact\n        data.boundaryType[p.bregionRight] = MixedOhmicSchottkyContact\n        data.boundaryType[p.bregionJ1] = InterfaceRecombination\n        data.boundaryType[p.bregionJ2] = InterfaceRecombination\n\n        # currently Beer-Lambert not working for textured devices\n        data.generationModel = GenerationUserDefined\n\n        # Present ionic vacancies in perovskite layer\n        # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n        enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionPero])\n\n        if test == false\n            println(\"*** done\\n\")\n        end\n\n        ################################################################################\n        if test == false\n            println(\"Define Params and fill in physical parameters\")\n        end\n        ################################################################################\n\n        data.params = Params(p)\n\n        if !vacancyEnergyCalculation\n            data.params.bandEdgeEnergy[p.iphia, :] .= p.Ea2D\n        end\n\n        data.params.recombinationSRHvelocity[p.iphin, p.bregionJ1] = vETL\n        data.params.recombinationSRHvelocity[p.iphip, p.bregionJ1] = vETL\n\n        data.params.recombinationSRHvelocity[p.iphin, p.bregionJ2] = vHTL\n        data.params.recombinationSRHvelocity[p.iphip, p.bregionJ2] = vHTL\n\n        ctsys = System(grid, data, unknown_storage = :sparse)\n\n        if test == false\n            println(\"*** done\\n\")\n        end\n        ################################################################################\n        if test == false\n            println(\"Define control parameters for Solver\")\n        end\n        ################################################################################\n\n        control = ChargeTransport.SolverControl()\n        control.verbose = verbose\n        control.damp_initial = 0.5\n        control.damp_growth = 1.61 # >= 1\n        control.maxiters = 300\n        control.max_round = 5\n        control.abstol = 1.0e-7\n        control.reltol = 1.0e-7\n        control.tol_round = 1.0e-7\n        control.Δu_opt = Inf\n\n        if test == false\n            println(\"*** done\\n\")\n        end\n\n        ################################################################################\n        if test == false\n            println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n        end\n        ################################################################################\n\n        #data.params.bandEdgeEnergy[3, 2] = -5.267 * eV\n        # Solve for the equilibrium solution in several steps:\n\nPoisson problem is solved,\nFull system is solved in equilibrium with photogeneration turned on,\n\nSince vacancyEnergyCalculation = true, we repeat 1) and 2) until Ea is found (which corresponds to given initial vacancy density p.Ca)\n\n        solEQ = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = vacancyEnergyCalculation)\n        inival = solEQ\n\n        if test == false\n            println(\"*** done\\n\")\n        end\n        ################################################################################\n        if test == false\n            println(\"Loop to increase bias (so that following scan protocol starts near VOC)\")\n        end\n        ################################################################################\n\n        biasLoop = collect(reverse(-range(0.0, endVoltage, length = 21)))\n\n        sol0p0 = ChargeTransport.unknowns(ctsys)\n        for istep in 1:length(biasLoop)\n\n            # turn slowly voltage on\n            set_contact!(ctsys, p.bregionRight, Δu = biasLoop[istep])\n\n            # keep some big time stepping here, so we preserve the vacancy density\n            sol0p0 = ChargeTransport.solve(ctsys, inival = inival, control = control, tstep = 1.0e3)\n            inival = sol0p0\n\n        end # bias loop\n\n        if !test\n            println(\"*** done\\n\")\n        end\n\nNow we have the correct initial condition to start the scan protocol\n\n        ################################################################################\n        if test == false\n            println(\"Preconditioning\")\n        end\n        ################################################################################\n\n        control.Δt = 1.0e-4\n        control.Δt_min = 1.0e-5\n        control.Δt_max = 5.0e-4\n        control.Δt_grow = 1.1\n\n        solPrecond = ChargeTransport.solve(ctsys, inival = inival, times = (0.0, tPrecond), control = control)\n\n        if !test\n            println(\"*** done\\n\")\n        end\n\n        ################################################################################\n        if !test\n            println(\"Reverse IV Measurement loop\")\n        end\n        ################################################################################\n\n        control.Δt = 4.0e-3 / scanrate\n        control.Δt_min = 4.0e-3 / scanrate\n        control.Δt_max = 6.0e-2 / scanrate\n        control.Δt_grow = 1.15\n\n        solRev = ChargeTransport.solve(ctsys, inival = solPrecond.u[end], times = (tPrecond, tPrecond + tend), control = control)\n\n        if !test\n            println(\"*** done\\n\")\n        end\n\n        ################################################################################\n        if !test\n            println(\"Forward IV Measurement loop\")\n        end\n        ################################################################################\n\n        solForw = ChargeTransport.solve(ctsys, inival = solRev.u[end], times = (tPrecond + tend, tPrecond + 2 * tend), control = control)\n\n        if Plotter !== nothing\n            subg = subgrid(grid, [p.regionPero])\n\nhttps://github.com/j-fu/GridVisualize.jl/blob/1f2b299a436b7750702ccca282fa14152d80ebf9/src/pyplot.jl#L86\n\n            function tridata(grid::ExtendableGrid)\n                coord = grid[Coordinates] ./ nm\n                cellnodes = Matrix(grid[CellNodes])\n                return coord[1, :], coord[2, :], transpose(cellnodes .- 1)\n            end\n\n            nn = get_density(solForw.u[1], p.regionPero, ctsys, p.iphin)\n            np = get_density(solForw.u[1], p.regionPero, ctsys, p.iphip)\n            na = get_density(solForw.u[1], p.regionPero, ctsys, p.iphia)\n\n            @show minimum(nn), maximum(nn)\n            @show minimum(np), maximum(np)\n            @show minimum(na), maximum(na)\n\n            figsize = (7.2, 5.6)\n            vmin = 5.0e17; vmax = 6.0e20\n            vminIon = 1.0e22; vmaxIon = 5.0e23\n\n\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(nn...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Electron density (beginning forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            #################\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(np...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Hole density (beginning forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            #################\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(na...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vminIon, vmax = vmaxIon), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Ion density (beginning forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            nn = get_density(solForw.u[end], p.regionPero, ctsys, p.iphin)\n            np = get_density(solForw.u[end], p.regionPero, ctsys, p.iphip)\n            na = get_density(solForw.u[end], p.regionPero, ctsys, p.iphia)\n\n            println(\" \")\n            @show minimum(nn), maximum(nn)\n            @show minimum(np), maximum(np)\n            @show minimum(na), maximum(na)\n\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(nn...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Electron density (end forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            #################\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(np...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Hole density (end forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            #################\n            Plotter.figure(figsize = figsize)\n            Plotter.tripcolor(tridata(subg)..., vcat(na...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vminIon, vmax = vmaxIon), shading = \"gouraud\", rasterized = true)\n            Plotter.xlabel(\" \\$x\\$ [nm]\", fontsize = 17)\n            Plotter.ylabel(\" \\$y\\$ [nm]\", fontsize = 17)\n            Plotter.axis([-20, 770, 20, 800])\n            Plotter.title(\"Ion density (end forward scan)\")\n            Plotter.colorbar(orientation = \"vertical\", label = \" Density [\\$\\\\mathrm{m}^{-3}\\$]\", extend = \"both\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n        end\n\n        if !test\n            println(\"*** done\\n\")\n        end\n\n        ################################################################################\n        if test == false\n            println(\"Forward IV curve calculation\")\n        end\n        ################################################################################\n\n        IV = zeros(0) # for saving I-V data\n        IVn = zeros(0); IVp = zeros(0)\n        IVa = zeros(0); IVψ = zeros(0)\n\n        ######################\n        ISRHn = zeros(0); IRadn = zeros(0)\n        ISRHp = zeros(0); IRadp = zeros(0)\n        ISRnL = zeros(0)\n        ISRnR = zeros(0)\n        IGen = zeros(0)\n\n        tvalues = solForw.t\n        number_tsteps = length(tvalues)\n        biasValues = data.contactVoltageFunction[2].(tvalues[2:end])\n\n        factory = ChargeTransport.TestFunctionFactory(ctsys)\n        tf = ChargeTransport.testfunction(factory, [p.bregionLeft], [p.bregionRight])\n\n        for istep in 2:number_tsteps\n\n            Δt = tvalues[istep] - tvalues[istep - 1] # Time step size\n            inival = solForw.u[istep - 1]\n            solution = solForw.u[istep]\n\n            IEdge = VoronoiFVM.integrate_∇TxFlux(ctsys.fvmsys, tf, solution)\n            IEdgeOld = VoronoiFVM.integrate_∇TxFlux(ctsys.fvmsys, tf, inival)\n\n            push!(IVn, IEdge[p.iphin]); push!(IVp, IEdge[p.iphip])\n            push!(IVψ, (IEdge[p.ipsi] - IEdgeOld[p.ipsi]) / Δt)\n\n            push!(IVa, IEdge[p.iphia])\n            push!(IV, IVψ[istep - 1] + IVn[istep - 1] + IVp[istep - 1] + IVa[istep - 1])\n\n            IntSRH = ChargeTransport.integrate(ctsys, SRHRecombination!, solution)\n            IntRad = ChargeTransport.integrate(ctsys, RadiativeRecombination!, solution)\n            IntSR = ChargeTransport.integrate(ctsys, SRRecombination!, solution, boundary = true)\n            IntGen = ChargeTransport.integrate(ctsys, Photogeneration!, solution)\n\n            IntSRHnSum = 0.0; IntRadnSum = 0.0\n            IntSRHpSum = 0.0; IntRadpSum = 0.0\n\n            for ii in 1:p.numberOfRegions\n                IntSRHnSum = IntSRHnSum - IntSRH[p.iphin, ii]\n                IntRadnSum = IntRadnSum - IntRad[p.iphin, ii]\n\n                IntSRHpSum = IntSRHpSum + IntSRH[p.iphip, ii]\n                IntRadpSum = IntRadpSum + IntRad[p.iphip, ii]\n            end\n\n            IntGenp = IntGen[p.iphip, p.regionPero]\n            IntSRnL = - IntSR[p.iphin, p.bregionJ1]\n            IntSRnR = - IntSR[p.iphin, p.bregionJ2]\n\n            push!(ISRHn, IntSRHnSum); push!(ISRHp, IntSRHpSum)\n            push!(IRadn, IntRadnSum); push!(IRadp, IntRadpSum)\n            push!(ISRnL, IntSRnL)\n            push!(ISRnR, IntSRnR)\n            push!(IGen, IntGenp)\n\n        end\n\n        if Plotter !== nothing\n\n            Plotter.figure()\n            tEnd = tPrecond + 2 * tend\n\n            tt = collect(range(0.0, tEnd, length = 201))\n            T = data.contactVoltageFunction[2]\n            Plotter.plot(tt, T.(tt), marker = \"o\")\n            Plotter.xlabel(\"time [s]\")\n            Plotter.ylabel(\"voltage [V]\")\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            Plotter.figure()\n            Plotter.plot(biasValues, -IV .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"blue\", label = \"forward\")\n\n            Plotter.grid()\n            Plotter.legend()\n            Plotter.xlabel(\"bias [V]\", fontsize = 17)\n            Plotter.ylabel(\"current density [mAcm\\$^{-2} \\$]\", fontsize = 17)\n            Plotter.tick_params(which = \"both\", labelsize = 18)\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n\n            #####################################\n            Plotter.figure()\n            Plotter.semilogy(biasValues, ISRHn .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"blue\", label = \"SRH\")\n            Plotter.semilogy(biasValues, IRadn .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"red\", label = \"rad\")\n            Plotter.semilogy(biasValues, IGen .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"gold\", label = \"Gen\")\n            Plotter.semilogy(biasValues, ISRnL .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"black\", label = \"SR, left\")\n            Plotter.semilogy(biasValues, ISRnR .* (cm^2) .* 1.0e3 ./ p.heightDev, linewidth = 5, color = \"darkgreen\", label = \"SR, right\")\n\n            Plotter.grid()\n            Plotter.legend()\n            Plotter.xlabel(\"bias [V]\", fontsize = 17)\n            Plotter.ylabel(\"current density [mAcm\\$^{-2} \\$]\", fontsize = 17)\n            Plotter.tick_params(which = \"both\", labelsize = 18)\n            Plotter.tight_layout()\n\n            current_figure = Plotter.gcf()\n            display(current_figure)\n        end\n\n        if test == false\n            IV = -IV\n            bias = biasValues\n\n            powerDensity = bias .* (IV)           # power density function\n            MaxPD, indexPD = findmax(powerDensity)\n\n            open_circuit = compute_open_circuit_voltage(bias, IV)\n\n            IncLightPowerDens = 1000.0 * W / m^2\n\n            fillfactor = 100 * (bias[indexPD] * IV[indexPD]) / (IV[1] * open_circuit)\n\n            efficiency = 100 * bias[indexPD] * (IV[indexPD] / p.heightDev) / (IncLightPowerDens)\n            JSC = IV[1] .* (cm)^(2) .* 1.0e3 ./ p.heightDev\n\n            println(\" \")\n            println(\"The JSC                  is $(round(JSC, digits = 3)) mAcm^{-2}.\")\n            println(\"The fill factor          is $(round(fillfactor, digits = 2)) %.\")\n            println(\"The efficiency           is $(round(efficiency, digits = 2)) %.\")\n            println(\"The open circuit voltage is $(round(open_circuit, digits = 4)) V.\")\n            println(\" \")\n        end\n        if test == false\n            integral = integrated_density(ctsys, sol = solEQ, icc = p.iphia, ireg = p.regionPero)\n            mOmega = data.regionVolumes[p.regionPero]\n\n            println(\"Calculated average vacancy density is: \", integral / mOmega)\n            println(\" \")\n            vacancyEnergy = data.params.bandEdgeEnergy[p.iphia, p.regionPero] / q\n            println(\"Value for vacancy energy is: \", vacancyEnergy, \" eV. Save this value for later use.\")\n            println(\" \")\n        end\n\n        testval = sum(filter(!isnan, solForw.u[end])) / length(solForw.u[end]) # when using sparse storage, we get NaN values in solution\n        return testval\n\n    end #  main\n\n    function test()\n        testval = -0.5987199947920246\n        return main(test = true) ≈ testval\n    end\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex108_CIGS/#CIGS:-stationary-with-Schottky-contacts.","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"(source code)\n\nSimulating stationary charge transport for CIGS with mixed Schottky/Ohmic contact conditions. Assume that SRH recombination only happens within a small regime.\n\nmodule Ex108_CIGS\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\n# function to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_pdoping_left, h_pdoping_trap, h_pdoing_right)\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 2 * refinementfactor))\n    coord_pdoping_left = collect(range(h_ndoping, stop = (h_ndoping + h_pdoping_left), length = 3 * refinementfactor))\n    coord_pdoping_plus = collect(\n        range(\n            (h_ndoping + h_pdoping_left),\n            stop = (h_ndoping + h_pdoping_left + h_pdoping_trap),\n            length = refinementfactor\n        )\n    )\n    coord_pdoping_right = collect(\n        range(\n            (h_ndoping + h_pdoping_left + h_pdoping_trap),\n            stop = (h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right),\n            length = 3 * refinementfactor\n        )\n    )\n    coord = glue(coord_ndoping, coord_pdoping_left)\n    coord = glue(coord, coord_pdoping_plus)\n    coord = glue(coord, coord_pdoping_right)\n\n    return coord\nend\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(; n = 3, Plotter = nothing, verbose = false, test = false)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n    (; q, k_B, ε_0, Planck_constant, m_e) = constants\n\n    eV = q * V\n\n    # region numbers\n    regionDonor = 1                           # n doped region\n    regionAcceptorLeft = 2                           # p doped region\n    regionAcceptorTrap = 3                           # p doped region with trap\n    regionAcceptorRight = 4                           # p doped region\n    regions = [regionDonor, regionAcceptorLeft, regionAcceptorTrap, regionAcceptorRight]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor = 1\n    bregionAcceptor = 2\n    bregionDALeft = 3\n    bregionALeftATrap = 4\n    bregionATrapARight = 5\n\n    # grid\n    refinementfactor = 2^(n - 1)\n    h_ndoping = 0.5 * μm\n    h_pdoping_left = 1.0 * μm\n    h_pdoping_trap = 0.1 * μm\n    h_pdoing_right = 1.0 * μm\n    w_device = 0.5 * μm  # width of device\n    z_device = 1.0e-4 * cm  # depth of device\n    h_total = h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right\n    coord = initialize_pin_grid(\n        refinementfactor,\n        h_ndoping,\n        h_pdoping_left,\n        h_pdoping_trap,\n        h_pdoing_right\n    )\n\n    grid = simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [h_ndoping], regionDonor) # n doped\n    cellmask!(grid, [h_ndoping], [h_ndoping + h_pdoping_left], regionAcceptorLeft) # p doped\n    cellmask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left + h_pdoping_trap], regionAcceptorTrap) # p doped with traps\n    cellmask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_total], regionAcceptorRight) # p doped\n\n    bfacemask!(grid, [h_ndoping], [h_ndoping], bregionDALeft, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left], bregionALeftATrap, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_ndoping + h_pdoping_left + h_pdoping_trap], bregionATrapARight, tol = 1.0e-18)\n\nTODO MO: Hier habe ich die Legende weggelassen, sonst werden die Bilder nicht richtig angezeigt bei PythonPlot\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (3, 4), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :none, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin = 1 # index electron quasi Fermi potential\n    iphip = 2 # index hole quasi Fermi potential\n    numberOfCarriers = 2 # electrons and holes\n\n    # physical data\n    T = 300.0 * K\n\n    # band edge energies\n    Ec_ZnO = 3.4 * eV\n    Ev_ZnO = 0.0 * eV\n\n    Ec_CIGS = 3.4 * eV\n    Ev_CIGS = 2.3 * eV\n\n    EC = [Ec_ZnO, Ec_CIGS, Ec_CIGS, Ec_CIGS]\n    EV = [Ev_ZnO, Ev_CIGS, Ev_CIGS, Ev_CIGS]\n\nhole trap energy\n\n    Et = 2.8 * eV\n\n    # effective densities of states\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n\n    NC = [Nc, Nc, Nc, Nc]\n    NV = [Nv, Nv, Nv, Nv]\n\n    # mobilities\n    mun_ZnO = 100 * (cm^2) / (V * s)\n    mup_ZnO = 25 * (cm^2) / (V * s)\n    mun_CIGS = 100.0 * (cm^2) / (V * s)\n    mup_CIGS = 25 * (cm^2) / (V * s)\n\n    μn = [mun_ZnO, mun_CIGS, mun_CIGS, mun_CIGS]\n    μp = [mup_ZnO, mup_CIGS, mup_CIGS, mup_CIGS]\n\n    # relative dielectric permittivity\n    εr_ZnO = 9 * 1.0\n    εr_CIGS = 13.6 * 1.0\n\n    ε = [εr_ZnO, εr_CIGS, εr_CIGS, εr_CIGS]\n\n    # recombination information parameters\n    ni_ZnO = sqrt(Nc * Nv) * exp(-(Ec_ZnO - Ev_ZnO) / (2 * k_B * T))     # intrinsic concentration\n    n0_ZnO = Nc * Boltzmann((Et - Ec_ZnO) / (k_B * T))                   # Boltzmann equilibrium concentration\n    p0_ZnO = ni_ZnO^2 / n0_ZnO                                           # Boltzmann equilibrium concentration\n    ni_CIGS = sqrt(Nc * Nv) * exp(-(Ec_CIGS - Ev_CIGS) / (2 * k_B * T))  # intrinsic concentration\n    n0_CIGS = Nc * Boltzmann((Et - Ec_CIGS) / (k_B * T))                 # Boltzmann equilibrium concentration\n    p0_CIGS = ni_CIGS^2 / n0_CIGS                                        # Boltzmann equilibrium concentration\n\n    p0 = [p0_ZnO, p0_CIGS, p0_CIGS, p0_CIGS]\n    n0 = [n0_ZnO, n0_CIGS, n0_CIGS, n0_CIGS]\n\nset the lifetime value high in all other regions, such that SRH recombination can be neglected there\n\n    SRH_LifeTime = [1.0e100, 1.0e100, 1.0e-3 * ns, 1.0e100]\n\n    Auger = 1.0e-29 * cm^6 / s\n    Radiative = 1.0e-10 * cm^3 / s\n\n    # Schottky contact information\n    An = 4 * pi * q * m_e * k_B^2 / Planck_constant^3\n    Ap = 4 * pi * q * m_e * k_B^2 / Planck_constant^3\n    vn = An * T^2 / (q * Nc)\n    vp = Ap * T^2 / (q * Nv)\n    barrier = 0.7 * eV\n\n    # doping information\n    Nd = 1.0e18 / (cm^3)\n    Na = 5.5e15 / (cm^3)\n\n    # we will impose this applied voltage on one boundary\n    voltageAcceptor = 1.0 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # initialize Data instance and fill in data\n    data = Data(grid, numberOfCarriers)\n    data.modelType = Stationary\n    data.F .= FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    data.boundaryType[bregionAcceptor] = SchottkyContact\n    data.boundaryType[bregionDonor] = OhmicContact\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # physical parameters\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg] = ε[ireg] * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = NC[ireg]\n        params.densityOfStates[iphip, ireg] = NV[ireg]\n        params.bandEdgeEnergy[iphin, ireg] = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg] = EV[ireg]\n        params.mobility[iphin, ireg] = μn[ireg]\n        params.mobility[iphip, ireg] = μp[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime[ireg]\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = n0[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = p0[ireg]\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping -- since we do not set any doping for the traps it is automatically zero\n    params.doping[iphin, regionDonor] = Nd\n    params.doping[iphip, regionAcceptorLeft] = Na\n    params.doping[iphip, regionAcceptorTrap] = Na\n    params.doping[iphip, regionAcceptorRight] = Na\n\n    # values for the schottky contacts\n    params.SchottkyBarrier[bregionAcceptor] = barrier\n    params.bVelocity[iphin, bregionAcceptor] = vn\n    params.bVelocity[iphip, bregionAcceptor] = vp\n\n    data.params = params\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.tol_round = 1.0e-7\n    control.damp_initial = 0.5\n    control.damp_growth = 1.2\n    control.maxiters = 30\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # solve thermodynamic equilibrium and update initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if Plotter !== nothing\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # ##### set legend for plotting routines #####\n        plot_energies!(vis[1, 2], ctsys, solution, \"Equilibrium\", label_energy)\n        plot_densities!(vis[1, 3], ctsys, solution, \"Equilibrium\", label_density)\n        plot_solution!(vis[1, 4], ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Stationary bias loop\")\n    end\n    ################################################################################\n\n    endVoltage = voltageAcceptor       # final bias value\n    biasValues = collect(range(0, stop = endVoltage, length = 52))\n\n    IV = zeros(0)\n    chargeDensities = zeros(0)\n\n    for i in eachindex(biasValues)\n\n        Δu = biasValues[i] # bias\n\n        # Apply new voltage: set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"bias: Δu = $(Δu) V\")\n        end\n\n        # solve time step problems with timestep Δt\n        solution = solve(ctsys, inival = inival, control = control)\n        inival = solution\n\n        # save IV data\n        current = get_current_val(ctsys, solution)\n        push!(IV, w_device * z_device * current)\n\n        # store charge density in donor region (ZnO)\n        push!(chargeDensities, charge_density(ctsys, solution)[regionDonor])\n\n\n    end # bias loop\n\n    # compute static capacitance: check this is correctly computed\n    staticCapacitance = diff(chargeDensities) ./ diff(biasValues)\n\n    # plot solution and IV curve\n    if Plotter !== nothing\n\n        plot_energies!(vis[2, 1], ctsys, solution, \"bias Δu = $(endVoltage) V\", label_energy)\n        plot_densities!(vis[2, 2], ctsys, solution, \"bias Δu = $(endVoltage) V\", label_density)\n        plot_solution!(vis[2, 3], ctsys, solution, \"bias Δu = $(endVoltage) V\", label_solution)\n        plot_IV!(vis[2, 4], biasValues, IV, \"bias Δu = $(biasValues[end]) V\", plotGridpoints = true) # total current\n\n        scalarplot!(\n            vis[3, 1],\n            biasValues[1:length(chargeDensities)],\n            chargeDensities;\n            color = :blue,\n            markershape = :circle,\n            markersize = 8,\n            title = \"Charge density in donor region\",\n            xlabel = L\"\\text{bias [V]}\",\n            ylabel = L\"\\text{Charge density [C]}\"\n        )\n\n        scalarplot!(\n            vis[3, 2],\n            biasValues[1:length(staticCapacitance)],\n            staticCapacitance;\n            color = :blue,\n            markershape = :circle,\n            markersize = 8,\n            title = \"Static capacitance in donor region\",\n            xlabel = L\"\\text{bias [V]}\",\n            ylabel = L\"Static capacitance [$\\frac{C}{V}$]\"\n        )\n\n        reveal(vis)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.3561479172035813\n\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module has successfully recompiled.\")\nend\n\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex204_Laser_simple/#Simple-laser-structure-with-5-layers.","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"(source code)\n\nSimulating a simple laser structure with 5 layers. The layers are defined by their material properties and thicknesses. The simulation will solve the charge transport equations across the layers, taking into account the stimulated recombination in the active region of the laser structure.\n\nmodule Ex204_Laser_simple\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\n\n###########################################################################\nnumberOfColoumns = Dict(\n    \"ref1\" => [2, 4],\n    \"ref2\" => [4, 8],\n    \"ref3\" => [8, 16],\n    \"ref4\" => [16, 32],\n    \"ref5\" => [32, 64]\n)\n\nnumberOfRows = Dict(\n    \"ref1\" => [4, 8, 2, 8, 4],\n    \"ref2\" => [8, 16, 4, 16, 8],\n    \"ref3\" => [16, 32, 8, 32, 16],\n    \"ref4\" => [32, 64, 16, 64, 32],\n    \"ref5\" => [64, 128, 32, 128, 64]\n)\n###################################################################\n\n\"\"\" Initializing X and Y coords for the tesca grid\"\"\"\nfunction tesca_grid(; refinement = 1, Plotter = nothing, airbox = false)\n\n    @local_unitfactors μm\n\n    ncol = numberOfColoumns[\"ref$(refinement)\"]\n    nrow = numberOfRows[\"ref$(refinement)\"]\n\n    widths_columns = [1.0  10.0] * μm\n    heights_rows = [1.0  0.5  0.05  0.5  1.0] * μm\n\n    coord_x1 = collect(range(0.0, widths_columns[1], length = ncol[1] + 1))\n    coord_x2 = collect(range(widths_columns[1], sum(widths_columns[1:2]), length = ncol[2] + 1))\n    X = glue(coord_x1, coord_x2)\n    X = glue(reverse(-X), X)\n\n    coord_y1 = collect(range(0.0, heights_rows[1], length = nrow[1] + 1))\n    coord_y2 = collect(range(heights_rows[1], sum(heights_rows[1:2]), length = nrow[2] + 1))\n    coord_y3 = collect(range(sum(heights_rows[1:2]), sum(heights_rows[1:3]), length = nrow[3] + 1))\n    coord_y4 = collect(range(sum(heights_rows[1:3]), sum(heights_rows[1:4]), length = nrow[4] + 1))\n    coord_y5 = collect(range(sum(heights_rows[1:4]), sum(heights_rows[1:5]), length = nrow[5] + 1))\n    Y = glue(glue(glue(glue(coord_y1, coord_y2), coord_y3), coord_y4), coord_y5)\n\n    grid = simplexgrid(X, Y)\n\n    cellmask!(grid, [X[1], 0.0], [sum(widths_columns), heights_rows[1]], 1)\n    cellmask!(grid, [X[1], heights_rows[1]], [sum(widths_columns), sum(heights_rows[1:2])], 2)\n    cellmask!(grid, [X[1], sum(heights_rows[1:2])], [sum(widths_columns), sum(heights_rows[1:3])], 3)\n    cellmask!(grid, [X[1], sum(heights_rows[1:3])], [sum(widths_columns), sum(heights_rows[1:4])], 4)\n    cellmask!(grid, [X[1], sum(heights_rows[1:4])], [sum(widths_columns), sum(heights_rows[1:5])], 5)\n\nAIR\n\n    cellmask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [sum(widths_columns), sum(heights_rows[1:5])], 6)\n    cellmask!(grid, [X[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows[1:5])], 6)\n\n    bregionDonor1 = 1      # bottom boundary\n    bregionAcceptor2 = 2   # top boundary\n    bregionNoFlux = 3\n    bregionAirBox = 4\n    bfacemask!(grid, [-widths_columns[1], sum(heights_rows)], [widths_columns[1], sum(heights_rows)], bregionAcceptor2)\n    bfacemask!(grid, [X[1], 0.0], [X[end], 0.0], bregionDonor1)\n\n    bfacemask!(grid, [X[1], 0.0], [X[1], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [X[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [-widths_columns[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows)], bregionNoFlux)\n\n    bfacemask!(grid, [X[end], 0.0], [X[end], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [X[end], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [widths_columns[1], sum(heights_rows)], bregionNoFlux)\n\n    bfacemask!(grid, [X[1], sum(heights_rows[1:4])], [X[1], Y[end]], bregionAirBox)\n    bfacemask!(grid, [X[1], Y[end]], [-widths_columns[1], Y[end]], bregionAirBox)\n    bfacemask!(grid, [widths_columns[1], Y[end]], [X[end], Y[end]], bregionAirBox)\n    bfacemask!(grid, [X[end], sum(heights_rows[1:4])], [X[end], Y[end]], bregionAirBox)\n\n    if airbox == false\n        grid = subgrid(grid, [1, 2, 3, 4, 5])\n    end\n\n    if Plotter !== nothing\n        GridVisualize.gridplot(\n            grid; Plotter, linewidth = 1, fontsize = 35, size = (1200, 900),\n            legend = :best, show = true, aspect = 4, colorbar = false, title = \"Device Geometry, values in [m]\", xlabel = \"x-coordinates\", ylabel = \"y-coordinates\"\n        )\n    end\n\n    return grid\nend\n\nfunction main(;\n        refinement = 1,\n        Plotter = nothing,\n        verbose = false, test = false, unknown_storage = :sparse,\n        numberOfEigenvalues = 1,\n        parameter_set = Params_Laser_simple # choose the parameter set\n    )\n\nparameter\n\n    p = parameter_set()\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid.\")\n    end\n    ################################################################################\n\n    grid = tesca_grid(; refinement, Plotter, airbox = false)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers, numberOfEigenvalues = numberOfEigenvalues)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F .= FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    data.boundaryType[p.bregionAcceptor2] = OhmicContact  # top boundary Dirichlet condition\n    data.boundaryType[p.bregionDonor1] = OhmicContact     # bottom boundary Dirichlet condition\n\n                                                # rest is set to Neumann by default\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    \"\"\" Data from Params_Laser_simple.jl: temperature T, band edge energies EC, EV, effective density of states NC, NV\n        mobilities μn, μp, dielectricConstant εs, radiative recombination r0, life times τn, τp,\n        Auger recombination coefficients Auger_Cn, Auger_Cp\n        doping doping (or vcat(Nd,Na) = doping).\n    \"\"\"\n    paramsoptical = ParamsOptical(grid, p.numberOfCarriers, numberOfEigenvalues)\n    paramsoptical.laserWavelength = p.λ\n\n    paramsoptical.absorption_0[:] = p.α0\n    paramsoptical.gain_0[:] = p.gain0\n    paramsoptical.refractiveIndex_0[:] = p.nTilde\n    paramsoptical.refractiveIndex_d[:] = p.nTilde_d\n    paramsoptical.refractiveIndex_γ[:] = p.γn\n    paramsoptical.absorptionFreeCarriers[p.iphin, :] = p.fcnalf\n    paramsoptical.absorptionFreeCarriers[p.iphip, :] = p.fcpalf\n\n    paramsoptical.eigenvalues .= 1 + 1 * im   # dummy value for initializing\n\n    data.params = Params(p)\n    data.paramsoptical = paramsoptical\n\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.abstol = 1.0e-7\n    control.reltol = 1.0e-7\n    control.tol_round = 1.0e-7\n    control.max_round = 3\n    control.damp_initial = 0.8   # < 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and set as initial guess\n    psi0Vector = electroNeutralSolution(ctsys)\n\n    inival = unknowns(ctsys)\n    inival[1, :] = inival[2, :] .= 0.0\n    inival[3, :] = psi0Vector\n\n    solution = equilibrium_solve!(ctsys, inival = inival, control = control, nonlinear_steps = 20.0)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = p.U[end]  # = 1.81 = topVoltageAcceptor2 # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 40)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, p.bregionAcceptor2, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    #########################################################\n\n    ctsys.data.paramsoptical.oldSolution = solution\n    currentSolution = solution\n    inival = solution\n\n    ############################\n    ctsys.data.paramsoptical.eigenvalues = p.λ1\n    ctsys.data.paramsoptical.eigenvectors = reshape(p.v1, length(p.v1), 1)  # reshaping because in system it must be a 2D array\n    ctsys.data.paramsoptical.power = p.P[2]\n\n    solution = solve(ctsys; inival = inival, control = control)\n    ctsys.data.paramsoptical.oldSolution = solution\n    currentSolution = solution\n    inival = solution\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, fignumber = 2, resolution = (1200, 900))\n\n        scalarplot!(\n            vis, grid, solution[1, :]; Plotter, legend = :best, clear = false, title = \"Applied voltage Δu = $maxBias V\",\n            xlabel = \"cross section space along \\$x=0\\$ [m]\", ylabel = \"potentials [V]\", fontsize = 55, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\varphi_n \\$\", color = \"blue\"\n        )\n\n        scalarplot!(\n            vis, grid, solution[2, :], ; Plotter, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\varphi_p \\$\", clear = false, color = \"mediumvioletred\"\n        )\n\n        scalarplot!(\n            vis, grid, solution[3, :]; Plotter, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\psi \\$\", clear = false, color = \"darkorange\"\n        )\n\n        reveal(vis)\n    end\n\n\n    testval = sum(solution) / length(solution)\n    return testval\n\nend # main\n\nfunction test()\n    testval = 0.5122451923673309\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"backgroundinfo/#Mathematical-drift-diffusion-models","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"ChargeTransport.jl aims to discretize charge transport models based on drift-diffusion equations. The bipolar case is sometimes referred to as van Roosbroeck system. This nonlinear system of partial differential equations couples Poisson's equation to several continuity equations. The precise type and amount will vary with the specific application.\n\nIn this section, we would like to describe the mathematical theory a bit more in detail. We denote with alpha the charge carrier, with n_alpha its corresponding density in a device region mathbfOmega during a finite time interval 0 t_F.","category":"section"},{"location":"backgroundinfo/#Poisson's-equation","page":"Mathematical drift-diffusion models","title":"Poisson's equation","text":"Poisson's equation for the electric potential psi is given by\n\nbeginaligned\n- nabla cdot Bigl(varepsilon_s nabla psi(mathbfx t) Bigr) = q sum_alpha z_alpha Bigl( n_alpha(mathbfx t) - C_alpha(mathbfx) Bigr)\nendaligned\n\nHere, varepsilon_s denotes the dielectric permittivity and $ q $ the elementary charge. The right-hand side of Poisson's equation, the space charge density, is the sum of charge carrier densities n_alpha multiplied by their respective charge numbers z_alpha and some corresponding fixed charges, the doping $ C_\\alpha $.","category":"section"},{"location":"backgroundinfo/#Continuity-equations","page":"Mathematical drift-diffusion models","title":"Continuity equations","text":"Poisson's equation is coupled to additional continuity equations for each charge carrier alpha, which describe the motion of free charge carriers in an electric field\n\nbeginaligned\nz_alpha q partial_t n_alpha +  nablacdot mathbfj_alpha\n\t=\n\tz_alpha q\tr_alpha\nendaligned\n\nHere, the flux mathbfj_alpha refers to the the carrier's current density and r_alpha to some production/reduction rates. These rates may be chosen to represent different recombination or generation models such as Shockley-Read-Hall, Auger or direct recombination.\n\nThe amount and type of charge carriers will be dependent on the specific application. The standard semiconductor equations use electrons alpha=n and holes alpha=p.","category":"section"},{"location":"backgroundinfo/#Drift-diffusion-fluxes","page":"Mathematical drift-diffusion models","title":"Drift-diffusion fluxes","text":"Our code uses as independent variables the electrostatic potential psi as well as the quasi Fermi potentials varphi_alpha. The charge carrier densities n_alpha are linked to the corresponding quasi Fermi potentials via the state equations\n\nbeginaligned\nn_alpha = N_alpha mathcalF_alpha Bigl(eta_alpha(psi varphi_alpha) Bigr) quad eta_alpha = z_alpha fracq (varphi_alpha - psi) + E_alphak_B T\nendaligned\n\nwhere the physical parameters are defined in the list of notations. With this definition we can formulate the carrier current given by\n\nbeginaligned\n    mathbfj_alpha\n\t=\n    - (z_alpha)^2 q mu_alpha\n    n_alpha\n    nablavarphi_alpha\n    \nendaligned\n\nwith the negative gradients of the quasi Fermi potentials as driving forces. Using the state equations one may rewrite these fluxes in a drift-diffusion form.\n\nnote: Note\nThe unknowns in ChargeTransport.jl are always defined as the quasi Fermi potentials $ \\varphi_\\alpha$ and the electric potential psi.","category":"section"},{"location":"backgroundinfo/#Boundary-conditions","page":"Mathematical drift-diffusion models","title":"Boundary conditions","text":"Currently, ohmic contacts, Schottky contacts and Schottky barrier lowering boundary conditions are implemented. For further model information, please look closer to the types, constructors and methods section.","category":"section"},{"location":"backgroundinfo/#Background-literature","page":"Mathematical drift-diffusion models","title":"Background literature","text":"For a comprehensive overview of drift-diffusion models, semiconductor applications as well as the underlying numerical methods, we recommend the following sources:\n\nP. Farrell, D. H. Doan, M. Kantner, J. Fuhrmann, T. Koprucki, and N. Rotundo. “Drift-Diffusion Models”. In: Optoelectronic Device Modeling and Simulation: Fundamentals, Materials, Nanostructures, LEDs, and Amplifiers. CRC Press Taylor & Francis Group, 2017, pp. 733–771.\nS. Selberherr. Analysis and Simulation of Semiconductor Devices. Springer-Verlag, 1984.\nS. M. Sze and K. K. Ng. Physics of Semiconductor Devices. Wiley, 2006.","category":"section"},{"location":"backgroundinfo/#notation","page":"Mathematical drift-diffusion models","title":"Notation","text":"symbol physical quantity     symbol physical quantity\n$ \\alpha $ mobile charge carrier     $ n_\\alpha $ charge carrier density of $ \\alpha $\nvarepsilon_s dielectric permittivity     $ \\psi $ electrostatic potential\n$ q $ elementary charge     $ C_\\alpha $ doping/background charge\n$ z_\\alpha $ charge number for $ \\alpha $     $ r_\\alpha $ production/reaction rate for $ \\alpha $\n$ N_\\alpha $ effective density of states for $ \\alpha $     $ \\mathcal{F}_\\alpha $ statistics function\n$ \\varphi_\\alpha $ quasi Fermi potential for $ \\alpha $     $ E_\\alpha $ band-edge energy for $ \\alpha $\n$ k_B $ Boltzmann constant     $ T $ temperature\n$ \\mu_\\alpha $ mobility of carrier $ \\alpha $      ","category":"section"},{"location":"module_examples/Ex102_PIN_nodal_doping/#GaAs-diode-with-spatially-varying-doping-(1D).","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"(source code)\n\nSimulating charge transport in a GaAs pin diode. This means the PDE problem corresponds to the van Roosbroeck system of equations. The simulations are performed out of equilibrium and for the stationary problem. A special feature here is that the doping is node-dependent.\n\nmodule Ex102_PIN_nodal_doping\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(; Plotter = nothing, verbose = false, test = false, unknown_storage = :sparse)\n\nunit factors and constants\n\n    @local_unitfactors μm cm s ns V K ps\n    constants = ChargeTransport.constants\n\n    eV = constants.q * V\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor = 1          # p doped region\n    regionIntrinsic = 2         # intrinsic region\n    regionDonor = 3             # n doped region\n    regions = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor = 1\n    bregionDonor = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    h_pdoping = 0.1 * μm\n    h_intrinsic = 0.1 * μm\n    h_ndoping = 0.1 * μm\n    h_total = h_pdoping + h_intrinsic + h_ndoping\n    w_device = 0.1 * μm  # width of device\n    z_device = 1.0e-5 * cm  # depth of device\n\n    coord = range(0.0, stop = h_ndoping + h_intrinsic + h_pdoping, length = 25)\n    coord = collect(coord)\n    grid = simplexgrid(coord)\n    numberOfNodes = length(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor, tol = 1.0e-15)    # p-doped region = 1\n    cellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic, tol = 1.0e-15)    # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor, tol = 1.0e-15)    # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], bregionAcceptor)     # outer left boundary\n    bfacemask!(grid, [h_total], [h_total], bregionDonor)  # outer right boundary\n    bfacemask!(grid, [h_pdoping], [h_pdoping], bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (3, 3), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # Define the physical data.\n    Ec = 1.424 * eV\n    Ev = 0.0 * eV\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n    mun = 8500.0 * (cm^2) / (V * s)\n    mup = 400.0 * (cm^2) / (V * s)\n    εr = 12.9 * 1.0              # relative dielectric permittivity of GAs\n    T = 300.0 * K\n\n    # recombination parameters\n    SRH_TrapDensity_n = 4.760185435081902e5 / cm^3\n    SRH_TrapDensity_p = 9.996936448738406e6 / cm^3\n    SRH_LifeTime = 1.0 * ps\n\n    # contact voltage\n    voltageAcceptor = 1.4 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\nWe initialize the Data instance and fill in predefined data.\n\n    data = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = false,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor] = OhmicContact\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\nDefine the Params and ParamsNodal struct.\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions           # region data\n\n        params.dielectricConstant[ireg] = εr * constants.ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = mun\n        params.mobility[iphip, ireg] = mup\n\n        # recombination parameters\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity_n\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity_p\n\n    end\n\n    # initialize the space dependent doping (see FarrellPeschka2019, Computers & Mathematics with Applications, 2019).\n    NDoping = 1.0e17 / cm^3\n    κ = 500.0\n    for icoord in 1:numberOfNodes\n        paramsnodal.doping[icoord] = NDoping * 0.5 * (1.0 + tanh((0.1 - coord[icoord] / μm) * κ) - (1.0 + tanh((coord[icoord] / μm - 0.2) * κ)))\n    end\n\n    data.params = params\n    data.paramsnodal = paramsnodal\n\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        show_params(ctsys)\n    end\n\n    if Plotter !== nothing\n        ################################################################################\n        println(\"Plot doping\")\n        ################################################################################\n        plot_doping!(vis[1, 2], grid, paramsnodal)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if Plotter !== nothing\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        plot_energies!(vis[1, 3], ctsys, solution, \"Equilibrium\", label_energy)\n        plot_densities!(vis[2, 1], ctsys, solution, \"Equilibrium\", label_density)\n        plot_solution!(vis[2, 2], ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 41)\n    IV = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu  = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n        # get IV curve\n        factory = TestFunctionFactory(ctsys)\n\n        # testfunction zero in bregionAcceptor and one in bregionDonor\n        tf = testfunction(factory, [bregionAcceptor], [bregionDonor])\n        I = integrate(ctsys, tf, solution)\n\n        push!(IV, abs.(w_device * z_device * (I[iphin] + I[iphip])))\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if Plotter !== nothing # plot solution and IV curve\n\n        plot_energies!(vis[2, 3], ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_energy)\n        plot_densities!(vis[3, 2], ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density, plotGridpoints = true)\n        plot_solution!(vis[3, 1], ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_solution, plotGridpoints = true)\n        plot_IV!(vis[3, 3], biasValues, IV, \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n\n        reveal(vis)\n    end\n\n    testval = solution[15]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.4676876548796856\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module is successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"allindex/#Overview-–-Constants,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Overview – Constants, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"section"},{"location":"allindex/#Methods","page":"Types, Constructors and Methods","title":"Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"section"},{"location":"allindex/#Description-of-Constant,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Description of Constant, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors-2","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/#Methods-2","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/#ChargeTransport.BarrierLoweringType","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringType","text":"Possible types for barrier lowering model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.BoundaryModelType","text":"Possible types of boundary models.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.CalculationType","page":"Types, Constructors and Methods","title":"ChargeTransport.CalculationType","text":"Possible types for calculation type.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.FluxApproximationType","page":"Types, Constructors and Methods","title":"ChargeTransport.FluxApproximationType","text":"Possible types of flux discretization schemes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationModelType","text":"Possible types for generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelType","text":"Possible Types of interface model (interior boundary conditions).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelType","text":"Possible types for the laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.ModelType","text":"Possible types which indicate, if we consider stationary or transient problem.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContactModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContactModelType","text":"Possible mathematical types of ohmic contact boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OuterBoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OuterBoundaryModelType","text":"Possible types of outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.QType","page":"Types, Constructors and Methods","title":"ChargeTransport.QType","text":"Type of charge carriers and the electric potential (corresponding to VoronoiFVM.jl).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SRHWithoutTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithoutTrapsType","text":"Possible type for SRH recombination without traps. Here, additional SRH model can be included, possibly also with dynamic traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.StandardFuncSet","page":"Types, Constructors and Methods","title":"ChargeTransport.StandardFuncSet","text":"Type of statistics functions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.TrapModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.TrapModelType","text":"Data type for trap model\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.constants","page":"Types, Constructors and Methods","title":"ChargeTransport.constants","text":"constants\n\nA globally available object containing the default constants\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.pdelib_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.pdelib_constants","text":"pdelib_constants\n\nconstants with slightly modified values as used in pdelib (https://wias-berlin.de/software/index.jsp?id=pdelib)\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.teSCA_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.teSCA_constants","text":"teSCA_constants\n\nconstants with slightly modified values used in WIAS-TeSCA (https://wias-berlin.de/software/index.jsp?id=TeSCA&lang=0&archive=true)\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.unity_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.unity_constants","text":"unity_constants\n\nunit constants\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.BarrierLoweringOff","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOff","text":"abstract type BarrierLoweringOff\n\nAbstract type for the neglection of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BarrierLoweringOn","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOn","text":"abstract type BarrierLoweringOn\n\nAbstract type for the choice of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BulkRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.BulkRecombination","text":"mutable struct BulkRecombination\n\nA struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.\n\niphin::Int64: Index for FVM construction of electron quasi Fermi potential.\n\niphip::Int64: Index for FVM construction of hole quasi Fermi potential.\n\nbulk_recomb::Bool: Boolean for general present recombination in bulk.\n\nbulk_recomb_Auger::Bool: Boolean for present Auger recombination in bulk.\n\nbulk_recomb_radiative::Bool: Boolean for present radiative recombination in bulk.\n\nbulk_recomb_SRH::Union{Type{ChargeTransport.SRHOff}, Type{ChargeTransport.SRHStationary}}: DataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.\n\nbulk_recomb_trap::Union{Type{ChargeTransport.NoTrap}, Type{ChargeTransport.SingleStateTrap}}: DataType for present trap state in bulk.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Constants","page":"Types, Constructors and Methods","title":"ChargeTransport.Constants","text":"Constants\n\nDefault physical constants (dimensionless) from PhysicalConstants.jl via LessUnitful.jl\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"mutable struct Data{TFuncs<:Function, TVoltageFunc<:Function, TGenerationData<:Union{Array{Float64, 3}, Function, VecOrMat{Float64}}}\n\nA struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.\n\nF::Vector{TFuncs} where TFuncs<:Function: An array with the corresponding distribution function mathcalF_alpha for all carriers alpha.\n\nqFModel::Union{Type{ContQF}, Type{DiscontQF}}: A datatype containing the information, whether at least on quasi Fermi potential is assumed to be continuous or discontinuous.\n\nregionVolumes::Vector{Float64}: An array with the measure of each region of the domain.\n\nboundaryType::Vector{Union{Type{InterfaceNone}, Type{InterfaceRecombination}, Type{MixedOhmicSchottkyContact}, Type{OhmicContact}, Type{SchottkyBarrierLowering}, Type{SchottkyContact}}}: An array of DataTypes with the type of boundary model for each boundary (interior and exterior).\n\ncontactVoltageFunction::Vector{TVoltageFunc} where TVoltageFunc<:Function: An array containing predefined functions for the applied bias in dependence of time at each outer boundary.\n\nbulkRecombination::BulkRecombination: A struct containing information concerning the bulk recombination model.\n\ngenerationData::Union{Array{Float64, 3}, Function, VecOrMat{Float64}}: A function/array containing the user-specific photogeneration rate. It can be a function which is specified in the user example or an array which is read in and calculated with, e.g., an external software.\n\nlaserModel::Union{Type{LaserModelOff}, Type{LaserModelOn}}: A datatype defining whether the user wants to use the laser model or not.\n\nisContinuous::Vector{Bool}: An array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.\n\nchargeCarrierList::Vector{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}: This list stores all charge carriers with the correct type needed for VoronoiFVM.\n\nelectricCarrierList::Vector{Int64}: This list stores all electric carrier indices, i.e. the one of electrons and holes.\n\nionicCarrierList::Vector{ChargeTransport.IonicCarrier}: This list contains all defined ionic carriers as a struct of Type IonicCarrier with all needed information on the ionic carriers (can be either ions or ion vacancies).\n\ntrapCarrierList::Vector{ChargeTransport.TrapCarrier}: This list stores all defined trap carriers as a struct of Type TrapCarrier with all needed information on the trap carriers.\n\nindex_psi::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}: This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.\n\nbarrierLoweringInfo::ChargeTransport.BarrierLoweringSpecies: This is a struct containing all information necessary to simulate Schottky Barrier Lowering.\n\nfluxApproximation::Vector{Union{Type{DiffusionEnhanced}, Type{DiffusionEnhancedModifiedDrift}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}}: A DataType for the flux discretization method.\n\ncalculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}: A DataType for equilibrium or out of equilibrium calculations.\n\nmodelType::Union{Type{Stationary}, Type{Transient}}: A DataType for transient or stationary calculations.\n\ngenerationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}, Type{GenerationUserDefined}}: A DataType for for generation model.\n\nλ1::Float64: An embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.\n\nλ2::Float64: An embedding parameter for the generation rate.\n\nλ3::Float64: An embedding parameter for an electrochemical reaction.\n\ngenerationComplete::Bool: A boolean which helps to influence the applied scan protocol by the user.\n\nohmicContactModel::Union{Type{OhmicContactDirichlet}, Type{OhmicContactRobin}}: Possibility to change the implementation of the ohmic contact boundary model for the electric potential (Dirichlet or Robin)\n\ntempBEE1::Vector{Float64}: Within this template, information concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempBEE2::Vector{Float64}: See the description of tempBEE1.\n\ntempDOS1::Vector{Float64}: Within this template, information concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempDOS2::Vector{Float64}: See the description of tempDOS2.\n\nparams::Params: A struct holding all region dependent parameter information. For more information see struct Params.\n\nparamsnodal::ParamsNodal: A struct holding all space dependent parameter information. For more information see struct ParamsNodal.\n\nparamsoptical::ParamsOptical: A struct holding the physical parameters for the Helmholtz equation simulation in a laser.\n\nconstants::ChargeTransport.Constants: A struct holding the dimensionless physical constants used for the simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"Data(\n    grid,\n    numberOfCarriers;\n    constants,\n    contactVoltageFunction,\n    generationData,\n    statfunctions,\n    numberOfEigenvalues\n) -> Data{StandardFuncSet, T, Vector{Float64}} where T<:Function\n\n\nSimplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.DiffusionEnhanced","page":"Types, Constructors and Methods","title":"ChargeTransport.DiffusionEnhanced","text":"abstract type DiffusionEnhanced\n\nAbstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotential","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotential","text":"abstract type ExcessChemicalPotential\n\nAbstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotentialGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotentialGraded","text":"abstract type ExcessChemicalPotentialGraded\n\nAbstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GeneralizedSG","page":"Types, Constructors and Methods","title":"ChargeTransport.GeneralizedSG","text":"abstract type GeneralizedSG\n\nAbstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationBeerLambert","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationBeerLambert","text":"abstract type GenerationBeerLambert\n\nAbstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationNone","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationNone","text":"abstract type GenerationNone\n\nAbstract type for no generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUniform","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUniform","text":"abstract type GenerationUniform\n\nAbstract type for uniform generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUserDefined","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUserDefined","text":"abstract type GenerationUserDefined\n\nAbstract type for user defined generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.InEquilibrium","text":"abstract type InEquilibrium\n\nAbstract type for equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceNone","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceNone","text":"abstract type InterfaceNone\n\nAbstract type for no interface model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceRecombination","text":"abstract type InterfaceRecombination\n\nAbstract type for surface recombination mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelOff","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelOff","text":"abstract type LaserModelOff\n\nAbstract type for no laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelOn","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelOn","text":"abstract type LaserModelOn\n\nAbstract type for usage of laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.MixedOhmicSchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.MixedOhmicSchottkyContact","text":"Abstract type for a mixed Ohmic and Schottky boundary model, resulting in all Dirichlet type conditions for electrons, holes and the electric potential.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContact","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContact","text":"Abstract type for ohmic contacts as outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OutOfEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.OutOfEquilibrium","text":"abstract type OutOfEquilibrium\n\nAbstract type for out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"mutable struct Params\n\nA struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\nnumberOfRegions::Int64: Number of subregions mathbfOmega_k within the domain mathbfOmega.\n\nnumberOfBoundaryRegions::Int64: Number of boundary regions (partial mathbfOmega)_k such that partial mathbfOmega = cup_k (partial mathbfOmega)_k. Note that here are inner and outer boundaries calculated.\n\nnumberOfCarriers::Int64: Number of moving charge carriers.\n\ninvertedIllumination::Int64: Parameter for the direction of illumination. If illumination is coming from the left, then set this value to 1. Otherwise, if the illumination comes from the right, set this value to -1.\n\ntemperature::Float64: A given constant temperature.\n\nγ::Float64: The parameter of the Blakemore statistics (needed for the generalizedSG flux).\n\nr0::Float64: Prefactor of electro-chemical reaction of internal boundary conditions.\n\nprefactor_SRH::Float64: Prefactor for stationary SRH recombination.\n\ngenerationPeak::Float64: Parameter for the shift of generation peak of the Beer-Lambert generation profile.\n\nSchottkyBarrier::Vector{Float64}: An array for the given Schottky barriers at present Schottky contacts.\n\ncontactVoltage::Vector{Float64}: An array containing a constant value for the applied voltage.\n\nbψEQ::Vector{Float64}: An array containing a constant value for the electric potential in case of Dirichlet boundary conditions.\n\nchargeNumbers::Vector{Float64}: An array with the corresponding charge numbers z_alpha for all carriers alpha.\n\nbBandEdgeEnergy::Matrix{Float64}: An array with the corresponding boundary band-edge energy values E_alpha in each region for each carrier alpha.\n\nbDensityOfStates::Matrix{Float64}: An array with the corresponding boundary effective density of states values N_alpha for each carrier alpha.\n\nbMobility::Matrix{Float64}: A 2D array with the corresponding boundary mobility values mu_alpha in each boundary region for each carrier alpha.\n\nbDoping::Matrix{Float64}: A 2D array with the corresponding boundary doping values for each carrier alpha.\n\nbVelocity::Matrix{Float64}: A 2D array with the corresponding boundary velocity values for each carrier alpha, when assuming Schottky contacts.\n\nbReactionCoefficient::Matrix{Float64}: An array to define the reaction coefficient at internal boundaries.\n\nrecombinationSRHvelocity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.\n\nbRecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary density values for electrons and holes.\n\nbRecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding recombination surface recombination velocities.\n\nbDensityEQ::Matrix{Float64}: A 2D array containing the equilibrium density of electric charge carriers at the boundary.\n\ndoping::Matrix{Float64}: A 2D array with the corresponding doping values for each carrier alpha on each region.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each region.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each region.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each region.\n\nrecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding SRH lifetimes tau_n tau_p for electrons and holes.\n\nrecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding time-independent SRH trap densities n_tau p_tau for electrons and holes.\n\nrecombinationAuger::Matrix{Float64}: A 2D array with the corresponding Auger coefficients for electrons and holes.\n\nrecombinationTrapCaptureRates::Array{Float64, 3}: A 2D array with the trap capture rates\n\ndielectricConstant::Vector{Float64}: A region dependent dielectric constant.\n\ndielectricConstantImageForce::Vector{Float64}: A region dependent image force dielectric constant.\n\ngenerationIncidentPhotonFlux::Vector{Float64}: A region dependent array for the prefactor in the generation process which is the incident photon flux.\n\ngenerationUniform::Vector{Float64}: A region dependent array for an uniform generation rate.\n\ngenerationAbsorption::Vector{Float64}: A region dependent array for the absorption coefficient in the generation process.\n\nrecombinationRadiative::Vector{Float64}: A region dependent array for the radiative recombination rate.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(\n    numberOfRegions,\n    numberOfBoundaryRegions,\n    numberOfCarriers\n) -> Params\n\n\nSimplified constructor for Params which only takes the numberOfRegions, numberOfBoundaryRegions and numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{ExtendableGrids.ExtendableGrid, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(\n    grid::ExtendableGrids.ExtendableGrid,\n    numberOfCarriers\n) -> Params\n\n\nDeprecated!\n\nSimplified constructor for Params which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_Laser_simple}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_Laser_simple\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_PSC_C60_TripleCation_PTAA}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_PSC_C60_TripleCation_PTAA\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_PSC_PCBM_MAPI_Pedot}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_PSC_PCBM_MAPI_Pedot\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_PSC_TiO2_MAPI_spiro}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_PSC_TiO2_MAPI_spiro\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsNodal","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"mutable struct ParamsNodal\n\nA struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\ndielectricConstant::Vector{Float64}: A node dependent dielectric constant.\n\ndoping::Vector{Float64}: A 1D array with the corresponding doping values on each node.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each node.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each node.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each node.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsNodal-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"ParamsNodal(grid, numberOfCarriers) -> ParamsNodal\n\n\nSimplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsOptical","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsOptical","text":"mutable struct ParamsOptical\n\nA struct holding the physical parameters for the Helmholtz equation simulation in a laser.\n\nlaserWavelength::Float64: The wavelength for the laser on hand.\n\npower::Float64: The laser power.\n\nabsorption_0::Vector{Float64}: A region dependent array for the absorption coefficient in the absorption function in the medium.\n\ngain_0::Vector{Float64}: A region dependent array for the gain model coefficient.\n\nrefractiveIndex_0::Vector{Float64}: A region dependent array for the refractive index coefficient.\n\nrefractiveIndex_d::Vector{Float64}: A region dependent array for the second refractive index coefficient.\n\nrefractiveIndex_γ::Vector{Float64}: A region dependent array for the refractive index exponent.\n\neigenvalues::Vector{ComplexF64}: An array of the eigenvalues.\n\nabsorptionFreeCarriers::Matrix{Float64}: A 2D array with the corresponding free carrier absorption values.\n\neigenvectors::Matrix{ComplexF64}: A 2D array with the corresponding eigenvector for eah eigenvalue.\n\noldSolution::Matrix{Float64}: A 2D array with the calculated solutions varphi_n, varphi_p andpsi in all the nodes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsOptical-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsOptical","text":"ParamsOptical(\n    grid,\n    numberOfCarriers,\n    numberOfEigenvalues\n) -> ParamsOptical\n\n\nSimplified constructor for ParamsOptical which only takes the grid, numberOfCarriers and numberOfEigenvalues as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ScharfetterGummel","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummel","text":"abstract type ScharfetterGummel\n\nAbstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ScharfetterGummelGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummelGraded","text":"abstract type ScharfetterGummelGraded\n\nAbstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.SchottkyContact","text":"Abstract type for schottky contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Stationary","page":"Types, Constructors and Methods","title":"ChargeTransport.Stationary","text":"abstract type Stationary\n\nAbstract type for stationary simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"mutable struct System\n\nA struct holding all information necessary for a drift-diffusion type system.\n\ndata::Data: A struct holding all data information, see Data\n\nfvmsys::VoronoiFVM.AbstractSystem: A struct holding system information for the finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"System(grid, data; kwargs...)\n\n\nSystem constructor which builds all necessary information needed based on the input parameters with special regard to the quasi Fermi potential model. This is the main struct in which all information on the input data, but also on the solving system, are stored.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Transient","page":"Types, Constructors and Methods","title":"ChargeTransport.Transient","text":"abstract type Transient\n\nAbstract type for transient simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Blakemore-Tuple{Real, Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Blakemore","text":"Blakemore(x::Real, γ::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with variable real scalar γ, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Boltzmann-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Boltzmann","text":"Boltzmann(x::Real) -> Any\n\n\nThe Boltzmann statistics function exp(x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracMinusOne-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracMinusOne","text":"FermiDiracMinusOne(x::Real) -> Any\n\n\nThe Fermi-Dirac integral of order -1 which reads 1(exp(-x) + 1), see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function F_12 (eta) used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfBednarczyk","text":"FermiDiracOneHalfBednarczyk(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, \"The Approximation of the Fermi-Dirac integral F_12(eta)\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfTeSCA","text":"FermiDiracOneHalfTeSCA(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&id=TeSCA.\n\nModified to use log1p(x)=log(1+x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSContinuityEquations!","text":"RHSContinuityEquations!(f, u, node, data)\n\n\nFunction which builds right-hand side of electric charge carriers.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSPoisson!-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSPoisson!","text":"RHSPoisson!(f, u, node, data, ipsi)\n\n\nFunction which builds right-hand side of Poisson equation, i.e. which builds the space charge density.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport._equilibrium_solve!-Tuple{Val{false}, System}","page":"Types, Constructors and Methods","title":"ChargeTransport._equilibrium_solve!","text":"_equilibrium_solve!(\n    ::Val{false},\n    ctsys::System;\n    inival,\n    control,\n    nonlinear_steps,\n    verbose,\n    yabstol,\n    ytol,\n    maxiter\n)\n\n\nBase implementation of equilibrium_solve: vacancyEnergyCalculation = false\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport._equilibrium_solve!-Tuple{Val{true}, System}","page":"Types, Constructors and Methods","title":"ChargeTransport._equilibrium_solve!","text":"_equilibrium_solve!(\n    ::Val{true},\n    ctsys::System;\n    inival,\n    control,\n    nonlinear_steps,\n    verbose,\n    yabstol,\n    ytol,\n    maxiter\n)\n\n\nExtended implementation of equilibrium_solve: vacancyEnergyCalculation = true. Calculates the energy value for the vacancies via the secant method. We will use this method to calculate suitable values for vacancy energy levels and internally modify the corresponding parameter.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.addTrapCaptureEscape!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.addTrapCaptureEscape!","text":"addTrapCaptureEscape!(f, u, node, data)\n\n\nInclude recombination between bands and traps\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.addTrapCaptureEscape!-Tuple{Any, Any, Any, Any, Type{ChargeTransport.NoTrap}}","page":"Types, Constructors and Methods","title":"ChargeTransport.addTrapCaptureEscape!","text":"addTrapCaptureEscape!(\n    f,\n    u,\n    node,\n    data,\n    _::Type{ChargeTransport.NoTrap}\n)\n\n\nNo trap: Do nothing\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.addTrapCaptureEscape!-Tuple{Any, Any, Any, Any, Type{ChargeTransport.SingleStateTrap}}","page":"Types, Constructors and Methods","title":"ChargeTransport.addTrapCaptureEscape!","text":"addTrapCaptureEscape!(\n    f,\n    u,\n    node,\n    data,\n    _::Type{ChargeTransport.SingleStateTrap}\n)\n\n\nA simple trap with one state that can either be filled or empty\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bflux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bflux!","text":"bflux!(f, u, bedge, data)\n\n\nMaster bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data) -> Any\n\n\nMaster breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactDirichlet}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(\n    f,\n    u,\n    bnode,\n    data,\n    _::Type{OhmicContactDirichlet}\n)\n\n\nCreates ohmic boundary conditions via Dirichlet BC for the electrostatic potential psi\n\npsi  = psi_0 + U,\n\nwhere psi_0 contains some given value and U is an applied voltage.\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for electrons and holes are dirichlet conditions, where\n\nvarphi_alpha = U`\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactRobin}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data, _::Type{OhmicContactRobin})\n\n\nCreates ohmic boundary conditions via a penalty approach with penalty parameter delta. For example, the right-hand side for the electrostatic potential psi is implemented as\n\nfpsi  = -qdelta   ( (p - N_a) - (n - N_d) ),\n\nassuming a bipolar semiconductor. In general, we have for some given charge number z_alpha\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for electrons and holes are dirichlet conditions, where\n\nvarphi_alpha = U`\n\nwith U as an applied voltage.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(\n    f,\n    u,\n    bnode,\n    data,\n    _::Type{SchottkyBarrierLowering}\n)\n\n\nCreates Schottky boundary conditions with additional lowering which are modelled as\n\npsi = - phi_Sq  + sqrt -frac q  nabla_boldsymbolnu psi_mathrmR4pi varepsilon_mathrmi + U,\n\nwhere psi_mathrmR denotes the electric potential with standard Schottky contacts and the same space charge density as psi and where varepsilon_mathrmi corresponds to the image force dielectric constant.\n\nTo solve for this additional boundary conditions the projected gradient nabla_boldsymbolnu psi_mathrmR is stored within a boundary species and calculated in the method generic_operator!().\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bstorage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bstorage!","text":"bstorage!(f, u, bnode, data) -> Any\n\n\nMaster bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Type{ContQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    ::Type{ContQF};\n    kwargs...\n) -> System\n\n\nThe core of the system constructor. Here, the system for continuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Type{DiscontQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    ::Type{DiscontQF};\n    kwargs...\n) -> System\n\n\nThe core of the system constructor. Here, the system for discontinuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-NTuple{8, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(\n    psi0,\n    phi,\n    temperature,\n    EVector,\n    chargeNumbers,\n    dopingVector,\n    dosVector,\n    FVector\n)\n\n\nCompute the charge density, i.e. the right-hand side of Poisson's equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(ctsys, sol) -> Any\n\n\nCompute the charge density for each region separately.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.degenerateLimit-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.degenerateLimit","text":"degenerateLimit(x) -> Any\n\n\nDegenerate limit of incomplete Fermi-Dirac integral of order 1/2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.electroNeutralSolution-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.electroNeutralSolution","text":"electroNeutralSolution(ctsys) -> Any\n\n\nCompute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for psi. The charge carriers may obey different statistics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_ionic_carrier!-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_ionic_carrier!","text":"enable_ionic_carrier!(data; ionicCarrier, regions)\n\n\nThis method takes the user information concerning present ionic charge carriers, builds a struct of Type IonicCarrier and add this struct to the ionicCarrierList.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_trap_carrier!-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_trap_carrier!","text":"enable_trap_carrier!(data; trapCarrier, regions)\n\n\nThis method takes the user information concerning present trap charge carriers, builds a struct of Type TrapCarrier and add this struct to the trapCarrierList.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nThe argument of the statistics function for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nThe argument of the statistics function for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-NTuple{6, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(psi, phi, temperature, E, z, constants) -> Any\n\n\nThe argument of the statistics function for given varphi_alpha and psi\n\nz_alpha  (k_B  T)   ( (varphi_alpha - psi) * q + E_alpha )\n\nThe parameters E_alpha and z_alpha are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}\n) -> Any\n\n\nThe argument of the statistics function for a given solution on a given interior region.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.flux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.flux!","text":"flux!(f, u, edge, data)\n\n\nMaster flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose for each charge carrier. For the displacement flux we use a finite difference approach.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.generic_operator!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.generic_operator!","text":"generic_operator!(f, u, fvmsys, data)\n\n\nGeneric operator to save the projected gradient of electric potential (for system with standard Schottky contacts). Note that this currently only working in one dimension!\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_BEE!-Tuple{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_BEE!","text":"get_BEE!(\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n) -> Any\n\n\nDefining locally the band-edge energy for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_DOS!-Tuple{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_DOS!","text":"get_DOS!(\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n)\n\n\nDefining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for time dependent problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for stationary problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(\n    u,\n    edge::VoronoiFVM.Edge,\n    data,\n    icc\n) -> Tuple{Any, Any}\n\n\nFor given potentials, compute corresponding densities for edges.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(sol, data, icc, ireg; inode) -> Any\n\n\nThe densities for given potentials  varphi_alpha and psi\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}\n) -> Any\n\n\nFor given potentials, compute corresponding densities for given interior region corresponding to a homogeneous set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.integrated_density-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.integrated_density","text":"Method to calculate the integrated carrier densities.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDiffusionEnhancements-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDiffusionEnhancements","text":"plotDiffusionEnhancements(; Plotter)\n\n\nPlot diffusion enhancements.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDistributions-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDistributions","text":"plotDistributions(; Plotter)\n\n\nPlot different distribution integrals.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_IV!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_IV!","text":"plot_IV!(visualizer, biasValues, IV, title; plotGridpoints)\n\n\nMethod for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_densities!-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_densities!","text":"plot_densities!(\n    visualizer,\n    ctsys,\n    solution,\n    title,\n    label_density;\n    plotGridpoints\n)\n\n\nPlotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping!","text":"plot_doping!(visualizer, ctsys, label_density)\n\n\nPossibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_electroNeutralSolutionBoltzmann!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_electroNeutralSolutionBoltzmann!","text":"plot_electroNeutralSolutionBoltzmann!(\n    visualizer,\n    grid,\n    psi0;\n    plotGridpoints\n)\n\n\nPlotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies!","text":"plot_energies!(visualizer, ctsys, label_BEE)\n\n\nWith this method it is possible to depict the band-edge energies E_alpha. This can be useful for debugging when dealing with heterojunctions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_solution!-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_solution!","text":"plot_solution!(\n    visualizer,\n    ctsys,\n    solution,\n    title,\n    label_solution;\n    plotGridpoints\n)\n\n\nMethod for plotting the solution vectors: the electrostatic potential psi as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data)\n\n\nMaster reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{InEquilibrium})\n\n\nReaction in case of equilibrium, i.e. no generation and recombination is considered.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nSets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes   fψ  = - q ((p - N_a) - (n - N_d) ) = - q  sum  n_alpha  (n_alpha - C_alpha) for some doping C_alpha w.r.t. to the species alpha. The right-hand sides for the charge carriers read as fn_alpha =  - z_alpha  q (G -  R) for all charge carriers n_alpha. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented. The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_bulk_recombination-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_bulk_recombination","text":"set_bulk_recombination(\n;\n    iphin,\n    iphip,\n    bulk_recomb_Auger,\n    bulk_recomb_radiative,\n    bulk_recomb_SRH,\n    bulk_recomb_trap\n)\n\n\nCorresponding constructor for the bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data) -> Any\n\n\nMaster storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nThe storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have fn_alpha =  z_alpha  q _t n_alpha and for the electrostatic potential fψ = 0.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.trap_density-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.trap_density","text":"trap_density(icc, ireg, params, Et, constants)\n\n\nCompute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.zeroVoltage-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.zeroVoltage","text":"Function in case of an applied voltage equal to zero at one boundary.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Ex101_PIN/#GaAs-diode-(1D).","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"(source code)\n\nWe simulate charge transport in a GaAs pin diode, where we use the van Roosbroeck system of equations as charge transport model. The unknowns are given by the quasi Fermi potentials of electrons and holes varphi_n, varphi_p and the electric potential psi. The simulations are performed out of equilibrium and for the stationary problem. By default, we assume a Boltzmann relation between densities and potentials.\n\nmodule Ex101_PIN\n\nusing ChargeTransport  # drift-diffusion solver\nusing ExtendableGrids  # grid initializer\nusing GridVisualize\nusing LaTeXStrings\n\n# This function is used to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping = collect(range((h_ndoping + h_intrinsic), stop = (h_ndoping + h_intrinsic + h_pdoping), length = 3 * refinementfactor))\n    coord = glue(coord_ndoping, coord_intrinsic)\n    coord = glue(coord, coord_pdoping)\n\n    return coord\nend\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(; n = 3, Plotter = nothing, verbose = false, test = false, unknown_storage = :sparse)\n\nunit factors and constants\n\n    @local_unitfactors μm cm s ns V K\n    constants = ChargeTransport.constants\n    (; q, k_B, ε_0) = constants\n\n    eV = q * V\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor = 1           # p doped region\n    regionIntrinsic = 2          # intrinsic region\n    regionDonor = 3              # n doped region\n    regions = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor = 1\n    bregionDonor = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    # grid\n    refinementfactor = 2^(n - 1)\n    h_pdoping = 2.0 * μm\n    h_intrinsic = 2.0 * μm\n    h_ndoping = 2.0 * μm\n    h_total = h_pdoping + h_intrinsic + h_ndoping\n    w_device = 0.5 * μm     # width of device\n    z_device = 1.0e-4 * cm  # depth of device\n    coord = initialize_pin_grid(\n        refinementfactor,\n        h_pdoping,\n        h_intrinsic,\n        h_ndoping\n    )\n\n    grid = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor)  # p-doped region = 1\n    cellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions. At exterior boundaries they are\n    # automatically set by ExtendableGridsjl. Thus, there the following two lines are actually\n    # unneccesarry, but are only written for completeness.\n    bfacemask!(grid, [0.0], [0.0], bregionAcceptor)              # outer left boundary\n    bfacemask!(grid, [h_total], [h_total], bregionDonor)         # outer right boundary\n    bfacemask!(grid, [h_pdoping], [h_pdoping], bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (4, 2), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\nWe define the physical data.\n\n    Ec = 1.424 * eV\n    Ev = 0.0 * eV\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n    mun = 8500.0 * (cm^2) / (V * s)\n    mup = 400.0 * (cm^2) / (V * s)\n    εr = 12.9 * 1.0              # relative dielectric permittivity of GAs\n    T = 300.0 * K\n\n    # recombination parameters\n    Auger = 1.0e-29 * cm^6 / s\n    SRH_TrapDensity = 1.0e10 / cm^3\n    SRH_LifeTime = 1.0 * ns\n    Radiative = 1.0e-10 * cm^3 / s\n\n    # doping\n    dopingFactorNd = 1.0\n    dopingFactorNa = 0.46\n    Nd = dopingFactorNd * Nc\n    Na = dopingFactorNa * Nv\n\n    # intrinsic concentration\n    ni = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * k_B * T))\n\n    # contact voltage: we impose an applied voltage only on one boundary.\n    # At the other boundary the applied voltage is zero.\n    voltageAcceptor = 1.5 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\nWe initialize the Data instance and fill in predefined data.\n\n    data = Data(grid, numberOfCarriers)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType = Stationary\n\n    # Here, we need to specify which numbers are associated with electron and hole quasi\n    # Fermi potential. Further, the desired recombination processes can be chosen here.\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Following choices are possible for boundary model: For contacts currently only\n    # OhmicContact and SchottkyContact are possible. For inner boundaries we have\n    # InterfaceNone, InterfaceRecombination.\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor] = OhmicContact\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\nDefine the Params struct. Params contains all necessary physical parameters. If one wants to simulate space-dependent variables, one additionally needs to generate a ParamsNodal struct, see Ex102.\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg] = εr * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = mun\n        params.mobility[iphip, ireg] = mup\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor] = Nd      # data.doping   = [0.0  Na;\n    params.doping[iphin, regionIntrinsic] = ni  #                  ni  0.0;\n    params.doping[iphip, regionAcceptor] = Na   #                  Nd  0.0]\n\nRegion dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.\n\n    data.params = params\n\nIn the last step, we initialize our system with previous data which is likewise dependent on the parameters. It is important that this is in the end, otherwise our VoronoiFVMSys is not dependent on the data we initialized but rather on default data.\n\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        # Here we can show region dependent physical parameters. show_params() only supports\n        # region dependent parameters, but, if one wishes to print nodal dependent parameters,\n        # currently this is possible with println(ctsys.data.paramsnodal). We neglected here,\n        # since in most applications where the numberOfNodes is >> 10 this would results in a\n        # large output in the terminal.\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if Plotter !== nothing\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        psi0 = electroNeutralSolution(ctsys)\n\n        plot_energies!(vis[1, 2], ctsys, label_BEE)\n        plot_doping!(vis[2, 1], ctsys, label_density)\n        plot_electroNeutralSolutionBoltzmann!(vis[2, 2], grid, psi0; plotGridpoints = true)\n\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 50\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.tol_round = 1.0e-8\n    control.damp_initial = 0.5\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 32)\n    IV = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution)\n\n        push!(IV, abs.(w_device * z_device * (current)))\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if Plotter !== nothing\n        ################################################################################\n        println(\"Plot results\")\n        ################################################################################\n\n        plot_energies!(vis[3, 1], ctsys, solution, \"Energies for applied voltage Δu = $(biasValues[end])\", label_energy; plotGridpoints = true)\n        plot_solution!(vis[3, 2], ctsys, solution, \"Solution for applied voltage Δu = $(biasValues[end])\", label_solution; plotGridpoints = true)\n        plot_densities!(vis[4, 1], ctsys, solution, \"Carrier densities for applied voltage Δu = $(biasValues[end])\", label_density, plotGridpoints = true)\n        plot_IV!(vis[4, 2], biasValues, IV, \"IV curve for applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n\n        reveal(vis)\n    end\n\n    testval = solution[15]\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n\nend #  main\n\nfunction test()\n    testval = 1.5068426833371802\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex105_PSC_gradedFlux/#Three-layer-PSC-device-with-graded-interfaces-and-Ohmic-contacts-(1D).","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"(source code)\n\nSimulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD without mobile ions. The simulations are performed out of equilibrium, stationary and with two junctions between perovskite layer and transport layers, to which we refer as graded interfaces. Hence, a graded flux discretization with space dependent band-edge energies and density of states is tested here. The difference here is that we adjusted the order of indexing the quasi Fermi potentials.\n\nThe parameters are based on the default parameter set of Ionmonger (with minor adjustments), such that we can likewise compare with the software Driftfusion, see https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv\n\nmodule Ex105_PSC_gradedFlux\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\n# function for grading the physical parameters\nfunction grading_parameter!(physicalParameter, coord, regionTransportLayers, regionJunctions, h, heightLayers, lengthLayers, values)\n    for ireg in regionTransportLayers\n\n        xcoord = lengthLayers[ireg]:lengthLayers[ireg + 1]\n        physicalParameter[xcoord] .= values[ireg]\n\n    end\n\n    for ireg in regionJunctions\n\n        xcoord = lengthLayers[ireg]:lengthLayers[ireg + 1]\n        left = lengthLayers[ireg] - 3\n        junction = h[ireg]\n        right = lengthLayers[ireg + 2] - 3\n\n        gradient = (physicalParameter[right] - physicalParameter[left]) / junction\n\n        for index in xcoord\n            physicalParameter[index] = physicalParameter[left] + (coord[index] - heightLayers[ireg - 1]) * gradient\n        end\n\n    end\n\n    return physicalParameter\nend\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(; n = 2, Plotter = nothing, verbose = false, test = false, unknown_storage = :sparse)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n\n    eV = constants.q * V\n\n    # region numbers\n    regionDonor = 1          # n doped region\n    regionJunction1 = 2\n    regionIntrinsic = 3          # intrinsic region\n    regionJunction2 = 4\n    regionAcceptor = 5          # p doped region\n    regions = [regionDonor, regionJunction1, regionIntrinsic, regionJunction2, regionAcceptor]\n    regionTransportLayers = [regionDonor, regionIntrinsic, regionAcceptor]\n    regionJunctions = [regionJunction1, regionJunction2]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor = 1\n    bregionAcceptor = 2\n    bregionDJ1 = 3\n    bregionJ1I = 4\n    bregionIJ2 = 5\n    bregionJ2A = 6\n\n    # grid\n    h_ndoping = 9.9e-6 * cm\n    h_junction1 = 1.0e-7 * cm\n    h_intrinsic = 4.0e-5 * cm\n    h_junction2 = 1.0e-7 * cm\n    h_pdoping = 1.99e-5 * cm\n    h_total = h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping\n    h = [h_ndoping, h_junction1, h_intrinsic, h_junction2, h_pdoping]\n    heightLayers = [\n        h_ndoping,\n        h_ndoping + h_junction1,\n        h_ndoping + h_junction1 + h_intrinsic,\n        h_ndoping + h_junction1 + h_intrinsic + h_junction2,\n        h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping,\n    ]\n    refinementfactor = 2^(n - 1)\n\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 4 * refinementfactor))\n    length_n = length(coord_ndoping)\n    coord_junction1 = collect(\n        range(\n            h_ndoping,\n            stop = h_ndoping + h_junction1,\n            length = 3 * refinementfactor\n        )\n    )\n    coord_intrinsic = collect(\n        range(\n            h_ndoping + h_junction1,\n            stop = (h_ndoping + h_junction1 + h_intrinsic),\n            length = 10 * refinementfactor\n        )\n    )\n    coord_junction2 = collect(\n        range(\n            h_ndoping + h_junction1 + h_intrinsic,\n            stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n            length = 3 * refinementfactor\n        )\n    )\n    coord_pdoping = collect(\n        range(\n            (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n            stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping),\n            length = 4 * refinementfactor\n        )\n    )\n\n    coord = glue(coord_ndoping, coord_junction1)\n    length_j1 = length(coord)\n    coord = glue(coord, coord_intrinsic)\n    length_i = length(coord)\n    coord = glue(coord, coord_junction2)\n    length_j2 = length(coord)\n    coord = glue(coord, coord_pdoping)\n\n    grid = simplexgrid(coord)\n    numberOfNodes = length(coord)\n    lengthLayers = [1, length_n, length_j1, length_i, length_j2, numberOfNodes]\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [heightLayers[1]], regionDonor)      # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionJunction1)  # first junction   = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionIntrinsic)  # intrinsic region = 3\n    cellmask!(grid, [heightLayers[3]], [heightLayers[4]], regionJunction2)  # sec. junction    = 4\n    cellmask!(grid, [heightLayers[4]], [heightLayers[5]], regionAcceptor)   # p-doped region   = 5\n\ninner interfaces\n\n    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionDJ1)\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ1I)\n    bfacemask!(grid, [heightLayers[3]], [heightLayers[3]], bregionIJ2)\n    bfacemask!(grid, [heightLayers[4]], [heightLayers[4]], bregionJ2A)\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (4, 2), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 2 # electron quasi Fermi potential\n    iphip = 1 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # temperature\n    T = 300.0 * K\n\n    # band edge energies\n    Ec_d = -4.0 * eV\n    Ev_d = -6.0 * eV\n\n    Ec_i = -3.7 * eV\n    Ev_i = -5.4 * eV\n\n    Ec_a = -3.1 * eV\n    Ev_a = -5.1 * eV\n\n    # these parameters at the junctions for E_\\alpha and N_\\alpha will be overwritten.\n    Ec_j1 = Ec_d;     Ec_j2 = Ec_i\n    Ev_j1 = Ev_d;     Ev_j2 = Ev_i\n\n    EC = [Ec_d, Ec_j1, Ec_i, Ec_j2, Ec_a]\n    EV = [Ev_d, Ev_j1, Ev_i, Ev_j2, Ev_a]\n\n    # effective densities of state\n    Nc_d = 5.0e19 / (cm^3)\n    Nv_d = 5.0e19 / (cm^3)\n\n    Nc_i = 8.1e18 / (cm^3)\n    Nv_i = 5.8e18 / (cm^3)\n\n    Nc_a = 5.0e19 / (cm^3)\n    Nv_a = 5.0e19 / (cm^3)\n\n    Nc_j1 = Nc_d;     Nc_j2 = Nc_i\n    Nv_j1 = Nv_d;     Nv_j2 = Nv_i\n\n    NC = [Nc_d, Nc_j1, Nc_i, Nc_j2, Nc_a]\n    NV = [Nv_d, Nv_j1, Nv_i, Nv_j2, Nv_a]\n\n    # mobilities\n    μn_d = 3.89 * (cm^2) / (V * s)\n    μp_d = 3.89 * (cm^2) / (V * s)\n\n    μn_i = 6.62e1 * (cm^2) / (V * s)\n    μp_i = 6.62e1 * (cm^2) / (V * s)\n\n    μn_a = 3.89e-1 * (cm^2) / (V * s)\n    μp_a = 3.89e-1 * (cm^2) / (V * s)\n\n    μn_j1 = μn_d;     μn_j2 = μn_i\n    μp_j1 = μp_d;     μp_j2 = μp_i\n\n    μn = [μn_d, μn_j1, μn_i, μn_j2, μn_a]\n    μp = [μp_d, μp_j1, μp_i, μp_j2, μp_a]\n\n    # relative dielectric permittivity\n    ε_d = 10.0 * 1.0\n    ε_i = 24.1 * 1.0\n    ε_a = 3.0 * 1.0\n\n    ε_j1 = ε_d;       ε_j2 = ε_a\n\n    ε = [ε_d, ε_j1, ε_i, ε_j2, ε_a]\n\n    # radiative recombination\n    r0_d = 0.0e+0 * cm^3 / s\n    r0_i = 1.0e-12 * cm^3 / s\n    r0_a = 0.0e+0 * cm^3 / s\n\n    r0_j1 = r0_i;      r0_j2 = r0_i\n\n    r0 = [r0_d, r0_j1, r0_i, r0_j2, r0_a]\n\n    # life times and trap densities\n    τn_d = 1.0e100 * s\n    τp_d = 1.0e100 * s\n\n    τn_i = 3.0e-10 * s\n    τp_i = 3.0e-8 * s\n    τn_a = τn_d\n    τp_a = τp_d\n\n    τn_j1 = τn_i;     τn_j2 = τn_a\n    τp_j1 = τp_i;     τp_j2 = τp_a\n\n    τn = [τn_d, τn_j1, τn_i, τn_j2, τn_a]\n    τp = [τp_d, τp_j1, τp_i, τp_j2, τp_a]\n\n    # SRH trap energies (needed for calculation of trap_density (SRH))\n\nEid             = -5.0                 * eV Eii             = -4.55                * eV Ei_a             = -4.1                 * eV\n\nEij1            = Eid;      Eij2     = Eii\n\nEI               = [Eid, Eij1, Eii, Eij2, Ei_a]\n\n    # reference densities\n    nτ_d = 7.94e8 / m^3\n    pτ_d = 7.94e8 / m^3\n\n    nτ_i = 4.26e10 / m^3\n    pτ_i = 3.05e10 / m^3\n    nτ_a = nτ_d\n    pτ_a = pτ_d\n\n    nτ_j1 = nτ_i;     nτ_j2 = nτ_a\n    pτ_j1 = pτ_i;     pτ_j2 = pτ_a\n\n    nτ = [nτ_d, nτ_j1, nτ_i, nτ_j2, nτ_a]\n    pτ = [pτ_d, pτ_j1, pτ_i, pτ_j2, pτ_a]\n\n    # Auger recombination\n    Auger = 0.0\n\n    # doping (doping values are from Driftfusion)\n    Nd = 1.03e18 / (cm^3)\n    Na = 1.03e18 / (cm^3)\n    Ni_acceptor = 8.32e7 / (cm^3)\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionDonor] = OhmicContact\n    data.boundaryType[bregionAcceptor] = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    # Default is ExcessChemicalPotential. Here, we need a graded variant\n    data.fluxApproximation .= ScharfetterGummelGraded\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # for region dependent parameters\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    # for space dependent parameters\n    paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    # nodal band-edge energies\n    paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(\n        paramsnodal.bandEdgeEnergy[iphin, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, EC\n    )\n    paramsnodal.bandEdgeEnergy[iphip, :] = grading_parameter!(\n        paramsnodal.bandEdgeEnergy[iphip, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, EV\n    )\n    # nodal effective density of states\n    paramsnodal.densityOfStates[iphin, :] = grading_parameter!(\n        paramsnodal.densityOfStates[iphin, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, NC\n    )\n    paramsnodal.densityOfStates[iphip, :] = grading_parameter!(\n        paramsnodal.densityOfStates[iphip, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, NV\n    )\n\n    for ireg in 1:numberOfRegions  ## region dependent data\n\n        # mobility\n        params.mobility[iphin, ireg] = μn[ireg]\n        params.mobility[iphip, ireg] = μp[ireg]\n\n        params.dielectricConstant[ireg] = ε[ireg] * constants.ε_0\n        # recombination parameters\n        params.recombinationRadiative[ireg] = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg] = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg] = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = nτ[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = pτ[ireg]\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor] = Nd\n    params.doping[iphip, regionIntrinsic] = Ni_acceptor\n    params.doping[iphip, regionAcceptor] = Na\n\n    data.params = params\n    data.paramsnodal = paramsnodal\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 200\n    control.abstol = 1.0e-13\n    control.reltol = 1.0e-13\n    control.tol_round = 1.0e-13\n    control.damp_initial = 0.5\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if Plotter !== nothing\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        plot_energies!(vis[1, 2], ctsys, solution, \"Equilibrium\", label_energy)\n        plot_densities!(vis[2, 1], ctsys, solution, \"Equilibrium\", label_density)\n\nTODO MO: phip wird nicht angezeigt, auch mit dem ursprünglichen Plotting, stimmt das so?\n\n        plot_solution!(vis[2, 2], ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 13)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu) V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival = solution\n\n    end # bias loop\n\n    # plotting\n    if Plotter !== nothing\n        plot_energies!(vis[3, 1], ctsys, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        plot_densities!(vis[3, 2], ctsys, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        plot_solution!(vis[4, 1], ctsys, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n\n        reveal(vis)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[data.index_psi, 20]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -3.982748467515117\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex202_PSC_tensorGrid/#PSC-device-on-2D-domain-(Tensor-grid).","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"(source code)\n\nSimulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions. The simulations are performed in 2D on a tensor grid, out of equilibrium and with abrupt interfaces.\n\nmodule Ex202_PSC_tensorGrid\n\nusing ChargeTransport\nusing ExtendableGrids\n\nyou can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information\n\nfunction main(;\n        n = 3,\n        Plotter = nothing, # only Plotter = PythonPlot or Plotter = PyPlot are supported in this example\n        verbose = false, test = false,\n        parameter_set = Params_PSC_PCBM_MAPI_Pedot, # choose the parameter set\n        vacancyEnergyCalculation = true,            # assume the vacancy energy level is either given or not\n    )\n\n    if Plotter !== nothing && (nameof(Plotter) ∉ [:PyPlot, :PythonPlot])\n        error(\"Plotting in Ex202_PSC_tensorGrid is only possible for Plotter = PythonPlot\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W\n\nparameter\n\n    p = parameter_set()\n\n    height = 5.0e-6 * cm\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 0.4 * V / s\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    # with fixed timestep sizes we can calculate the times a priori\n    tend = endVoltage / scanrate\n\n    # Define scan protocol function\n    function linearScanProtocol(t)\n        return if t == Inf\n            0.0\n        else\n            scanrate * t\n        end\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.6 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (5.1 * δ), p.h_intrinsic / (1.0 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (1.0 * δ), p.h_intrinsic / (5.1 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.3 * δ), p.h_pdoping / (0.3 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (0.6 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord_length = glue(coord, coord_p_u, tol = 10 * t)\n\n    height_L = geomspace(0.0, height / 2, height / (0.4 * δ), height / (0.4 * δ))\n    height_R = geomspace(height / 2, height, height / (0.4 * δ), height / (0.4 * δ))\n    coord_height = glue(height_L, height_R, tol = 10 * t)\n\n    grid = simplexgrid(coord_length, coord_height)\n\n    # specify inner regions\n    cellmask!(grid, [0.0, 0.0], [p.h_ndoping, height], p.regionDonor, tol = 1.0e-18)\n    cellmask!(grid, [p.h_ndoping, 0.0], [p.h_ndoping + p.h_intrinsic, height], p.regionIntrinsic, tol = 1.0e-18)\n    cellmask!(grid, [p.h_ndoping + p.h_intrinsic, 0.0], [p.h_total, height], p.regionAcceptor, tol = 1.0e-18)\n\n    # specify outer regions\n    # metal interfaces [xmin, ymin], [xmax, ymax]\n    bfacemask!(grid, [0.0, 0.0], [0.0, height], p.bregionDonor)                           # BregionNumber = 1\n    bfacemask!(grid, [p.h_total, 0.0], [p.h_total, height], p.bregionAcceptor)            # BregionNumber = 2\n    bfacemask!(grid, [p.heightLayers[1], 0.0], [p.heightLayers[1], height], p.bregionJ1)  # BregionNumber = 3\n    bfacemask!(grid, [p.heightLayers[2], 0.0], [p.heightLayers[2], height], p.bregionJ2)  # BregionNumber = 4\n\n    # no flux interfaces\n    bfacemask!(grid, [0.0, 0.0], [p.h_total, 0.0], 0)\n    bfacemask!(grid, [0.0, height], [p.h_total, height], 0)\n\n    if Plotter !== nothing\n        gridplot(grid; Plotter, resolution = (600, 400), linewidth = 0.5, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[p.iphin] = FermiDiracOneHalfTeSCA\n    data.F[p.iphip] = FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n\n    if !vacancyEnergyCalculation\n        data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] = p.Ea[p.regionIntrinsic]\n    end\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.max_round = 5\n    control.damp_initial = 0.1\n    control.damp_growth = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = vacancyEnergyCalculation)\n    inival = solution\n\n    if Plotter !== nothing\n        ipsi = data.index_psi\n        X = grid[Coordinates][1, :]\n        Y = grid[Coordinates][2, :]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[p.iphin, :])\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement\")\n    end\n    ################################################################################\n\n    control.Δt = 5.0e-2\n    control.Δt_grow = 1.03\n    # calculation of solution\n    sol = ChargeTransport.solve(ctsys, inival = inival, times = (0.0, tend), control = control)\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n\n    # for saving I-V data\n    IV = zeros(0) # for IV values\n    biasValues = zeros(0) # for bias values\n\n    for istep in 2:number_tsteps\n\n        Δt = t - tvalues[istep - 1]  # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n        push!(IV, current)\n\n        inival = solution\n\n    end # time loop\n\n    biasValues = contactVoltageFunction[p.bregionAcceptor].(tvalues)\n\n    if Plotter !== nothing\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[p.iphin, :])\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n\n        ################\n        Plotter.figure()\n        Plotter.plot(biasValues[2:end], IV .* (cm)^2 / height, label = \"\", linewidth = 3, marker = \"o\")\n        Plotter.grid()\n        Plotter.ylabel(\"total current [A]\")\n        Plotter.xlabel(\"Applied Voltage [V]\")\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n    end\n\n    if test == false\n        integral = integrated_density(ctsys, sol = solution, icc = p.iphia, ireg = p.regionIntrinsic)\n\n        println(\" \")\n        println(\"Calculated average vacancy density is: \", integral / data.regionVolumes[p.regionIntrinsic])\n        println(\" \")\n        if vacancyEnergyCalculation\n            vacancyEnergy = data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] / data.constants.q\n            println(\"Value for vacancy energy is: \", vacancyEnergy, \" eV. Save this value for later use.\")\n            println(\"We recommend to calculate it on a fine grid.\")\n            println(\" \")\n        end\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -0.5862627265480347; testvalvacancyEnergyCalculation = -0.5871876928952634\n    return main(test = true) ≈ testval && main(test = true, vacancyEnergyCalculation = false) ≈ testvalvacancyEnergyCalculation\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"PSC/#Perovskite-solar-cell","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We simulate charge transport in perovskite solar cells (PSCs), where we have apart from holes and electrons also ionic charge carriers. Here, we assume to have three domains, denoted by mathbfOmega = mathbfOmega_textHTL cup mathbfOmega_textPVK cup mathbfOmega_textETL   The unknowns are the quasi Fermi potentials of electrons holes and anion vacancies varphi_n varphi_p varphi_a as well as the electric potential psi. The underlying PDEs are given by\n\nbeginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (n_textp(psi varphi_textp) - C_textp ) - (n_textn(psi varphi_textn) - C_textn) Big)\n\tq partial_t n_textn(psi varphi_textn) - nabla cdot mathbfj_textn = qBigl(G(mathbfx) - R(n_textnn_textp) Bigr) \n\tq partial_t n_textp(psi varphi_textp) + nabla cdot mathbfj_textp = Bigl(G(mathbfx) - R(n_textnn_textp) Bigr)\nendaligned\n\nfor mathbfx in mathbfOmega_textHTL cup  mathbfOmega_textETL  t in 0 t_F. In the middle, intrinsic region ($ \\mathbf{x} \\in \\mathbf{\\Omega}_{\\text{PVK}} $), we have\n\nbeginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( n_textp(psi varphi_textp)  - n_textn(psi varphi_textn) + n_texta(psi varphi_texta) - C_texta Big)\nq partial_t n_textn(psi varphi_textn)\t- nabla cdot mathbfj_textn = Bigl(G(mathbfx) - R(n_textnn_textp) Bigr) \n\tq partial_t n_textp(psi varphi_textp) + nabla cdot mathbfj_textp = Bigl(G(mathbfx) - R(n_textnn_textp) Bigr)\n\tq partial_t n_texta(psi varphi_texta) + nabla cdot mathbfj_texta = 0\nendaligned\n\nsee Abdel2021.\n\nDifferences to the previous example include\n\nan additional charge carrier (the anion vacancy)\nparameter jumps across heterojunctions\nthe transient case\na generation rate G\nhigher dimensional problem.","category":"section"},{"location":"PSC/#Simulating-electronic-ionic-charge-transport","page":"Perovskite solar cell","title":"Simulating electronic-ionic charge transport","text":"For example, for perovskite solar cells an average vacancy density is given in literature. If the charge carrier densities are used as the set of unknowns, the initial condition for the anion vacancy density can be given by\n\nbeginaligned\n\tn_texta^0 = C_texta\nendaligned\n\nwhere C_texta corresponds to the uniform density of cation vacancies and is set equal to the average anion vacancy density to ensure global charge neutrality. With homogeneous no-flow Neumann boundary conditions around the perovskite layer for the anion vacancies, the total mass of anions is conserved at all times, i.e.\n\nbeginaligned\n\tfrac1Omega_textPVK  int_Omega_textPVK n_texta (mathbfx t) dmathbfx\n    = frac1Omega_textPVK   int_Omega_textPVK n_texta^0 (mathbfx) dmathbfx\n    = C_texta quad textfor all quad t geq 0\nendaligned\n\nSince we do not use charge carrier densities directly but instead employ quasi Fermi potentials as the unknowns, due to mathematical, physical, and numerical advantages, we must find a workaround to properly fix the initial condition for the vacancy density.","category":"section"},{"location":"PSC/#Quasi-Fermi-potential-notation","page":"Perovskite solar cell","title":"Quasi Fermi potential notation","text":"The statistical relation between the vacancy density and the potentials (our chosen unknowns) reads\n\nbeginaligned\n    n_texta  = N_texta  F_-1 Bigl(eta_texta (psi varphi_texta ) Bigr) quad eta_texta  = z_texta  fracq (varphi_texta  - psi) + E_texta k_B T\nendaligned\n\nwhere N_texta denotes the maximum vacancy density allowed, F_-1 = (exp(-x) +1)^-1 is the Fermi-Dirac integral of order -1, and we refer to E_texta is the intrinsic vacancy energy level (somehow a model parameter). In equilibrium, we set the vacancy quasi-Fermi potential to zero, i.e., varphi_texta = 0, when the applied voltage is V = 0. Because the initial condition for the vacancy density is prescribed as C_texta and the electric potential psi is an unknown, the only remaining free parameter is the vacancy energy E_texta.\n\nThe value of E_texta must be chosen such that the average vacancy density remains conserved for all time steps.","category":"section"},{"location":"PSC/#Current-way-of-handling-E_\\text{a}","page":"Perovskite solar cell","title":"Current way of handling E_texta","text":"We implement a method that calculates the appropriate Ea values internally via the secant method. To make use of this feature, you can add in the equilibrium solving the flag vacancyEnergyCalculation=true.\n\nsolution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = true)\n\nTo check, if, indeed, the average vacancy density is maintained, you can calculate that value and print the chosen vacancy energy level.\n\nintegral = integrated_density(ctsys, sol = solution, icc = iphia, ireg = regionIntrinsic)\n\nprintln(\"Calculated average vacancy density is: \", integral / data.regionVolumes[regionIntrinsic])\n\nvacancyEnergy = data.params.bandEdgeEnergy[iphia, regionIntrinsic] / data.constants.q\nprintln(\"Value for vacancy energy is: \", vacancyEnergy, \" eV\")","category":"section"},{"location":"PSC/#Remarks","page":"Perovskite solar cell","title":"Remarks","text":"For 1D simulations, this approach is sufficient.\nFor multi-dimensional simulations, however, we recommend precomputing the Ea values and storing them in case of multiple computations with the same parameter set.\n\nNext, we give a quick survey on how to use ChargeTransport.jl to adjust the input parameters such that all mentioned features can be simulated will be given in the following.","category":"section"},{"location":"PSC/#Example-1:-Graded-interfaces","page":"Perovskite solar cell","title":"Example 1: Graded interfaces","text":"By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to this example.\n\nWe sketch the relevant parts here. First, we need to import the constants and units.\n\n# unit factors\n@local_unitfactors μm cm s ns V K\n\n# constants\nconstants = ChargeTransport.constants\n(; q, k_B, ε_0) = constants\n\neV = q * V\n\nThen, we need to define two additional thin interface layers\n\n\n# region numbers\nregionDonor = 1      # n doped region\nregionJunction1 = 2\nregionIntrinsic = 3  # intrinsic region\nregionJunction2 = 4\nregionAcceptor = 5   # p doped region\n\nwhich need to be taken into account by the initialization of the grid.\n\nSecond, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be chosen accordingly and we need to construct a nodally dependent parameter struct\n\n# The flux approximation is by default the excess chemical potential scheme.\n# In this example, we need a graded scheme.\ndata.fluxApproximation = ScharfetterGummelGraded\n\nparamsnodal = ParamsNodal(grid, numberOfCarriers)\n\nFinally, we introduce graded parameters. Currently, only a linear grading is implemented.\n\nparamsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(\n    paramsnodal.bandEdgeEnergy[iphin, :],\n    coord, regionTransportLayers, regionJunctions, h,\n    heightLayers, lengthLayers, EC\n)","category":"section"},{"location":"PSC/#Example-2:-Linear-IV-scan-protocol","page":"Perovskite solar cell","title":"Example 2: Linear IV scan protocol","text":"Here, we summarize the main parts of this example. Define three charge carriers.\n\niphin = 1 # electrons\niphip = 2 # holes\niphia = 3 # anion vacancies\nnumberOfCarriers = 3\n\nConsider the transient problem and enable the ionic charge carriers only in the active layer:\n\ndata.modelType = Transient\nenable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])\n\nFollowing specification is needed for a linear I-V scan protocol.\n\nscanrate = 1.0 * V / s\nendVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\ntend = endVoltage / scanrate","category":"section"},{"location":"PSC/#Use-internal-time-stepping","page":"Perovskite solar cell","title":"Use internal time stepping","text":"To make use of internal time stepping, the scan protocol need to be previously defined, e.g.\n\nfunction linearScanProtocol(t)\n    if t == Inf\n        0.0\n    else\n        scanrate * t\n    end\nend\n\n## Apply zero voltage on left boundary and a linear scan protocol on right boundary\ncontactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\nAnd then, need to be parsed into the data construction method\n\ndata = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n\nThis makes it possible to use the internal time solving method\n\nsol = solve(ctsys, inival = inival, times=(0.0, tend), control = control)","category":"section"},{"location":"PSC/#Example-3:-Illumination","page":"Perovskite solar cell","title":"Example 3: Illumination","text":"Add uniform photogeneration to the previous code by setting\n\ndata.generationModel = GenerationUniform\n\nand specify the uniform generation rate in each region, i.e.\n\nfor ireg in 1:numberOfRegions\n    params.generationUniform[ireg] = generationUniform[ireg]\nend\n\nfor given data stored in generationUniform. If one wishes to use the Beer-Lambert generation, then the corresponding code would be\n\ndata.generationModel = GenerationBeerLambert\n\nfor ireg in 1:numberOfRegions\n    params.generationIncidentPhotonFlux[ireg] = incidentPhotonFlux[ireg]\n    params.generationAbsorption[ireg] = absorption[ireg]\nend\n\nparams.generationPeak = generationPeak\n\nIf one wishes to invert the illumination, one needs to define\n\nparams.invertedIllumination = -1\n\nwhere this value is by default set to one (for light entering from the left). Furthermore, we recommend performing a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see this example.","category":"section"},{"location":"PSC/#Example-4:-Multi-dimensional-problems","page":"Perovskite solar cell","title":"Example 4: Multi-dimensional problems","text":"It is also possible to perform multi-dimensional simulations.\n\nFor a 2D mesh you may use a structured grid via ExtendableGrids.jl or an unstructured mesh via the Julia wrapper Triangulate.jl for Jonathan Richard Shewchuk's Triangle mesh generator. Respective examples can be likewise found within this package.\n\nLastly, with help of the TetGen.jl wrapper, three-dimensional tetrahedral meshes can be generated, see this example.","category":"section"},{"location":"plot/#Plotting-Routines","page":"Plotting Routines","title":"Plotting Routines","text":"The same design as in VoronoiFVM.jl is used: To avoid dependencies for this package, the plot methods defined in this package have as their first argument the module of the plotting package used.\n\nCurrently, only PyPlot was tested.","category":"section"},{"location":"module_examples/Ex203_LBIC_NonDimensional/#2D-nondimensionalized-LBIC-measurement.","page":"2D nondimensionalized LBIC measurement.","title":"2D nondimensionalized LBIC measurement.","text":"(source code)\n\nSimulation of LBIC measurement technique with a focused laser in two dimensions, accompanying the manuscript\n\nExistence of solutions and uniform bounds for the stationary semiconductor equations with generation and ionic carriers,     by D. Abdel, A. Blaustein, M. Herda, C. Chainais-Hillairet, and J. Moatti.\n\nmodule Ex203_LBIC_NonDimensional\n\nusing ChargeTransport\nusing VoronoiFVM\nusing ExtendableGrids  # grid initializer\n\ngrid information\n\nlength_x = 8.0; length_y = 4.0\nbox_cx = length_x / 2;  box_cy = length_y / 2\nbox_x = 4.0;  box_y = 2.0\n\nnumberOfRegions = 2\nbregion1 = 1; bregion2 = 2\n\n# set indices of the quasi Fermi potentials\niphin = 1              # electron quasi Fermi potential\niphip = 2              # hole quasi Fermi potential\nipsi = 3               # electric potential\nnumberOfCarriers = 2\n\nWe define the physical data.\n\nzn = -1; zp = 1\nEn = 0.0; Ep = 0.0     # set the energies to 0\nNn = 1.0; Np = 1.0     # set the effective DOS to 1\nμn = 1.0; μp = 1.0     # set the mobilities to 1\nT = 1.0                # set temperature to 1\n\n# recombination parameters\nSRH_TrapDensity = 0.0\nSRH_LifeTime = 1.0\n\nyou can set verbose also to true to display some solver information\n\nfunction main(;\n        hmin = 0.1, h = 0.25, hmax = 0.25, # grid information\n        Cn = 1.0e1, Cp = 1.0e1,            # doping\n        λ = 1.0,                           # Debye length\n        G0 = 1.0, x0 = 1.0, y0 = 2.0,      # laser information\n        ####################################\n        parameterStudy = false,\n        ####################################\n        Plotter = nothing, # only Plotter = PythonPlot or Plotter = PyPlot are supported in this example\n        verbose = false, test = false\n    )\n\n    if Plotter !== nothing && (nameof(Plotter) ∉ [:PyPlot, :PythonPlot])\n        error(\"Plotting in Ex203_LBIC_NonDimensional is only possible for Plotter = PythonPlot\")\n    end\n\n    if Plotter !== nothing\n\nyou need PyCall in your global environment\n\n        @eval using PyCall\n\nhttps://stackoverflow.com/questions/29443369/how-to-make-a-custom-colormap-using-pyplot-not-matplotlib-proper\n\n        matcolors = PyCall.pyimport(\"matplotlib.colors\")\n\nhttps://github.com/BIDS/colormap/blob/master/parula.py\n\n        cm_data = [\n            [0.2081, 0.1663, 0.5292], [0.2116238095, 0.1897809524, 0.5776761905],\n            [0.212252381, 0.2137714286, 0.6269714286], [0.2081, 0.2386, 0.6770857143],\n            [0.1959047619, 0.2644571429, 0.7279], [\n                0.1707285714, 0.2919380952,\n                0.779247619,\n            ], [0.1252714286, 0.3242428571, 0.8302714286],\n            [0.0591333333, 0.3598333333, 0.8683333333], [\n                0.0116952381, 0.3875095238,\n                0.8819571429,\n            ], [0.0059571429, 0.4086142857, 0.8828428571],\n            [0.0165142857, 0.4266, 0.8786333333], [\n                0.032852381, 0.4430428571,\n                0.8719571429,\n            ], [0.0498142857, 0.4585714286, 0.8640571429],\n            [0.0629333333, 0.4736904762, 0.8554380952], [\n                0.0722666667, 0.4886666667,\n                0.8467,\n            ], [0.0779428571, 0.5039857143, 0.8383714286],\n            [0.079347619, 0.5200238095, 0.8311809524], [\n                0.0749428571, 0.5375428571,\n                0.8262714286,\n            ], [0.0640571429, 0.5569857143, 0.8239571429],\n            [0.0487714286, 0.5772238095, 0.8228285714], [\n                0.0343428571, 0.5965809524,\n                0.819852381,\n            ], [0.0265, 0.6137, 0.8135], [\n                0.0238904762, 0.6286619048,\n                0.8037619048,\n            ], [0.0230904762, 0.6417857143, 0.7912666667],\n            [0.0227714286, 0.6534857143, 0.7767571429], [\n                0.0266619048, 0.6641952381,\n                0.7607190476,\n            ], [0.0383714286, 0.6742714286, 0.743552381],\n            [0.0589714286, 0.6837571429, 0.7253857143],\n            [0.0843, 0.6928333333, 0.7061666667], [0.1132952381, 0.7015, 0.6858571429],\n            [0.1452714286, 0.7097571429, 0.6646285714], [\n                0.1801333333, 0.7176571429,\n                0.6424333333,\n            ], [0.2178285714, 0.7250428571, 0.6192619048],\n            [0.2586428571, 0.7317142857, 0.5954285714], [\n                0.3021714286, 0.7376047619,\n                0.5711857143,\n            ], [0.3481666667, 0.7424333333, 0.5472666667],\n            [0.3952571429, 0.7459, 0.5244428571], [\n                0.4420095238, 0.7480809524,\n                0.5033142857,\n            ], [0.4871238095, 0.7490619048, 0.4839761905],\n            [0.5300285714, 0.7491142857, 0.4661142857], [\n                0.5708571429, 0.7485190476,\n                0.4493904762,\n            ], [0.609852381, 0.7473142857, 0.4336857143],\n            [0.6473, 0.7456, 0.4188], [0.6834190476, 0.7434761905, 0.4044333333],\n            [0.7184095238, 0.7411333333, 0.3904761905],\n            [0.7524857143, 0.7384, 0.3768142857], [\n                0.7858428571, 0.7355666667,\n                0.3632714286,\n            ], [0.8185047619, 0.7327333333, 0.3497904762],\n            [0.8506571429, 0.7299, 0.3360285714], [0.8824333333, 0.7274333333, 0.3217],\n            [0.9139333333, 0.7257857143, 0.3062761905], [\n                0.9449571429, 0.7261142857,\n                0.2886428571,\n            ], [0.9738952381, 0.7313952381, 0.266647619],\n            [0.9937714286, 0.7454571429, 0.240347619], [\n                0.9990428571, 0.7653142857,\n                0.2164142857,\n            ], [0.9955333333, 0.7860571429, 0.196652381],\n            [0.988, 0.8066, 0.1793666667], [0.9788571429, 0.8271428571, 0.1633142857],\n            [0.9697, 0.8481380952, 0.147452381], [0.9625857143, 0.8705142857, 0.1309],\n            [0.9588714286, 0.8949, 0.1132428571], [\n                0.9598238095, 0.9218333333,\n                0.0948380952,\n            ], [0.9661, 0.9514428571, 0.0755333333],\n            [0.9763, 0.9831, 0.0538],\n        ]\n\n        parula_map = matcolors.LinearSegmentedColormap.from_list(\"parula\", cm_data)\n        Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n        Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n        Plotter.close(\"all\")\n    end\n\nconstants Here, we set the constants to unityconstants. In particular, we set: q = kB = ε_0 = 1 When defining `ChargeTransport.constants\" the constants based on CODATA2022 are used.\n\n    constants = ChargeTransport.unity_constants\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    X1 = geomspace(0.0, box_cx - box_x / 2, hmin, hmax)\n    X2 = geomspace(box_cx - box_x / 2, box_cx, hmax, hmin)\n    X3 = geomspace(box_cx, box_cx + box_x / 2, hmin, hmax)\n    X4 = geomspace(box_cx + box_x / 2, length_x, hmax, hmin)\n    X = glue(X1, X2); X = glue(X, X3); X = glue(X, X4)\n    ##################\n    Y1 = collect(0.0:h:(box_cy - box_y / 2))\n    Y2 = geomspace(box_cy - box_y / 2, box_cy, hmax, hmin)\n    Y3 = geomspace(box_cy, box_cy + box_y / 2, hmin, hmax)\n    Y4 = collect((box_cy + box_y / 2):h:length_y)\n    Y = glue(Y1, Y2); Y = glue(Y, Y3); Y = glue(Y, Y4)\n    ##################\n    grid = simplexgrid(X, Y)\n\n    rect!(grid, [box_cx - box_x / 2, box_cy - box_y / 2], [box_cx + box_x / 2, box_cy + box_y / 2], region = 2, bregion = 0, tol = 1.0e-1)\n\n    # bfacemask! for setting different boundary regions.\n    bfacemask!(grid, [0.0, 0.0], [0.0, length_y], bregion1)\n    bfacemask!(grid, [length_x, 0.0], [length_x, length_y], bregion2)\n    bfacemask!(grid, [0.0, 0.0], [length_x, 0.0], 0)\n    bfacemask!(grid, [0.0, length_y], [length_x, length_y], 0)\n\n    if Plotter !== nothing\n        gridplot(grid; Plotter)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # Optical generation\n    sigma = 0.5\n    G(x, y) = G0 * exp(- ((x - x0)^2 + (y - y0)^2) / (2 * sigma^2))\n\n    genData = zeros(length(grid[Coordinates][1, :]))\n    coord = grid[Coordinates]\n    subg = subgrid(grid, [1, 2])\n    iNode = subg[NodeParents] # to receive array with correct ordering of nodes\n\n    for inode in iNode\n        x = coord[1, inode]\n        y = coord[2, inode]\n        genData[inode] = G(x, y)\n    end\n\n    if Plotter !== nothing\n        XX = grid[Coordinates][1, :]\n        YY = grid[Coordinates][2, :]\n\n        Plotter.figure()\n        Plotter.tricontourf(XX, YY, genData, levels = 40)\n        Plotter.colorbar(orientation = \"vertical\", label = \"Generation \\$ G \\$ \")\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"\\$ y \\$\", fontsize = 17)\n        Plotter.axis(\"equal\")\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\nWe initialize the Data instance and fill in predefined data.\n\n    data = Data(grid, numberOfCarriers, generationData = genData, constants = constants)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType = Stationary\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[iphin] = FermiDiracOneHalfTeSCA\n    data.F[iphip] = FermiDiracOneHalfTeSCA\n\n    # The desired recombination processes can be chosen here.\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = false,\n        bulk_recomb_SRH = true\n    )\n\ngeneration model\n\n    data.generationModel = GenerationUserDefined\n\n    # flux discretization scheme is by default excess chemical potential flux scheme\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\nDefine the Params struct\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = zn\n    params.chargeNumbers[iphip] = zp\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg] = λ^2 # Debye length, entering model as `DielectricConstant`, i.e., prefactor in the displacement flux\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nn\n        params.densityOfStates[iphip, ireg] = Np\n        params.bandEdgeEnergy[iphin, ireg] = En\n        params.bandEdgeEnergy[iphip, ireg] = Ep\n        params.mobility[iphin, ireg] = μn\n        params.mobility[iphip, ireg] = μp\n\n        # recombination parameters\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n\n    end\n\n    # doping\n    params.doping[iphin, 1] = Cn\n    params.doping[iphip, 2] = Cp\n\nRegion dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.\n\n    data.params = params\n\nIn the last step, we initialize our system with previous data which is likewise dependent on the parameters.\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    # boundary model\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphin, bregion1, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphip, bregion1, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, ipsi, bregion1, 0.0)\n\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphin, bregion2, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphip, bregion2, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, ipsi, bregion2, 0.0)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = VoronoiFVM.SolverControl()\n    control.verbose = verbose\n    control.maxiters = 50\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.tol_round = 1.0e-8\n    control.damp_initial = 0.1\n    control.damp_growth = 1.21\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Solving the nonlinear system of equations\")\n    end\n    ################################################################################\n\n    inival = ChargeTransport.unknowns(ctsys)\n    inival .= 0.0\n\n    sol = ChargeTransport.solve(ctsys, inival = inival, control = control)\n\n    if parameterStudy\n        return sol, ctsys\n    end\n\n    ###################################\n    factory = VoronoiFVM.TestFunctionFactory(ctsys.fvmsys)\n    tf = VoronoiFVM.testfunction(factory, [bregion1], [bregion2])\n\n    I = VoronoiFVM.integrate(ctsys.fvmsys, tf, sol)\n\n    current = I[1] + I[2]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false && (nameof(Plotter) ∈ [:PythonPlot, :PyPlot])\n        println(\"Plotting\")\n    end\n    ################################################################################\n\n    if Plotter !== nothing\n\nhttps://github.com/j-fu/GridVisualize.jl/blob/1f2b299a436b7750702ccca282fa14152d80ebf9/src/pyplot.jl#L86\n\n        function tridata(grid::ExtendableGrid)\n            coord = grid[Coordinates]\n            cellnodes = Matrix(grid[CellNodes])\n            return coord[1, :], coord[2, :], transpose(cellnodes .- 1)\n        end\n\n        XX = grid[Coordinates][1, :]; YY = grid[Coordinates][2, :]\n\n        nn = data.F[iphin].(zn * (sol[iphin, :] - sol[ipsi, :]))\n        np = data.F[iphip].(zp * (sol[iphip, :] - sol[ipsi, :]))\n\n        vmin = 0.005; vmax = 7.0\n\n        Blues = Plotter.get_cmap(:Blues); Oranges = Plotter.get_cmap(:Oranges)\n        Greens = Plotter.get_cmap(:Greens)\n\n        Plotter.figure()\n        Plotter.tripcolor(tridata(grid)..., vcat(nn...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", cmap = parula_map, rasterized = true)\n        Plotter.title(\"\\$ n_{\\\\mathrm{n}} \\$\")\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"\\$ y \\$\", fontsize = 17)\n        Plotter.colorbar(orientation = \"vertical\", label = \"density\")\n        Plotter.axis(\"equal\")\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n        ########################################################\n        Plotter.figure()\n        Plotter.tripcolor(tridata(grid)..., vcat(np...), norm = Plotter.matplotlib.colors.LogNorm(vmin = vmin, vmax = vmax), shading = \"gouraud\", cmap = parula_map, rasterized = true)\n        Plotter.title(\"\\$ n_{\\\\mathrm{p}} \\$\")\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"\\$ y \\$\", fontsize = 17)\n        Plotter.colorbar(orientation = \"vertical\", label = \"density\")\n        Plotter.axis(\"equal\")\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n        ########################################################\n        Plotter.figure()\n        Plotter.surf(XX[:], YY[:], sol[ipsi, :], color = Blues(201))\n        Plotter.title(\" \\$ \\\\psi \\$\")\n        Plotter.xlabel(\"\\$ x \\$\")\n        Plotter.ylabel(\"\\$ y \\$\")\n        Plotter.zlabel(\"potential\")\n\nSet aspect ratio based on data ranges\n\n        Plotter.gca().set_xlim3d(0.0, 8.0)\n        Plotter.gca().set_ylim3d(0.0, 4.0)\n        Plotter.gca().set_zlim3d(-3.0, 4.5)\n\n        xlim = Plotter.gca().get_xlim3d()\n        ylim = Plotter.gca().get_ylim3d()\n        zlim = Plotter.gca().get_zlim3d()\n\n        xr = xlim[2] - xlim[1]\n        yr = ylim[2] - ylim[1]\n        zr = zlim[2] - zlim[1]\n        maxr = maximum([xr, yr, zr])\n        Plotter.gca().set_box_aspect((xr / maxr, yr / maxr, zr / maxr))\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n        ########################################################\n        Plotter.figure()\n        Plotter.surf(XX[:], YY[:], zn .* sol[iphin, :], color = Greens(201))\n        Plotter.title(\"\\$ v_{\\\\mathrm{n}} \\$\")\n        Plotter.xlabel(\"\\$ x \\$\")\n        Plotter.ylabel(\"\\$ y \\$\")\n        Plotter.zlabel(\"potential\")\n        Plotter.gca().set_xlim3d(0.0, 8.0)\n        Plotter.gca().set_ylim3d(0.0, 4.0)\n        Plotter.gca().set_zlim3d(-1.0, 1.0)\n        Plotter.gca().set_box_aspect((xr / maxr, yr / maxr, zr / maxr))\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n        ########################################################\n        Plotter.figure()\n        Plotter.surf(XX[:], YY[:], zp .* sol[iphip, :], color = Oranges(201))\n        Plotter.title(\"\\$ v_{\\\\mathrm{p}} \\$\")\n        Plotter.xlabel(\"\\$ x \\$\")\n        Plotter.ylabel(\"\\$ y \\$\")\n        Plotter.zlabel(\"potential\")\n        Plotter.gca().set_xlim3d(0.0, 8.0)\n        Plotter.gca().set_ylim3d(0.0, 4.0)\n        Plotter.gca().set_zlim3d(-1.0, 1.0)\n        Plotter.gca().set_box_aspect((xr / maxr, yr / maxr, zr / maxr))\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n    end\n\n    if test == false && (nameof(Plotter) ∈ [:PythonPlot, :PyPlot])\n        println(\"*** done\\n\")\n    end\n\n    return current\n\nend #  main\n\n\n# This is one of the functions, with which the current data sets for the parameter study can be generated\nfunction ParameterStudy1D(;\n        hmin = 0.1, h = 0.25, hmax = 0.25, # grid information\n        Cn = 1.0e1, Cp = 1.0e1,            # doping\n        λ = 1.0,                           # Debye length\n        G0 = 1.0,                          # laser information\n        Plotter = nothing\n    )\n\n    if Plotter !== nothing && !(nameof(Plotter) in [:PyPlot, :PythonPlot])\n        @warn \"Plotting in ParameterStudy1D is only possible for Plotter = PyPlot or Plotter = PythonPlot\"\n        Plotter = nothing\n    end\n\n    if Plotter !== nothing\n        Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n        Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n        Plotter.close(\"all\")\n    end\n\n    X1 = geomspace(0.0, box_cx - box_x / 2, hmin, hmax)\n    X2 = geomspace(box_cx - box_x / 2, box_cx, hmax, hmin)\n    X3 = geomspace(box_cx, box_cx + box_x / 2, hmin, hmax)\n    X4 = geomspace(box_cx + box_x / 2, length_x, hmax, hmin)\n    X = glue(X1, X2); X = glue(X, X3); X = glue(X, X4)\n    ##################\n    Y1 = collect(0.0:h:(box_cy - box_y / 2))\n    Y2 = geomspace(box_cy - box_y / 2, box_cy, hmax, hmin)\n    Y3 = geomspace(box_cy, box_cy + box_y / 2, hmin, hmax)\n    Y4 = collect((box_cy + box_y / 2):h:length_y)\n    Y = glue(Y1, Y2); Y = glue(Y, Y3); Y = glue(Y, Y4)\n    ##################\n    grid = simplexgrid(X, Y)\n\n    rect!(grid, [box_cx - box_x / 2, box_cy - box_y / 2], [box_cx + box_x / 2, box_cy + box_y / 2], region = 2, bregion = 0, tol = 1.0e-1)\n\n    # bfacemask! for setting different boundary regions.\n    bfacemask!(grid, [0.0, 0.0], [0.0, length_y], bregion1)\n    bfacemask!(grid, [length_x, 0.0], [length_x, length_y], bregion2)\n    bfacemask!(grid, [0.0, 0.0], [length_x, 0.0], 0)\n    bfacemask!(grid, [0.0, length_y], [length_x, length_y], 0)\n\n    IVec = zeros(0)\n    i = 1\n\n    y0 = box_cy\n    for xx in X\n\n        println(i)\n        i = i + 1\n        x0 = xx\n\n        sol, ctsys = Ex203_LBIC_NonDimensional.main(Cn = Cn, Cp = Cp, λ = λ, G0 = G0, x0 = x0, y0 = y0, test = true, plotting = false, parameterStudy = true)\n\n        #########################################################\n        #### calculate total current\n        factory = VoronoiFVM.TestFunctionFactory(ctsys.fvmsys)\n        tf = VoronoiFVM.testfunction(factory, [bregion1], [bregion2])\n\n        I = VoronoiFVM.integrate(ctsys.fvmsys, tf, sol)\n        current = I[1] + I[2]\n\n        push!(IVec, current)\n        #########################################################\n    end\n\n    if Plotter !== nothing\n        Plotter.plot(X, IVec, linewidth = 4, marker = \"o\", markersize = 12)\n        Plotter.axvspan(0.0, 2.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(2.0, 6.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.axvspan(6.0, 8.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.xlim(0.0, 8.0)\n        Plotter.ylim(-0.8, 0.8)\n        Plotter.xlabel(\"Laser position \\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Current\", fontsize = 17)\n        Plotter.tight_layout()\n    end\n\n    return nothing\n\nend\n\n# This is one of the functions, with which the data sets for the parameter study can be generated\nfunction ParameterStudy2D(;\n        hmin = 0.1, h = 0.25, hmax = 0.25, # grid information\n        Cn = 1.0e1, Cp = 1.0e1,            # doping\n        λ = 1.0,                           # Debye length\n        G0 = 1.0,                          # laser information\n        Plotter = nothing,\n    )\n\n    if Plotter !== nothing && !(nameof(Plotter) in [:PyPlot, :PythonPlot])\n        @warn \"Plotting in ParameterStudy2D is only possible for Plotter = PyPlot or Plotter = PythonPlot\"\n        Plotter = nothing\n    end\n\n    if Plotter !== nothing\n        Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n        Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n        Plotter.close(\"all\")\n    end\n\n    X1 = geomspace(0.0, box_cx - box_x / 2, hmin, hmax)\n    X2 = geomspace(box_cx - box_x / 2, box_cx, hmax, hmin)\n    X3 = geomspace(box_cx, box_cx + box_x / 2, hmin, hmax)\n    X4 = geomspace(box_cx + box_x / 2, length_x, hmax, hmin)\n    X = glue(X1, X2); X = glue(X, X3); X = glue(X, X4)\n    ##################\n    Y1 = collect(0.0:h:(box_cy - box_y / 2))\n    Y2 = geomspace(box_cy - box_y / 2, box_cy, hmax, hmin)\n    Y3 = geomspace(box_cy, box_cy + box_y / 2, hmin, hmax)\n    Y4 = collect((box_cy + box_y / 2):h:length_y)\n    Y = glue(Y1, Y2); Y = glue(Y, Y3); Y = glue(Y, Y4)\n    ##################\n    grid = simplexgrid(X, Y)\n\n    rect!(grid, [box_cx - box_x / 2, box_cy - box_y / 2], [box_cx + box_x / 2, box_cy + box_y / 2], region = 2, bregion = 0, tol = 1.0e-1)\n\n    # bfacemask! for setting different boundary regions.\n    bfacemask!(grid, [0.0, 0.0], [0.0, length_y], bregion1)\n    bfacemask!(grid, [length_x, 0.0], [length_x, length_y], bregion2)\n    bfacemask!(grid, [0.0, 0.0], [length_x, 0.0], 0)\n    bfacemask!(grid, [0.0, length_y], [length_x, length_y], 0)\n\n    IVec = zeros(0)\n    i = 1\n\n    for coord in eachcol(grid[Coordinates])\n\n        println(i)\n        i = i + 1\n        x0 = coord[1]\n        y0 = coord[2]\n\n        sol, ctsys = Ex203_LBIC_NonDimensional.main(Cn = Cn, Cp = Cp, λ = λ, G0 = G0, x0 = x0, y0 = y0, test = true, plotting = false, parameterStudy = true)\n\n        #########################################################\n        #### calculate total current\n        factory = VoronoiFVM.TestFunctionFactory(ctsys.fvmsys)\n        tf = VoronoiFVM.testfunction(factory, [bregion1], [bregion2])\n\n        I = VoronoiFVM.integrate(ctsys.fvmsys, tf, sol)\n        current = I[1] + I[2]\n\n        push!(IVec, current)\n\n    end\n\n    if Plotter !== nothing\n        X = grid[Coordinates][1, :]; Y = grid[Coordinates][2, :]\n        Plotter.surf(X[:], Y[:], IVec)\n        Plotter.title(\" \\$ I \\$\")\n        Plotter.xlabel(\"\\$ x \\$\")\n        Plotter.ylabel(\"\\$ y \\$\")\n        Plotter.zlabel(\"current \")\n        Plotter.tight_layout()\n\n        return nothing\n    end\n\nend\n\nfunction test()\n    testval = -0.052620329648232746\n    return main(test = true) ≈ testval\nend\n\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/#PSC-device-with-surface-recombination-(1D).","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"(source code)\n\nSimulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions with a linear scan protocol.\n\nHere, the surface recombination at internal boundaries is tested.\n\nmodule Ex106_PSC_SurfaceRecombination\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\nfunction main(;\n        n = 6, Plotter = nothing,                   # supported Plotters are GLMakie and PythonPlot\n        verbose = false, test = false,\n        parameter_set = Params_PSC_PCBM_MAPI_Pedot, # choose the parameter set\n        vacancyEnergyCalculation = false,           # assume the vacancy energy level is either given or not\n    )\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W\n\nparameter\n\n    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 1.0 * V / s\n    vend = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = vend / scanrate\n\n    # Define scan protocol function\n    function linearScanProtocol(t)\n        return if t == Inf\n            0.0\n        else\n            scanrate * t\n        end\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (5.1 * δ), p.h_intrinsic / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (1.1 * δ), p.h_intrinsic / (5.1 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.3 * δ), p.h_pdoping / (0.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (0.8 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], p.bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [p.h_total], [p.h_total], p.bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (3, 2), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[p.iphin] = FermiDiracOneHalfTeSCA\n    data.F[p.iphip] = FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionJ1] = InterfaceRecombination\n    data.boundaryType[p.bregionJ2] = InterfaceRecombination\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n\n    if !vacancyEnergyCalculation\n        data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] = p.Ea[p.regionIntrinsic]\n    end\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.damp_initial = 0.9\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = vacancyEnergyCalculation)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement\")\n    end\n    ################################################################################\n\n    control.Δt = 5.0e-2\n    control.Δt_grow = 1.03\n    # calculation of solution\n    sol = ChargeTransport.solve(ctsys, inival = inival, times = (0.0, tend), control = control)\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n\n    # for saving I-V data\n    IV = zeros(0) # for IV values\n    biasValues = zeros(0) # for bias values\n\n    for istep in 2:number_tsteps\n\n        Δt = tvalues[istep] - tvalues[istep - 1]  # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n        push!(IV, current)\n\n        inival = solution\n\n    end # time loop\n\n    solution = sol.u[end]\n\n    biasValues = contactVoltageFunction[p.bregionAcceptor].(tvalues)\n\nTODO MO: Ergibt das Sinn? Habe ich für die Title gemacht.\n\n    maxBias = biasValues[end]\n\n    if Plotter !== nothing\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n        # add labels for anion vacancy\n        label_energy[1, p.iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, p.iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[p.iphia] = \"\\$E_a\\$\"\n        label_density[p.iphia] = \"\\$ n_a \\$\";      label_solution[p.iphia] = \"\\$ \\\\varphi_a\\$\"\n\n        plot_densities!(vis[1, 2], ctsys, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        plot_solution!(vis[2, 1], ctsys, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n\n        ###########\n        #TODO MO: Im Referenceplot mit PyPlot sind mehr Schritte, wieso?\n        scalarplot!(\n            vis[2, 2],\n            tvalues,\n            biasValues;\n            markershape = :circle,\n            markersize = 8,\n            color = :blue,\n            xlabel = L\"\\text{time [s]}\",\n            ylabel = L\"\\text{bias [V]}\",\n            title = \"Applied bias over time\"\n        )\n        ###########\n        scalarplot!(\n            vis[3, 1],\n            biasValues[2:end],\n            IV .* (cm^2) .* 1.0e3,\n            linewidth = 2,\n            color = \"darkblue\",\n            xlabel = L\"\\text{bias [V]}\",\n            ylabel = L\"current density [$\\text{mAcm}^{-2}$]\",\n            title = \"Total current\"\n        )\n\n        reveal(vis)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        integral = integrated_density(ctsys, sol = solution, icc = p.iphia, ireg = p.regionIntrinsic)\n\n        println(\"Calculated average vacancy density is: \", integral / data.regionVolumes[p.regionIntrinsic])\n        println(\" \")\n        if vacancyEnergyCalculation\n            vacancyEnergy = data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] / data.constants.q\n            println(\"Value for vacancy energy is: \", vacancyEnergy, \" eV. Save this value for later use.\")\n            println(\"We recommend to calculate it on a fine grid.\")\n            println(\" \")\n        end\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend # main\n\nfunction test()\n    testval = -0.5965444263524541; testvalvacancyEnergyCalculation = -0.5966729068541846\n    return main(test = true, vacancyEnergyCalculation = true) ≈ testval && main(test = true, vacancyEnergyCalculation = false) ≈ testvalvacancyEnergyCalculation\nend\n\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/#MoS2-with-moving-defects-and-Schottky-Barrier-Lowering.","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"(source code)\n\nMemristor simulation with additional moving positively charged defects and Schottky barrier lowering at the contacts.\n\nmodule Ex107_MoS2_withIons_BarrierLowering\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(; Plotter = nothing, verbose = false, test = false, barrierLowering = true)\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid, regions and time mesh\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm eV s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n    (; q, k_B, ε_0, Planck_constant, m_e) = constants\n\n\n    # region numbers\n    regionflake = 1\n\n    # boundary region numbers\n    bregionLeft = 1\n    bregionRight = 2\n\n    # grid\n    h_flake = 1.0 * μm # length of the conducting channel\n\nnon-uniform grid\n\n    coord1 = geomspace(0.0, h_flake / 2, 5.0e-4 * h_flake, 2.0e-2 * h_flake)\n    coord2 = geomspace(h_flake / 2, h_flake, 2.0e-2 * h_flake, 5.0e-4 * h_flake)\n    coord = glue(coord1, coord2)\n\n    grid = simplexgrid(coord)\n\n    # set region in grid\n    cellmask!(grid, [0.0], [h_flake], regionflake, tol = 1.0e-18)\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (3, 2), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of unknowns\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    iphix = 3\n\n    numberOfCarriers = 3 # electrons, holes and ions\n\nWe define the physical data\n\n    T = 300.0 * K\n    εr = 9.0 * 1.0                   # relative dielectric permittivity\n    εi = 1.0 * εr                                   # image force dielectric permittivity\n\n    Ec = - 4.0 * eV\n    Ev = - 5.3 * eV\n    Ex = - 4.38 * eV\n\n    Nc = 2 * (2 * pi * 0.55 * m_e * k_B * T / (Planck_constant^2))^(3 / 2) / m^3\n    Nv = 2 * (2 * pi * 0.71 * m_e * k_B * T / (Planck_constant^2))^(3 / 2) / m^3\n    Nx = 1.0e28 / (m^3)\n\n    μn = 1.0e-4 * (m^2) / (V * s)\n    μp = 1.0e-4 * (m^2) / (V * s)\n    μx = 0.8e-13 * (m^2) / (V * s)\n\n    # Schottky contact\n    barrierLeft = 0.225 * eV\n    barrierRight = 0.215 * eV\n    An = 4 * pi * q * 0.55 * m_e * k_B^2 / Planck_constant^3\n    Ap = 4 * pi * q * 0.71 * m_e * k_B^2 / Planck_constant^3\n    vn = An * T^2 / (q * Nc)\n    vp = Ap * T^2 / (q * Nv)\n\n    Nd = 1.0e17 / (m^3) # doping\n\n    Area = 2.1e-11 * m^2                # Area of electrode\n\nScan protocol information\n\n    endTime = 9.6 * s\n    amplitude = 12.0 * V\n    scanrate = 4 * amplitude / endTime\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if 0.0 <= t  && t <= endTime / 4\n            biasVal = 0.0 + scanrate * t\n        elseif t >= endTime / 4  && t <= 3 * endTime / 4\n            biasVal = amplitude .- scanrate * (t - endTime / 4)\n        elseif t >= 3 * endTime / 4 && t <= endTime\n            biasVal = - amplitude .+ scanrate * (t - 3 * endTime / 4)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end\n\nApply zero voltage on left boundary and a linear scan protocol on right boundary\n\n    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n    data.modelType = Transient\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[iphin] = FermiDiracOneHalfTeSCA\n    data.F[iphip] = FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = false,\n        bulk_recomb_SRH = false\n    )\n    if barrierLowering\n        data.boundaryType[bregionLeft] = SchottkyBarrierLowering\n        data.boundaryType[bregionRight] = SchottkyBarrierLowering\n    else\n        data.boundaryType[bregionLeft] = SchottkyContact\n        data.boundaryType[bregionRight] = SchottkyContact\n    end\n\n    # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n    enable_ionic_carrier!(data, ionicCarrier = iphix, regions = [regionflake])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n    params.chargeNumbers[iphix] = 2\n\n    for ireg in 1:length([regionflake])           # region data\n\n        params.dielectricConstant[ireg] = εr * ε_0\n        params.dielectricConstantImageForce[ireg] = εi * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = μn\n        params.mobility[iphip, ireg] = μp\n        params.densityOfStates[iphix, ireg] = Nx\n        params.bandEdgeEnergy[iphix, ireg] = Ex\n        params.mobility[iphix, ireg] = μx\n    end\n\n    params.SchottkyBarrier[bregionLeft] = barrierLeft\n    params.SchottkyBarrier[bregionRight] = barrierRight\n    params.bVelocity[iphin, bregionLeft] = vn\n    params.bVelocity[iphin, bregionRight] = vn\n    params.bVelocity[iphip, bregionLeft] = vp\n    params.bVelocity[iphip, bregionRight] = vp\n\n    # interior doping\n    params.doping[iphin, regionflake] = Nd\n\n    data.params = params\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.damp_initial = 0.9\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    control.abstol = 1.0e-9\n    control.reltol = 1.0e-9\n    control.tol_round = 1.0e-9\n\n    control.Δu_opt = Inf\n    control.Δt = 1.0e-4\n    control.Δt_min = 1.0e-5\n    control.Δt_max = 5.0e-2\n    control.Δt_grow = 1.05\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    solEQ = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 0)\n    inival = solEQ\n\n    if Plotter !== nothing\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n        label_energy[1, iphix] = \"\\$E_x-q\\\\psi\\$\"; label_energy[2, iphix] = \"\\$ - q \\\\varphi_x\\$\"\n        label_density[iphix] = \"\\$ n_x\\$\";       label_solution[iphix] = \"\\$ \\\\varphi_x\\$\"\n\n        plot_densities!(vis[1, 2], ctsys, solEQ, \"Equilibrium\", label_density)\n        plot_solution!(vis[2, 1], ctsys, solEQ, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    sol = solve(ctsys, inival = inival, times = (0.0, endTime), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    #########  IV curve calculation\n    ################################################################################\n\n    IV = zeros(0) # for saving I-V data\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n    biasValues = scanProtocol.(tvalues)\n\n    factory = TestFunctionFactory(ctsys)\n    tf = testfunction(factory, [bregionLeft], [bregionRight])\n\n    push!(IV, 0.0)\n    for istep in 2:number_tsteps\n        Δt = tvalues[istep] - tvalues[istep - 1] # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    if Plotter !== nothing\n        scalarplot!(\n            vis[2, 2],\n            tvalues,\n            biasValues;\n            markershape = :cross,\n            markersize = 8,\n            xlabel = L\"\\text{time [s]}\",\n            ylabel = L\"\\text{voltage [V]}\",\n            title = \"Applied voltage over time\"\n        )\n\n        currentValues = abs.(Area .* IV)\n        mask = currentValues .> 0 # TODO MO: für log, sonst wird nichts geplottet, jetzt wird nur der erste Wert nicht geplottet, ok so?\n        scalarplot!(\n            vis[3, 1],\n            biasValues[mask],\n            currentValues[mask];\n            linewidth = 2,\n            color = \"black\",\n            xlabel = L\"\\text{applied bias [V]}\",\n            ylabel = L\"\\text{total current [A]}\",\n            title = \"Total current\",\n            yscale = :log\n        )\n\n        reveal(vis)\n    end\n\n    testval = sum(filter(!isnan, solEQ)) / length(solEQ)\n    return testval\n\nend #  main\n\nfunction test()\n    return main(test = true, barrierLowering = true) ≈ -1692.2303837883194\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"module_examples/Ex103_PSC_IVMeasurement/#PSC-device-with-ions-and-different-I-V-scan-protocols-(1D).","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"(source code)\n\nSimulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.\n\nThe time-dependent simulations are performed with abrupt interfaces. Two different I-V measurement protocols are included and the corresponding solution vectors and the I-V curve after the scan can be depicted.\n\nmodule Ex103_PSC_IVMeasurement\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(;\n        n = 3, Plotter = nothing, verbose = false, test = false,\n        parameter_set = Params_PSC_TiO2_MAPI_spiro, # choose the parameter set\n        otherScanProtocol = false,                  # you can choose between two scan protocols\n        vacancyEnergyCalculation = true,            # assume the vacancy energy level is either given or not\n    )\n\n    @local_unitfactors μm cm s ns V K ps Hz\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\nparameters\n\n    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 1.0 * V / s\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = endVoltage / scanrate\n\n    # Define scan protocol function\n    function linearScanProtocol(t)\n        return if t == Inf\n            0.0\n        else\n            scanrate * t\n        end\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\n    # Instead of a linear scan protocol, we can also apply other scan protocols which we\n    # define by our own and parse to the model generator via the struct Data\n    if otherScanProtocol\n        # scan protocol parameter\n        frequency = 10.0 * Hz\n        amplitude = 0.2 * V\n        tend = 1 / frequency\n\n        # Define sinusoidal applied voltage\n        function sinusoidalScanProtocol(t)\n            return if t == Inf\n                0.0\n            else\n                amplitude * sin(2.0 * pi * frequency * t)\n            end\n        end\n\n        # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n        contactVoltageFunction = [zeroVoltage, sinusoidalScanProtocol]\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (2.8 * δ), p.h_intrinsic / (2.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (2.1 * δ), p.h_intrinsic / (2.8 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.6 * δ), p.h_pdoping / (1.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (1.3 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], p.bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [p.h_total], [p.h_total], p.bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (3, 4), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :none, title = \"Grid\", xlabel = L\"\\text{space[m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    # Currently, the way to go is to pass a contact voltage function exactly here.\n    data = Data(grid, p.numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[p.iphin] = FermiDiracOneHalfTeSCA\n    data.F[p.iphip] = FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # With this method, the user enable the ionic carrier parsed to ionicCarrier and gives\n    # gives the information on which regions this ionic carrier is defined.\n    # In this application ion vacancies only live in active perovskite layer.\n    # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n\n    if !vacancyEnergyCalculation\n        data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] = p.Ea[p.regionIntrinsic]\n    end\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if Plotter !== nothing\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, p.iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, p.iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[p.iphia] = \"\\$E_a\\$\"\n        label_density[p.iphia] = \"\\$ n_a \\$\";      label_solution[p.iphia] = \"\\$ \\\\varphi_a\\$\"\n\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.max_round = 5\n    control.damp_initial = 0.1\n    control.damp_growth = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = vacancyEnergyCalculation)\n    inival = solution\n\n    if Plotter !== nothing\n        plot_energies!(vis[1, 2], ctsys, solution, \"Equilibrium\", label_energy)\n        plot_densities!(vis[1, 3], ctsys, solution, \"Equilibrium\", label_density)\n        plot_solution!(vis[1, 4], ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement\")\n    end\n    ################################################################################\n\n    control.Δt = 0.5\n    control.Δt_grow = 1.0\n\n    if otherScanProtocol\n        control.Δt_min = 1.0e-4\n        control.Δt = 1.0e-4\n        control.Δt_grow = 1.2\n    end\n\n    # calculation of solution\n    sol = ChargeTransport.solve(ctsys, inival = inival, times = (0.0, tend), control = control)\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n\n    # for saving I-V data\n    IV = zeros(0)    # for IV values\n    ISRHn = zeros(0)\n    ISRHp = zeros(0) # for SRH recombination current\n    IRadn = zeros(0)\n    IRadp = zeros(0) # for radiative recombination current\n\n    for istep in 2:number_tsteps\n\n        Δt = tvalues[istep] - tvalues[istep - 1]  # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n\n        IntSRH = integrate(ctsys, SRHRecombination!, solution)\n        IntRad = integrate(ctsys, RadiativeRecombination!, solution)\n\n        IntSRHnSum = 0.0; IntRadnSum = 0.0\n        IntSRHpSum = 0.0; IntRadpSum = 0.0\n\n        for ii in 1:p.numberOfRegions\n            IntSRHnSum = IntSRHnSum - IntSRH[p.iphin, ii]\n            IntRadnSum = IntRadnSum - IntRad[p.iphin, ii]\n\n            IntSRHpSum = IntSRHpSum + IntSRH[p.iphip, ii]\n            IntRadpSum = IntRadpSum + IntRad[p.iphip, ii]\n        end\n\n        push!(IV, current)\n        push!(ISRHn, IntSRHnSum); push!(ISRHp, IntSRHpSum)\n        push!(IRadn, IntRadnSum); push!(IRadp, IntRadpSum)\n\n        inival = solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # here in res the biasValues and the corresponding current are stored.\n    # res = [biasValues IV];\n\n    if Plotter !== nothing\n        plot_energies!(vis[2, 1], ctsys, solution, \"bias Δu = $(endVoltage)\", label_energy)\n        plot_densities!(vis[2, 2], ctsys, solution, \"bias Δu = $(endVoltage)\", label_density)\n        plot_solution!(vis[2, 3], ctsys, solution, \"bias Δu = $(endVoltage)\", label_solution)\n    end\n\n    biasValues = contactVoltageFunction[p.bregionAcceptor].(tvalues)\n\n    if Plotter !== nothing\n        scalarplot!(\n            vis[2, 4],\n            tvalues,\n            biasValues,\n            markershape = :circle,\n            xlabel = L\"\\text{time [s]}\",\n            ylabel = L\"\\text{bias [V]}\",\n            title = \"Applied voltage over time\"\n        )\n\n        ###############\n        plot_IV!(vis[3, 1], biasValues[2:end], IV, \"bias Δu = $(endVoltage)\")\n\n        ###############\n\nPlot Recombination SRH recombination electrons\n\n        scalarplot!(\n            vis[3, 2],\n            biasValues[2:end],\n            ISRHn .* (cm^2) .* 1.0e3;\n            clear = false,\n            yscale = :log,\n            linewidth = 5,\n            color = :darkblue,\n            label = \"SRH recombination (n)\",\n            legend = :rb,\n            xlabel = L\"\\text{bias [V]}\",\n            ylabel = L\"current density [$\\frac{\\text{mA}}{\\text{cm}^2}$]\",\n            title = \"Recombination\"\n        )\n\nSRH recombination holes\n\n        scalarplot!(\n            vis[3, 2],\n            biasValues[2:end],\n            ISRHp .* (cm^2) .* 1.0e3;\n            clear = false,\n            yscale = :log,\n            linewidth = 5,\n            color = :lightblue,\n            linestyle = :dot,\n            label = \"SRH recombination (p)\",\n            legend = :rb\n        )\n\nRadiative Recombination electrons\n\n        scalarplot!(\n            vis[3, 2],\n            biasValues[2:end],\n            IRadn .* (cm^2) .* 1.0e3;\n            clear = false,\n            yscale = :log,\n            linewidth = 5,\n            color = :darkgreen,\n            label = \"Radiative recombination (n)\",\n            legend = :rb\n        )\n\nRadiative Recombination holes\n\n        scalarplot!(\n            vis[3, 2],\n            biasValues[2:end],\n            IRadp .* (cm^2) .* 1.0e3;\n            clear = false,\n            yscale = :log10,\n            linewidth = 2,\n            color = :lightgreen,\n            linestyle = :dot,\n            label = \"Radiative recombination (p)\",\n            legend = :rb\n        )\n\n        reveal(vis)\n    end\n\n    if test == false\n        integral = integrated_density(ctsys, sol = solution, icc = p.iphia, ireg = p.regionIntrinsic)\n\n        println(\"Calculated average vacancy density is: \", integral / data.regionVolumes[p.regionIntrinsic])\n        println(\" \")\n        if vacancyEnergyCalculation\n            vacancyEnergy = data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] / data.constants.q\n            println(\"Value for vacancy energy is: \", vacancyEnergy, \" eV. Save this value for later use.\")\n            println(\"We recommend to calculate it on a fine grid.\")\n            println(\" \")\n        end\n    end\n\n    if otherScanProtocol\n        return IV[1]\n    else\n        return sum(IV)\n    end\n\nend #  main\n\nfunction test()\n    testval = 313.58311884281136; testvalOther = 0.004948787599489832\n    @show main(test = true, otherScanProtocol = false)\n    @show main(test = true, otherScanProtocol = true, vacancyEnergyCalculation = false)\n    return main(test = true, otherScanProtocol = false) ≈ testval && abs(main(test = true, otherScanProtocol = true, vacancyEnergyCalculation = false) - testvalOther) / testvalOther < 1.0e-7\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"GaAs/#van-Roosbroeck-system","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:\n\nbeginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - C_p ) - (n(psi varphi_n) - C_n) Big)\n\tq partial_t n(psi varphi_n) -nabla cdot mathbfj_n = -qR(np) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = -qR(np)\nendaligned\n\nOhmic contacts will be used as boundary conditions. We will proceed as follows\n\nStep 1: Initialize grid\n\nStep 2: Initialize physical model\n\nStep 3: Solve the problem in equilibrium\n\nStep 4: Solve the problem for an applied bias","category":"section"},{"location":"GaAs/#Example-1:-Stationary-1D-problem-(region-doping)","page":"van Roosbroeck system","title":"Example 1: Stationary 1D problem (region doping)","text":"We consider a three-layer GaAs p-i-n device in one dimension. We will explain the PIN example in greater detail.\n\nAs Step 0, we need to import all used units and constants:\n\n# unit factors\n@local_unitfactors μm cm s ns V K\n\n# constants\nconstants = ChargeTransport.constants\n(; q, k_B, ε_0) = constants\n\neV = q * V","category":"section"},{"location":"GaAs/#Step-1:-Initialize-grid","page":"van Roosbroeck system","title":"Step 1: Initialize grid","text":"We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.\n\n\n## region numbers\nregionAcceptor = 1           # p doped region\nregionIntrinsic = 2          # intrinsic region\nregionDonor = 3              # n doped region\nregions = [regionAcceptor, regionIntrinsic, regionDonor]\nnumberOfRegions = length(regions)\n\n## boundary region numbers\n# Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n# adding additional interior boundaries, continue with 3, 4, ...\nbregionAcceptor = 1\nbregionDonor = 2\nbregionJunction1 = 3\nbregionJunction2 = 4\n\n## grid\nrefinementfactor = 2^(n - 1)\nh_pdoping = 2.0 * μm\nh_intrinsic = 2.0 * μm\nh_ndoping = 2.0 * μm\nh_total = h_pdoping + h_intrinsic + h_ndoping\nw_device = 0.5 * μm  # width of device\nz_device = 1.0e-4 * cm  # depth of device\ncoord = initialize_pin_grid(\n    refinementfactor,\n    h_pdoping,\n    h_intrinsic,\n    h_ndoping\n)\n\ngrid             = simplexgrid(coord)\n\n## cellmask! for defining the subregions and assigning region number\ncellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor)  # p-doped region = 1\ncellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic) # intrinsic region = 2\ncellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n## bfacemask! for setting different boundary regions. At exterior boundaries they are automatically set by\n## ExtendableGridsjl. Thus, there the following two lines are actually unneccesarry, but are only written for completeness.\nbfacemask!(grid, [0.0], [0.0], bregionAcceptor)     # outer left boundary\nbfacemask!(grid, [h_total], [h_total], bregionDonor)  # outer right boundary\nbfacemask!(grid, [h_pdoping], [h_pdoping], bregionJunction1) # first  inner interface\nbfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface","category":"section"},{"location":"GaAs/#Step-2:-Initialize-physical-model","page":"van Roosbroeck system","title":"Step 2: Initialize physical model","text":"Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to numberOfCarriers + 1.\n\n# Set indices for the quasi Fermi potentials\niphin = 1    # electrons\niphip = 2    # holes\nnumberOfCarriers = 2\n\n# Initialize Data instance\ndata = Data(grid, numberOfCarriers)\n\n# Solve the stationary problem instead of the transient one\ndata.modelType = Stationary\n\n# by default, we set as statistics function for electrons and holes Boltzmann, if you want to have a more\n# general description like FermiDirac, please use data.F .= FermiDiracOneHalfTeSCA\n\n# Enable/Disable recombination processes, the default is stationary SRH recombination.\ndata.bulkRecombination = set_bulk_recombination(;\n    iphin = iphin, iphip = iphip,\n    bulk_recomb_Auger = true,\n    bulk_recomb_radiative = true,\n    bulk_recomb_SRH = true\n)\n\n# choose boundary models\n# exterior boundaries: OhmicContact and SchottkyContact\n# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.\ndata.boundaryType[bregionAcceptor] = OhmicContact\ndata.boundaryType[bregionDonor] = OhmicContact\n\n\nNext, we fill in pre-defined or externally read in parameter values.\n\n# params contains all necessary physical parameters\nparams = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\nparams.temperature = T\nparams.chargeNumbers[iphin] = -1\nparams.chargeNumbers[iphip] = 1\n\nfor ireg in 1:numberOfRegions # region data\n\n    params.dielectricConstant[ireg] = εr * ε_0\n\n    ## effective DOS, band-edge energy and mobilities\n    params.densityOfStates[iphin, ireg] = Nc\n    params.densityOfStates[iphip, ireg] = Nv\n    params.bandEdgeEnergy[iphin, ireg] = Ec\n    params.bandEdgeEnergy[iphip, ireg] = Ev\n    params.mobility[iphin, ireg] = mun\n    params.mobility[iphip, ireg] = mup\n\n    ## recombination parameters\n    params.recombinationRadiative[ireg] = Radiative\n    params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n    params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n    params.recombinationAuger[iphin, ireg] = Auger\n    params.recombinationAuger[iphip, ireg] = Auger\n\nend\n\n# doping\nparams.doping[iphin, regionDonor] = Nd\nparams.doping[iphin, regionIntrinsic] = ni\nparams.doping[iphip, regionIntrinsic] = 0.0\nparams.doping[iphip, regionAcceptor] = Na\n\n# Initialize a ChargeTransport struct\ndata.params = params\nctsys = System(grid, data, unknown_storage=unknown_storage)","category":"section"},{"location":"GaAs/#Step-3:-Solve-the-problem-in-equilibrium","page":"van Roosbroeck system","title":"Step 3: Solve the problem in equilibrium","text":"Solve the equilibrium. Note that control refers to the SolverControl parameters given in VoronoiFVM.\n\nsolution = equilibrium_solve!(ctsys, control = control)\ninival = solution","category":"section"},{"location":"GaAs/#Step-4:-Solve-the-problem-for-an-applied-bias","page":"van Roosbroeck system","title":"Step 4: Solve the problem for an applied bias","text":"Starting from the equilibrium solution, we increase the applied voltage.\n\nmaxBias = voltageAcceptor # bias at acceptor boundary\nbiasValues = range(0, stop = maxBias, length = 32)\n\nfor Δu in biasValues\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc\n    solution = solve(ctsys; inival = inival, control = control)\n    inival .= solution\nend","category":"section"},{"location":"GaAs/#Step-5:-Postprocessing","page":"van Roosbroeck system","title":"Step 5: Postprocessing","text":"By adding the following line to the previous loop\n\ncurrent = get_current_val(ctsys, solution)\n\nwe have the possibility to calculate the total current.\n\nMoreover, there are several plotting routines, see ct_plotting.jl.","category":"section"},{"location":"GaAs/#Example-2:-Stationary-1D-problem-(nodal-doping)","page":"van Roosbroeck system","title":"Example 2: Stationary 1D problem (nodal doping)","text":"Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of ParamsNodal.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from this example)\n\nparamsnodal = ParamsNodal(grid, numberOfCarriers)\n\n# initialize the space dependent doping\nNDoping = 1.0e17  / cm^3; κ = 500.0\nfor icoord = 1:numberOfNodes\n    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )\n    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )\n    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )\nend\n\ndata.paramsnodal = paramsnodal","category":"section"},{"location":"changes/","page":"Changelog","title":"Changelog","text":"using Markdown\nMarkdown.parse(read(\"../../CHANGELOG.md\",String))","category":"section"},{"location":"module_examples/Ex104_PSC_Photogeneration/#PSC-device-with-photogeneration-rate-(1D).","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"(source code)\n\nSimulating a three layer PSC device TiO2 | MAPI | Pedot with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.\n\nWe perform a linear scan protocol and try out different photogeneration rates.\n\nmodule Ex104_PSC_Photogeneration\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing LaTeXStrings # sonst funktioniert includet() nicht\n\nfor convenience\n\nparametersdir = ChargeTransport.parametersdir\n\nsupported Plotters are GLMakie and PythonPlot you can set verbose also to true to display some solver information\n\nfunction main(;\n        n = 5,\n        Plotter = nothing,\n        verbose = false, test = false,\n        ########################\n        parameter_set = Params_PSC_TiO2_MAPI_spiro, # choose the parameter set\n        ########################\n        userdefinedGeneration = false,              # you can choose between predefined and user-defined generation profiles\n        vacancyEnergyCalculation = true,            # assume the vacancy energy level is either given or not\n    )\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\nparameters\n\n    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 0.04 * V / s\n    number_tsteps = 31\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = endVoltage / scanrate\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if 0.0 <= t  && t <= tend\n            biasVal = 0.0 + scanrate * t\n        elseif t > tend  && t <= 2 * tend\n            biasVal = scanrate * tend .+ scanrate * (tend - t)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2,\n        p.h_ndoping,\n        p.h_ndoping / (0.7 * δ),\n        p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping,\n        p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (2.8 * δ),\n        p.h_intrinsic / (2.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k,\n        p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (2.1 * δ),\n        p.h_intrinsic / (2.8 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic,\n        p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.6 * δ),\n        p.h_pdoping / (1.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (1.3 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18) # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18) # p-doped region   = 3\n\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18)\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18)\n\n    if Plotter !== nothing\n        vis = GridVisualizer(; Plotter, layout = (4, 2), size = (1550, 800))\n        gridplot!(vis[1, 1], grid; Plotter, legend = :lt, title = \"Grid\", xlabel = L\"\\text{space [m]}\", show = true)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    if userdefinedGeneration\n\n        subg1 = subgrid(grid, [p.regionDonor]); subg2 = subgrid(grid, [p.regionIntrinsic]); subg3 = subgrid(grid, [p.regionAcceptor])\n\n        gen1 = zeros(length(subg1[Coordinates]) - 1); gen3 = zeros(length(subg3[Coordinates]) - 1)\n        gen2 = p.incidentPhotonFlux[p.regionIntrinsic] .* p.absorption[p.regionIntrinsic] .* exp.(- p.absorption[p.regionIntrinsic] .* (subg2[Coordinates] .- p.generationPeak))\n\n        # we want to get agreement with the region-wise defined photogeneration\n        X1 = subg1[Coordinates]; X2 = subg2[Coordinates]; X3 = subg3[Coordinates]\n\n        h1end = X1[end] - X1[end - 1]; h2beg = X2[2] - X2[1]\n        h2end = X2[end] - X2[end - 1]; h3beg = X3[2] - X3[1]\n\nregion reaction multiplies with h2beg/2 ( = | ωk ∩ region2|) it visits the node only from region2 node reaction multiplies with (h1end+h2beg)/2 ( = | ωk|)  as it visits the node from region 1 and region 2 therefore, we need the following weights However, note that | ω_k ∩ region2| is not calculate explicitly but via the simplex components (if we have cellwise loops)\n\n        weight1 = h2beg / (h1end + h2beg) # ( = | ω_k ∩ region2| / | ω_k| )\n        weight2 = h2end / (h2end + h3beg)\n\n        gen2[1] = weight1 * gen2[1]; gen2[end] = weight2 * gen2[end]\n\n        generationData = [gen1; gen2'; gen3]\n\n        data = Data(\n            grid, p.numberOfCarriers,\n            contactVoltageFunction = contactVoltageFunction,\n            generationData = generationData\n        )\n    else\n\n        data = Data(\n            grid, p.numberOfCarriers,\n            contactVoltageFunction = contactVoltageFunction\n        )\n\n    end\n\n    data.modelType = Transient\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[p.iphin] = FermiDiracOneHalfTeSCA\n    data.F[p.iphip] = FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # by default the statistics function is set to FermiDiracMinusOne to limit ion depletion\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    if userdefinedGeneration\n        data.generationModel = GenerationUserDefined\n    else\n        data.generationModel = GenerationBeerLambert\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n\n    if !vacancyEnergyCalculation\n        data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] = p.Ea[p.regionIntrinsic]\n    end\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.max_round = 5\n    control.damp_initial = 0.5\n    control.damp_growth = 1.21 # >= 1\n    control.Δt_max = 5.0e-1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control, vacancyEnergyCalculation = vacancyEnergyCalculation)\n    inival = solution\n    solutionEQ = inival\n\n    if Plotter !== nothing\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, p.iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, p.iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[p.iphia] = \"\\$E_a\\$\"\n        label_density[p.iphia] = \"\\$ n_a \\$\";      label_solution[p.iphia] = \"\\$ \\\\varphi_a\\$\"\n\n        plot_densities!(vis[1, 2], ctsys, solution, \"Initial condition\", label_density)\n        plot_solution!(vis[2, 1], ctsys, solution, \"Initial condition\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # put here back the homogeneous Neumann boundary conditions.\n    ctsys.fvmsys.boundary_factors[p.iphia, p.bregionJ2] = 0.0\n    ctsys.fvmsys.boundary_values[p.iphia, p.bregionJ2] = 0.0\n\n    sol = solve(ctsys, inival = inival, times = (0.0, tend), control = control)\n\n    if Plotter !== nothing\n        tsol = sol(tend)\n\n        plot_densities!(vis[2, 2], ctsys, tsol, \"Densities at end time\", label_density)\n        plot_solution!(vis[3, 1], ctsys, tsol, \"Solution at end time\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Reverse scan protocol\")\n    end\n    ################################################################################\n    inivalReverse = sol(tend)\n    solReverse = solve(ctsys, inival = inivalReverse, times = (tend, 2 * tend), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Curve calculation\")\n    end\n    ################################################################################\n\n    factory = TestFunctionFactory(ctsys)\n    tf = testfunction(factory, [p.bregionDonor], [p.bregionAcceptor])\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n    biasValues = scanProtocol.(tvalues)\n    IV = zeros(0)\n\n    for istep in 2:number_tsteps\n        Δt = tvalues[istep] - tvalues[istep - 1] # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(p.numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    tvaluesReverse = solReverse.t\n    number_tstepsReverse = length(tvaluesReverse)\n    biasValuesReverse = scanProtocol.(tvaluesReverse)\n    IVReverse = zeros(0)\n\n    for istep in 2:number_tstepsReverse\n        Δt = tvaluesReverse[istep] - tvaluesReverse[istep - 1] # Time step size\n        inival = solReverse.u[istep - 1]\n        solution = solReverse.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(p.numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IVReverse, current)\n\n    end\n\n    if Plotter !== nothing\n        scalarplot!(\n            vis[3, 2],\n            tvalues,\n            biasValues;\n            clear = false,\n            markershape = :cross,\n            markersize = 8,\n            color = \"blue\",\n            label = \"forward\",\n            legend = :cc,\n            xlabel = L\"\\text{time [s]}\",\n            ylabel = L\"\\text{voltage [V]}\",\n            title = \"Applied bias over time\"\n        )\n\n        scalarplot!(\n            vis[3, 2],\n            tvaluesReverse,\n            biasValuesReverse;\n            clear = false,\n            markershape = :cross,\n            markersize = 8,\n            color = \"orange\",\n            label = \"reverse\",\n            legend = :cc\n        )\n\n        scalarplot!(\n            vis[4, 1],\n            biasValues[2:end],\n            -IV;\n            linewidth = 2,\n            label = \"forward\",\n            legend = :cc,\n            color = \"blue\",\n            xlabel = L\"\\text{applied bias [V]}\",\n            ylabel = L\"\\text{total current [A]}\",\n            title = \"Total current\",\n            clear = false\n        )\n\n        scalarplot!(\n            vis[4, 1],\n            biasValuesReverse[2:end],\n            -IVReverse;\n            linewidth = 2,\n            label = \"reverse\",\n            legend = :cc,\n            color = \"orange\",\n            clear = false\n        )\n\n        if userdefinedGeneration\n            scalarplot!(\n                vis[4, 2],\n                coord,\n                data.generationData;\n                xlabel = L\"\\text{space [m]}\",\n                ylabel = L\"photogeneration [$\\frac{1}{\\text{cm}^3 s}$]\",\n                title = \"Photogeneration\"\n            )\n        else\n            colors = [\"blue\", \"orange\", \"green\"]\n\n            for ireg in 1:p.numberOfRegions\n                subg = subgrid(grid, [ireg])\n                scalarplot!(\n                    vis[4, 2],\n                    subg,\n                    BeerLambert(ctsys, ireg, subg[Coordinates])';\n                    clear = false,\n                    color = colors[ireg],\n                    label = \"region $ireg\",\n                    legend = :cc,\n                    xlabel = L\"\\text{space [m]}\",\n                    ylabel = L\"photogeneration [$\\frac{1}{\\text{cm}^3 s}$]\",\n                    title = \"Photogeneration\"\n                )\n            end\n        end\n\n        reveal(vis)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute fill factor and efficiency\")\n    end\n    ################################################################################\n\n    bias = biasValues[2:end]\n    IV = -IV\n\n    powerDensity = bias .* (IV)           # power density function\n    MaxPD, indexPD = findmax(powerDensity)\n\n    open_circuit = compute_open_circuit_voltage(bias, IV)\n\n    IncidentLightPowerDensity = 1000.0 * W / m^2\n\n    fillfactor = 100.0 .* (bias[indexPD] * IV[indexPD]) / (IV[1] * open_circuit)\n\n    efficiency = 100.0 .* bias[indexPD] * IV[indexPD] / IncidentLightPowerDensity\n\n    if test == false\n        println(\" \")\n        println(\"The fill factor is $(round(fillfactor, digits = 3)) %.\")\n        println(\"The efficiency  is $(round(efficiency, digits = 3)) %.\")\n        println(\"The open circuit voltage  is $(round(open_circuit, digits = 3)) V.\")\n        println(\" \")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        integral = integrated_density(ctsys, sol = solution, icc = p.iphia, ireg = p.regionIntrinsic)\n\n        println(\"Calculated average vacancy density is: \", integral / data.regionVolumes[p.regionIntrinsic])\n        println(\" \")\n        if vacancyEnergyCalculation\n            vacancyEnergy = data.params.bandEdgeEnergy[p.iphia, p.regionIntrinsic] / data.constants.q\n            println(\"Value for vacancy energy is: \", vacancyEnergy, \" eV. Save this value for later use.\")\n            println(\"We recommend to calculate it on a fine grid.\")\n            println(\" \")\n        end\n    end\n\n    testval = sum(filter(!isnan, solutionEQ)) / length(solutionEQ) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -1.0451771259505067; testvalvacancyEnergyCalculation = -1.046195159158462\n    return main(test = true, vacancyEnergyCalculation = true) ≈ testval && main(test = true, vacancyEnergyCalculation = false) ≈ testvalvacancyEnergyCalculation && main(test = true, userdefinedGeneration = true) ≈ testval\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"general/#ChargeTransport.jl-–-Simulating-charge-transport-in-semiconductors","page":"Home","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"(Image: Build status) (Image: ) (Image: )\n\nChargeTransport.jl simulates charge transport in semiconductors. To this end, it discretizes the semiconductor drift-diffusion equations via the Voronoi finite volume method as implemented in VoronoiFVM.jl.","category":"section"},{"location":"general/#Special-features","page":"Home","title":"Special features","text":"heterostructures\n1D, 2D and 3D simulations\nstationary and transient simulations\nIV curves and scan protocols\nan arbitrary amount of charge carriers (electrons, heavy holes, light holes, ions, ...)\nthermodynamically consistent, physics preserving numerical methods\ndifferent charge carrier statistics per species (Boltzmann, Blakemore, Fermi-Dirac)\nAuger, radiative, Shockley-Read-Hall recombination\nuniform and Beer-Lambert generation","category":"section"},{"location":"general/#Installation-and-first-steps","page":"Home","title":"Installation and first steps","text":"The installation can easily be done via the Julia REPL with the following commands\n\njulia> using Pkg\njulia> Pkg.add(\"ChargeTransport\")\n\nWe recommend have a look at the example files:\n\nPages = [\n    \"GaAs.md\",\n    \"PSC.md\",\n    ]\nDepth = 2\n\nYou can load an example as follows\n\njulia> include(\"Ex103_PSC.jl\")\njulia> Ex103_PSC.main()\njulia> Ex103_PSC.main(plotting = true) # show plots\n\nSince the examples are encapsulated into modules, you can load as many examples as you wish. If you would like to modify one of the examples, consider using Revise.jl and includet.","category":"section"},{"location":"general/#Literature","page":"Home","title":"Literature","text":"The simulations in the following papers are based on ChargeTransport.jl:\n\n[1.] D. Abdel, P. Farrell and J. Fuhrmann. Assessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation. Optical and Quantum Electronics 53, 163 (2021).\n\n[2.] D. Abdel, P. Vágner, J. Fuhrmann and P. Farrell. Modelling charge transport in perovskite solar cells: Potential-based and limiting ion depletion. Electrochimica Acta 390 (2021).\n\n[3.] D. Abdel, C. Chainais-Hillairet, P. Farrell and M. Herda. Numerical analysis of a finite volume scheme for charge transport in perovskite solar cells. IMA Journal of Numerical Analysis (2023).\n\n[4.] D. Abdel, N. E. Courtier and P. Farrell. Volume exclusion effects in perovskite charge transport modeling. Optical and Quantum Electronics 55, 884 (2023).\n\n[5.] B. Spetzler, D. Abdel, F. Schwierz, M. Ziegler and P. Farrell. The Role of Vacancy Dynamics in Two-Dimensional Memristive Devices. Advanced Electronic Materials (2023).\n\n[6.] D. Abdel, A. Glitzky and M. Liero. Analysis of a drift-diffusion model for perovskite solar cells. Discrete and Continuous Dynamical Systems - Series B (2024).\n\n[7.] D. Abdel, M. Herda, M. Ziegler, C. Chainais-Hillairet, B. Spetzler, P. Farrell. Numerical analysis and simulation of lateral memristive devices: Schottky, ohmic, and multi-dimensional electrode models. submitted (2024).\n\n[8.] B. Spetzler, E. Spetzler, S. Zamankhani, D. Abdel, P. Farrell, K.-U. Sattler, M. Ziegler. Physics-Guided Sequence Modeling for Fast Simulation and Design Exploration of 2D Memristive Devices. (2025).\n\n[9.] D. Abdel, J. Relle, T. Kirchartz, P. Jaap, J. Fuhrmann, S. Burger, C. Becker, K. Jäger, P. Farrell. Unravelling the mystery of enhanced open-circuit voltages in nanotextured perovskite solar cells. submitted (2025).","category":"section"},{"location":"module_examples/Ex109_PSC_NonDimensional/#Nondimensionalized-perovskite-solar-cell.","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"(source code)\n\nSimulation of charge transport in a non-dimensionalized three-layer perovskite solar cell. All physical parameters and constants are set to 1 besides the energies which are set to zero. This example serves an academic purpose. The main() method is doing the study for one specific prefactor G0 of the photogeneration, while the GenerationStudy() method does the parameter study with respect to G0. For the underlying manuscript\n\nExistence of solutions and uniform bounds for the stationary semiconductor equations with generation and ionic carriers,     by D. Abdel, A. Blaustein, M. Herda, C. Chainais-Hillairet, and J. Moatti.\n\nthe test cases are (for n = 80)","category":"section"},{"location":"module_examples/Ex109_PSC_NonDimensional/#A:-enableIons-false,-DirichletVal-2.0","page":"Nondimensionalized perovskite solar cell.","title":"A: enableIons = false, DirichletVal = 2.0","text":"","category":"section"},{"location":"module_examples/Ex109_PSC_NonDimensional/#B:-enableIons-true,-DirichletVal-1.0","page":"Nondimensionalized perovskite solar cell.","title":"B: enableIons = true,  DirichletVal = 1.0","text":"module Ex109_PSC_NonDimensional\n\nusing ChargeTransport\nusing VoronoiFVM\nusing ExtendableGrids\nusing LaTeXStrings\n\nregion numbers\n\nregion1 = 1\nregion2 = 2\nregion3 = 3\nregions = [region1, region2, region3]\nnumberOfRegions = length(regions)\n\nboundary region numbers\n\nbregion1 = 1\nbregion2 = 2\n\n# grid\nh1 = 1.0; h2 = 4.0; h3 = 2.0\nh_total = h1 + h2 + h3\n\niphin = 1              # electron quasi Fermi potential\niphip = 2              # hole quasi Fermi potential\n\nWe define the physical data.\n\nzn = -1; zp = 1; za = 1\nEn = 0.0; Ep = 0.0; Ea = 0.0  # set the energies to 0\nNn = 1.0; Np = 1.0; Na = 10.0 # set the effective DOS to 1\nμn = 1.0; μp = 1.0; μa = 1.0  # set the mobilities to 1\nT = 1.0                       # set temperature to 1\n\n# recombination parameters\nSRH_TrapDensity = 0.0\nSRH_LifeTime = 1.0\nRadiative = 1.0\n\n# doping\nCa = 7.5\n\nyou can set verbose also to true to display some solver information\n\nfunction main(;\n        n = 80,               # for number of nodes in each layer\n        Cn = 10, Cp = 10,     # doping\n        λ = 1.0,              # Debye length\n        DirichletVal = 2.0,   # Dirichlet value\n        G0 = 1.0,             # photogeneration prefactor\n        enableIons = false,   # present vacancies or not\n        #################################\n        parameterStudy = false,\n        parseInival = false, inival = Array{Float64, 2},\n        #################################\n        Plotter = nothing,\n        verbose = false, test = false\n    )\n\n    if Plotter !== nothing && (nameof(Plotter) ∉ [:PythonPlot, :PyPlot])\n        error(\"We need PythonPlot as Plotter for this example. Please add PythonPlot to your global environment via the package manager and choose `Plotter = PythonPlot`.\")\n    end\n\n    if Plotter !== nothing\n        Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n        Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n        Plotter.close(\"all\")\n    end\n\nconstants Here, we set the constants to unityconstants. In particular, we set: q = kB = ε_0 = 1 When defining `ChargeTransport.constants\" the constants based on CODATA2022 are used.\n\n    constants = ChargeTransport.unity_constants\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    coord1 = collect(range(0.0; stop = h1, length = n))\n    coord2 = collect(range(h1; stop = h1 + h2, length = 4 * n))\n    coord3 = collect(range(h1 + h2; stop = h_total, length = 2 * n))\n    coord = glue(coord1, coord2)\n    coord = glue(coord, coord3)\n\n    grid = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0], [h1], region1)\n    cellmask!(grid, [h1], [h1 + h2], region2)\n    cellmask!(grid, [h1 + h2], [h_total], region3)\n\n    # bfacemask! for setting different boundary regions.\n    bfacemask!(grid, [0.0], [0.0], bregion1)\n    bfacemask!(grid, [h_total], [h_total], bregion2)\n\n    if Plotter !== nothing\n        gridplot(grid, Plotter = Plotter)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    if enableIons && DirichletVal != 1.0\n        @warn \"Caution, initial value for the ions is only correct for `DirichletVal = 1.0` as the average density need to be equal to Ca.\n        We adjusted the Dirichlet value to 1.0\"\n        DirichletVal = 1.0\n    end\n\n    if enableIons\n        iphia = 3          # vacancies\n        ipsi = 4           # electric potential\n        numberOfCarriers = 3\n    else\n        ipsi = 3           # electric potential\n        numberOfCarriers = 2\n    end\n\nphotogeneration\n\n    G(x) = G0 .* exp.(- (x .- h1))\n    genData = zeros(length(coord))\n    genData[length(coord1):(length(coord1) + length(coord2) - 1)] = G.(coord2)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\nWe initialize the Data instance and fill in predefined data. Define the unity constants also in the discrete counterpart of the model\n\n    data = Data(grid, numberOfCarriers, generationData = genData, constants = constants)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType = Stationary\n\n    # The default for electrons and holes is Boltzmann. Here, we set it to a more general statistics function\n    data.F[iphin] = FermiDiracOneHalfTeSCA\n    data.F[iphip] = FermiDiracOneHalfTeSCA\n\n    data.boundaryType[bregion1] = OhmicContact\n    data.boundaryType[bregion2] = OhmicContact\n\n    if enableIons\n        enable_ionic_carrier!(data, ionicCarrier = iphia, regions = [region2])\n    end\n\n    # The desired recombination processes can be chosen here.\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\ngeneration model\n\n    data.generationModel = GenerationUserDefined\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\nDefine the Params struct\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = zn\n    params.chargeNumbers[iphip] = zp\n    if enableIons\n        params.chargeNumbers[iphia] = za\n    end\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg] = λ^2\n\nthe effective density of states and mobilities are set by default to one and the band-edge by default to zero. This is why they do not necessarily need to be parsed here.","category":"section"},{"location":"module_examples/Ex109_PSC_NonDimensional/#effective-DOS,-band-edge-energy-and-mobilities","page":"Nondimensionalized perovskite solar cell.","title":"effective DOS, band-edge energy and mobilities","text":"params.densityOfStates[iphin, ireg] = Nn params.densityOfStates[iphip, ireg] = Np params.bandEdgeEnergy[iphin, ireg] = En params.bandEdgeEnergy[iphip, ireg] = Ep params.mobility[iphin, ireg] = μn params.mobility[iphip, ireg] = μp\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n\n    end\n\n    # doping\n    params.doping[iphin, region1] = Cn\n    params.doping[iphip, region3] = Cp\n\n    # vacancy parameters\n    if enableIons\n        params.densityOfStates[iphia, region2] = Na\n        params.bandEdgeEnergy[iphia, region2] = Ea\n        params.mobility[iphia, region2] = μa\n        params.doping[iphia, region2] = Ca\n    end\n\nRegion dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.\n\n    data.params = params\n\nIn the last step, we initialize our system with previous data which is likewise dependent on the parameters.\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = VoronoiFVM.SolverControl()\n    control.verbose = verbose\n    control.maxiters = 50\n    control.abstol = 1.0e-6\n    control.reltol = 1.0e-6\n    control.tol_round = 1.0e-6\n    control.damp_initial = 0.5\n    control.damp_growth = 1.61\n    control.max_round = 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Solving the nonlinear system of equations\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    inival2 = equilibrium_solve!(ctsys, control = control)\n\n    if parseInival\n        inival2 = inival\n    end\n\n    # we need to fix the average vacancy density\n    if enableIons\n        if G0 < 0.1\n            inival2[iphia, :] .= 0.7\n        elseif G0 == 0.1\n            inival2[iphia, :] .= 0.705\n        elseif G0 == 0.5\n            inival2[iphia, :] .= 0.729\n        elseif G0 == 1.0\n            inival2[iphia, :] .= 0.757\n        elseif G0 == 5.0e0\n            inival2[iphia, :] .= 0.955\n        elseif G0 == 1.0e1\n            inival2[iphia, :] .= 1.143\n        elseif G0 == 5.0e1\n            inival2[iphia, :] .= 1.842\n        elseif G0 == 1.0e2\n            inival2[iphia, :] .= 2.209\n        elseif G0 == 5.0e2\n            inival2[iphia, :] .= 3.08\n        elseif G0 == 1.0e3\n            inival2[iphia, :] .= 3.435\n        end\n\n    end\n\n    set_contact!(ctsys, 2, Δu = DirichletVal)\n    sol = ChargeTransport.solve(ctsys, inival = inival2, control = control)\n\n    if enableIons && test == false\n        integral = integrated_density(ctsys, sol = sol, icc = iphia, ireg = region2)\n        mOmega = data.regionVolumes[region2]\n\n        println(\"Given vacancy density is: \", Ca)\n        println(\"Calculated average vacancy density is: \", integral / mOmega)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if parameterStudy\n        return coord, sol\n    end\n\n    ################################################################################\n    if test == false && (nameof(Plotter) ∈ [:PythonPlot, :PyPlot])\n        println(\"Plotting\")\n    end\n    ################################################################################\n\n    nn = Nn .* data.F[iphin].(zn * (sol[iphin, :] - sol[ipsi, :]))\n    np = Np .* data.F[iphip].(zp * (sol[iphip, :] - sol[ipsi, :]))\n    if enableIons\n        na = Na .* data.F[iphia].(za * (sol[iphia, :] - sol[ipsi, :]))\n    end\n\n    if Plotter !== nothing\n\n        Plotter.figure()\n        Plotter.plot(coord, zn .* sol[iphin, :], color = \"green\", linewidth = 5, label = \"\\$ v_{\\\\mathrm{n}}\\$\")\n        Plotter.plot(coord, zp .* sol[iphip, :], color = \"red\", linewidth = 5, linestyle = \"--\", label = \"\\$ v_{\\\\mathrm{p}}\\$\")\n        Plotter.plot(coord, sol[ipsi, :], color = \"blue\", linestyle = \":\", linewidth = 5, label = \"\\$ \\\\psi\\$\")\n        if enableIons\n            Plotter.plot(coord[n:5n], za .* sol[iphia, n:5n], color = \"gold\", linewidth = 5, linestyle = \"--\", label = \"\\$ v_{\\\\mathrm{a}}\\$\")\n        end\n        Plotter.axvspan(0.0, 1.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.xlim(0.0, 7.0)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Potential\", fontsize = 17)\n        Plotter.tight_layout()\n        Plotter.legend(loc = \"center right\", fontsize = 14)\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n\n        ########################################################\n\n        Plotter.figure()\n        Plotter.semilogy(coord, nn, color = \"green\", linewidth = 5, label = \"\\$ n_{\\\\mathrm{n}}\\$\")\n        Plotter.semilogy(coord, np, color = \"red\", linewidth = 5, label = \"\\$ n_{\\\\mathrm{p}}\\$\")\n        if enableIons\n            Plotter.semilogy(coord[n:5n], na[n:5n], color = \"gold\", linewidth = 5, label = \"\\$ n_{\\\\mathrm{a}}\\$\")\n        end\n        Plotter.legend(loc = \"center right\", fontsize = 14)\n        Plotter.xlim(0.0, 7.0)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Density\", fontsize = 17)\n        Plotter.tight_layout()\n\n        current_figure = Plotter.gcf()\n        display(current_figure)\n\n    end\n\n    return sum(filter(!isnan, sol)) / length(sol)\n\n    if test == false && nameof(Plotter) == :PyPlot\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\n\n#######################################################################\n#######################################################################\n\nFor the underlying manuscript, the test cases are (for n = 80)\n\n# A: enableIons = false, DirichletVal = 2.0\n# B: enableIons = true,  DirichletVal = 1.0\n\nfunction GenerationStudy(;\n        n = 80,               # for number of nodes in each layer\n        Cn = 10, Cp = 10,     # doping\n        λ = 1.0,              # Debye length\n        DirichletVal = 2.0,   # Dirichlet value\n        enableIons = false,   # enabling ions\n        Plotter = nothing,\n        verbose = false\n    )\n\n    if !isnothing(Plotter) && nameof(Plotter) != :PyPlot\n        @warn \"We need PyPlot as Plotter for this example. Please add PyPlot to your global environment via the package manager and choose `Plotter = PyPlot`.\"\n\n        Plotter = nothing\n    end\n\n    if Plotter !== nothing\n        Plotter.rc(\"font\", family = \"sans-serif\", size = 14)\n        Plotter.rc(\"mathtext\", fontset = \"dejavusans\")\n        Plotter.close(\"all\")\n    end\n\n    if enableIons && DirichletVal != 1.0\n        @warn \"Caution, initial value for the ions is only correct for `DirichletVal = 1.0` as the average density need to be equal to Ca.\n        We adjusted the Dirichlet value to 1.0\"\n        DirichletVal = 1.0\n    end\n\n    if enableIons\n        iphia = 3          # vacancies\n        ipsi = 4           # electric potential\n        numberOfCarriers = 3\n    else\n        ipsi = 3           # electric potential\n        numberOfCarriers = 2\n    end\n\n    G0Vec = [1.0e-3, 5.0e-3, 1.0e-2, 5.0e-2, 1.0e-1, 5.0e-1, 1.0e0, 5.0e0, 1.0e1, 5.0e1, 1.0e2, 5.0e2, 1.0e3]\n\n    soleM1 = Array{Float64, 2}; sole0 = Array{Float64, 2}\n    sole1 = Array{Float64, 2}; sole2 = Array{Float64, 2}\n    ####\n    nnmaxVec = zeros(0); npmaxVec = zeros(0); namaxVec = zeros(0)\n    phinmaxVec = zeros(0); phipmaxVec = zeros(0)\n    phiamaxVec = zeros(0); psimaxVec = zeros(0)\n\n    ##### first one\n    G0 = G0Vec[1]\n    println(\"G0 = \", G0)\n\n    coord, sol = main(n = n, Cn = Cn, Cp = Cp, λ = λ, DirichletVal = DirichletVal, G0 = G0, enableIons = enableIons, parameterStudy = true, test = true, verbose = verbose)\n\n    nn = FermiDiracOneHalfTeSCA.(zn * (sol[iphin, :] - sol[ipsi, :]))\n    np = FermiDiracOneHalfTeSCA.(zp * (sol[iphip, :] - sol[ipsi, :]))\n\n    ####\n    nnmax = maximum(abs.(nn))\n    npmax = maximum(abs.(np))\n    phinmax = maximum(abs.(sol[iphin, :]))\n    phipmax = maximum(abs.(sol[iphip, :]))\n    psimax = maximum(abs.(sol[ipsi, :]))\n\n    #####################################\n    push!(nnmaxVec, nnmax)\n    push!(npmaxVec, npmax)\n    push!(phinmaxVec, phinmax)\n    push!(phipmaxVec, phipmax)\n    push!(psimaxVec, psimax)\n\n    if enableIons\n        na = filter(!isnan, Na .* FermiDiracMinusOne.(za * (sol[iphia, :] - sol[ipsi, :])))\n        namax = maximum(abs.(na))\n        phiamax = maximum(abs.(filter(!isnan, sol[iphia, :])))\n\n        push!(namaxVec, namax)\n        push!(phiamaxVec, phiamax)\n    end\n\n    inival = sol\n\n    ######################################\n\n    for G0 in G0Vec[2:end]\n\n        println(\"G0 = \", G0)\n\n        coord, sol = main(n = n, Cn = Cn, Cp = Cp, λ = λ, DirichletVal = DirichletVal, G0 = G0, enableIons = enableIons, parameterStudy = true, parseInival = true, inival = inival, test = true, verbose = verbose)\n\n        nn = FermiDiracOneHalfTeSCA.(zn * (sol[iphin, :] - sol[ipsi, :]))\n        np = FermiDiracOneHalfTeSCA.(zp * (sol[iphip, :] - sol[ipsi, :]))\n\n        ####\n        nnmax = maximum(abs.(nn))\n        npmax = maximum(abs.(np))\n        phinmax = maximum(abs.(sol[iphin, :]))\n        phipmax = maximum(abs.(sol[iphip, :]))\n        psimax = maximum(abs.(sol[ipsi, :]))\n\n        #####################################\n        push!(nnmaxVec, nnmax)\n        push!(npmaxVec, npmax)\n        push!(phinmaxVec, phinmax)\n        push!(phipmaxVec, phipmax)\n        push!(psimaxVec, psimax)\n\n        if enableIons\n            na = filter(!isnan, Na .* FermiDiracMinusOne.(za * (sol[iphia, :] - sol[ipsi, :])))\n            namax = maximum(abs.(na))\n            phiamax = maximum(abs.(filter(!isnan, sol[iphia, :])))\n\n            push!(namaxVec, namax)\n            push!(phiamaxVec, phiamax)\n        end\n\n        inival = sol\n\n        if G0 == 1.0e-1\n            soleM1 = copy(sol)\n        elseif G0 == 1.0e0\n            sole0 = copy(sol)\n        elseif G0 == 1.0e1\n            sole1 = copy(sol)\n        elseif G0 == 1.0e2\n            sole2 = copy(sol)\n        end\n    end\n\n    ###################################\n    if Plotter !== nothing\n        size = 12\n        if enableIons\n            Plotter.loglog(G0Vec, Ca .* ones(length(G0Vec)), color = \"gray\", linestyle = \":\", linewidth = 4, label = \"\\$  M_{\\\\mathrm{a}} \\$ \")\n        end\n        Plotter.loglog(G0Vec, nnmaxVec, marker = \"o\", markersize = size, linewidth = 5, color = \"darkgreen\", label = \"\\$  || n_{\\\\mathrm{n}} ||_{\\\\infty} \\$ \")\n        #####\n        Plotter.loglog(G0Vec, npmaxVec, marker = \"o\", linewidth = 5, linestyle = \"--\", markersize = size, color = \"darkred\", label = \"\\$  || n_{\\\\mathrm{p}} ||_{\\\\infty} \\$ \")\n        if enableIons\n            Plotter.loglog(G0Vec, namaxVec, marker = \"o\", linewidth = 5, markersize = size, color = \"gold\", label = \"\\$  || n_{\\\\mathrm{a}} ||_{\\\\infty} \\$ \")\n        end\n        Plotter.legend(fontsize = 15)\n        Plotter.xlabel(\" \\$ G_0 \\$ \", fontsize = 17)\n        Plotter.ylabel(\"\\$ L^{\\\\infty} \\$ norm\", fontsize = 17)\n        Plotter.title(\"Cn = $Cn; Cp = $Cp; BC = $DirichletVal, \\$ \\\\lambda = \\$ $λ\")\n        Plotter.xlim(7.0e-4, 3.0e3)\n        Plotter.ylim(6.0e-1, 30.0)\n        Plotter.yticks([1.0e0, 1.0e1, 2.0e1])\n        Plotter.tight_layout()\n\n        ###################################\n        Plotter.figure()\n        Plotter.loglog(G0Vec, psimaxVec, marker = \"o\", markersize = size, color = \"darkblue\", linestyle = \":\", linewidth = 5, label = \"\\$  ||\\\\psi||_{\\\\infty} \\$ \")\n        Plotter.loglog(G0Vec, phinmaxVec, marker = \"o\", markersize = size, color = \"darkgreen\", linewidth = 5, label = \"\\$  ||v_{\\\\mathrm{n}}||_{\\\\infty} \\$ \")\n        Plotter.loglog(G0Vec, phipmaxVec, marker = \"o\", markersize = size, linestyle = \"--\", color = \"darkred\", linewidth = 5, label = \"\\$  ||v_{\\\\mathrm{p}}||_{\\\\infty} \\$ \")\n        if enableIons\n            Plotter.loglog(G0Vec, phiamaxVec, marker = \"o\", markersize = size, color = \"gold\", linewidth = 5, label = \"\\$  ||v_{\\\\mathrm{a}}||_{\\\\infty} \\$ \")\n        end\n\n        Plotter.xlim(7.0e-4, 3.0e3)\n        Plotter.ylim(6.0e-1, 30.0)\n        Plotter.yticks([1.0e0, 1.0e1, 2.0e1])\n        Plotter.legend(fontsize = 15)\n        Plotter.xlabel(\" \\$ G_0 \\$ \", fontsize = 17)\n        Plotter.ylabel(\"\\$ L^{\\\\infty} \\$ norm\", fontsize = 17)\n        Plotter.title(\"Cn = $Cn; Cp = $Cp; BC = $DirichletVal, \\$ \\\\lambda = \\$ $λ\")\n        Plotter.tight_layout()\n\n        ###################################\n        Plotter.figure()\n        Blues = Plotter.get_cmap(:Blues)\n        Oranges = Plotter.get_cmap(:Oranges)\n        Greens = Plotter.get_cmap(:Greens)\n        Wistia = Plotter.get_cmap(:Wistia)\n\n        if enableIons\n            Plotter.plot(coord[n:5n]', za .* soleM1[iphia, n:5n], linewidth = 5, color = Wistia(201))\n            Plotter.plot(coord[n:5n]', za .* sole0[iphia, n:5n], linewidth = 5, color = Wistia(171))\n            Plotter.plot(coord[n:5n]', za .* sole1[iphia, n:5n], linewidth = 5, color = Wistia(131))\n            Plotter.plot(coord[n:5n]', za .* sole2[iphia, n:5n], linewidth = 5, color = Wistia(101))\n        end\n\n        Plotter.plot(coord', zn .* soleM1[iphin, :], linewidth = 5, color = Greens(241))\n        Plotter.plot(coord', zn .* sole0[iphin, :], linewidth = 5, color = Greens(201))\n        Plotter.plot(coord', zn .* sole1[iphin, :], linewidth = 5, color = Greens(161))\n        Plotter.plot(coord', zn .* sole2[iphin, :], linewidth = 5, color = Greens(121))\n\n\n        Plotter.xlim(0.0, 7.0)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.ylim(-5.8, 7.5)\n        Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Potential\", fontsize = 17)\n        Plotter.tight_layout()\n\n        ###################################\n        Plotter.figure()\n        Plotter.plot(coord', zp .* soleM1[iphip, :], linewidth = 5, color = Oranges(241))\n        Plotter.plot(coord', zp .* sole0[iphip, :], linewidth = 5, color = Oranges(201))\n        Plotter.plot(coord', zp .* sole1[iphip, :], linewidth = 5, color = Oranges(161))\n        Plotter.plot(coord', zp .* sole2[iphip, :], linewidth = 5, color = Oranges(121))\n        Plotter.xlim(0.0, 7.0)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.ylim(-5.8, 7.5)\n        Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Potential\", fontsize = 17)\n        Plotter.tight_layout()\n\n        ###################################\n        Plotter.figure()\n        Plotter.plot(coord', soleM1[ipsi, :], linewidth = 5, color = Blues(241))\n        Plotter.plot(coord', sole0[ipsi, :], linewidth = 5, color = Blues(201))\n        Plotter.plot(coord', sole1[ipsi, :], linewidth = 5, color = Blues(161))\n        Plotter.plot(coord', sole2[ipsi, :], linewidth = 5, color = Blues(121))\n        Plotter.xlim(0.0, 7.0)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.ylim(-5.8, 7.5)\n        Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Potential\", fontsize = 17)\n        Plotter.tight_layout()\n\n        ###################################\n        nneM1 = FermiDiracOneHalfTeSCA.(zn * (soleM1[iphin, :] - soleM1[ipsi, :]))\n        npeM1 = FermiDiracOneHalfTeSCA.(zp * (soleM1[iphip, :] - soleM1[ipsi, :]))\n\n        nne0 = FermiDiracOneHalfTeSCA.(zn * (sole0[iphin, :] - sole0[ipsi, :]))\n        npe0 = FermiDiracOneHalfTeSCA.(zp * (sole0[iphip, :] - sole0[ipsi, :]))\n\n        nne1 = FermiDiracOneHalfTeSCA.(zn * (sole1[iphin, :] - sole1[ipsi, :]))\n        npe1 = FermiDiracOneHalfTeSCA.(zp * (sole1[iphip, :] - sole1[ipsi, :]))\n\n        nne2 = FermiDiracOneHalfTeSCA.(zn * (sole2[iphin, :] - sole2[ipsi, :]))\n        npe2 = FermiDiracOneHalfTeSCA.(zp * (sole2[iphip, :] - sole2[ipsi, :]))\n\n        if enableIons\n            naeM1 = Na .* FermiDiracMinusOne.(za * (soleM1[iphia, :] - soleM1[ipsi, :]))\n            nae0 = Na .* FermiDiracMinusOne.(za * (sole0[iphia, :] - sole0[ipsi, :]))\n            nae1 = Na .* FermiDiracMinusOne.(za * (sole1[iphia, :] - sole1[ipsi, :]))\n            nae2 = Na .* FermiDiracMinusOne.(za * (sole2[iphia, :] - sole2[ipsi, :]))\n        end\n\n        Plotter.figure()\n        Plotter.semilogy(coord', nneM1, linewidth = 5, color = Greens(241))\n        Plotter.semilogy(coord', nne0, linewidth = 5, color = Greens(201))\n        Plotter.semilogy(coord', nne1, linewidth = 5, color = Greens(161))\n        Plotter.semilogy(coord', nne2, linewidth = 5, color = Greens(121))\n        #################\n        Plotter.semilogy(coord', npeM1, linewidth = 5, color = Oranges(241))\n        Plotter.semilogy(coord', npe0, linewidth = 5, color = Oranges(201))\n        Plotter.semilogy(coord', npe1, linewidth = 5, color = Oranges(161))\n        Plotter.semilogy(coord', npe2, linewidth = 5, color = Oranges(121))\n        ##########\n        Plotter.xlim(0.0, 7.0)\n        Plotter.ylim(3.0e-3, 1.5e1)\n        Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n        Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n        Plotter.ylabel(\"Density\", fontsize = 17)\n        Plotter.tight_layout()\n\n        ###################################\n        if enableIons\n            Plotter.figure()\n            Plotter.semilogy(coord', naeM1, linewidth = 5, color = Wistia(201))\n            Plotter.semilogy(coord', nae0, linewidth = 5, color = Wistia(171))\n            Plotter.semilogy(coord', nae1, linewidth = 5, color = Wistia(131))\n            Plotter.semilogy(coord', nae2, linewidth = 5, color = Wistia(101))\n            Plotter.xlim(0.0, 7.0)\n            Plotter.yticks([1.0e0, 1.0e1])\n            Plotter.xticks([0.0, 1.0, 3.0, 5.0, 7.0])\n            Plotter.axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n            Plotter.axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n            Plotter.axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n            Plotter.xlabel(\"\\$ x \\$\", fontsize = 17)\n            Plotter.ylabel(\"Density\", fontsize = 17)\n            Plotter.tight_layout()\n        end\n\n    end\n\n    return nothing\n\nend\n\nfunction test()\n    testval = 0.9289261210695825\n    return main(test = true) ≈ testval\nend\n\nend # module\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"section"}]
}
