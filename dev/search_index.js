var documenterSearchIndex = {"docs":
[{"location":"GeneralInformation/#generalDescription","page":"Code overview","title":"Code overview","text":"","category":"section"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"The following flow chart explains what needs to be defined when designing new examples. The important information is stored in the Data struct with the most important components listed here.","category":"page"},{"location":"GeneralInformation/","page":"Code overview","title":"Code overview","text":"(Image: Code Structure)","category":"page"},{"location":"module_examples/Ex108_CIGS/#CIGS:-stationary-with-Schottky-contacts.","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"","category":"section"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"(source code)","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"Simulating stationary charge transport for CIGS with mixed Schottky/Ohmic contact conditions. Assume that SRH recombination only happens within a small regime.","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"module Ex108_CIGS\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# function to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_pdoping_left, h_pdoping_trap, h_pdoing_right)\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 2 * refinementfactor))\n    coord_pdoping_left = collect(range(h_ndoping, stop = (h_ndoping + h_pdoping_left), length = 3 * refinementfactor))\n    coord_pdoping_plus = collect(\n        range(\n            (h_ndoping + h_pdoping_left),\n            stop = (h_ndoping + h_pdoping_left + h_pdoping_trap),\n            length = refinementfactor\n        )\n    )\n    coord_pdoping_right = collect(\n        range(\n            (h_ndoping + h_pdoping_left + h_pdoping_trap),\n            stop = (h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right),\n            length = 3 * refinementfactor\n        )\n    )\n    coord = glue(coord_ndoping, coord_pdoping_left)\n    coord = glue(coord, coord_pdoping_plus)\n    coord = glue(coord, coord_pdoping_right)\n\n    return coord\nend","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"function main(; n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false)\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n    (; q, k_B, ε_0, Planck_constant, m_e) = constants\n\n    eV = q * V\n\n    # region numbers\n    regionDonor = 1                           # n doped region\n    regionAcceptorLeft = 2                           # p doped region\n    regionAcceptorTrap = 3                           # p doped region with trap\n    regionAcceptorRight = 4                           # p doped region\n    regions = [regionDonor, regionAcceptorLeft, regionAcceptorTrap, regionAcceptorRight]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor = 1\n    bregionAcceptor = 2\n    bregionDALeft = 3\n    bregionALeftATrap = 4\n    bregionATrapARight = 5\n\n    # grid\n    refinementfactor = 2^(n - 1)\n    h_ndoping = 0.5 * μm\n    h_pdoping_left = 1.0 * μm\n    h_pdoping_trap = 0.1 * μm\n    h_pdoing_right = 1.0 * μm\n    w_device = 0.5 * μm  # width of device\n    z_device = 1.0e-4 * cm  # depth of device\n    h_total = h_ndoping + h_pdoping_left + h_pdoping_trap + h_pdoing_right\n    coord = initialize_pin_grid(\n        refinementfactor,\n        h_ndoping,\n        h_pdoping_left,\n        h_pdoping_trap,\n        h_pdoing_right\n    )\n\n    grid = simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [h_ndoping], regionDonor) # n doped\n    cellmask!(grid, [h_ndoping], [h_ndoping + h_pdoping_left], regionAcceptorLeft) # p doped\n    cellmask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left + h_pdoping_trap], regionAcceptorTrap) # p doped with traps\n    cellmask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_total], regionAcceptorRight) # p doped\n\n    bfacemask!(grid, [h_ndoping], [h_ndoping], bregionDALeft, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left], [h_ndoping + h_pdoping_left], bregionALeftATrap, tol = 1.0e-18)\n    bfacemask!(grid, [h_ndoping + h_pdoping_left + h_pdoping_trap], [h_ndoping + h_pdoping_left + h_pdoping_trap], bregionATrapARight, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    iphin = 1 # index electron quasi Fermi potential\n    iphip = 2 # index hole quasi Fermi potential\n    numberOfCarriers = 2 # electrons and holes\n\n    # physical data\n    T = 300.0 * K\n\n    # band edge energies\n    Ec_ZnO = 3.4 * eV\n    Ev_ZnO = 0.0 * eV\n\n    Ec_CIGS = 3.4 * eV\n    Ev_CIGS = 2.3 * eV\n\n    EC = [Ec_ZnO, Ec_CIGS, Ec_CIGS, Ec_CIGS]\n    EV = [Ev_ZnO, Ev_CIGS, Ev_CIGS, Ev_CIGS]","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"hole trap energy","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"    Et = 2.8 * eV\n\n    # effective densities of states\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n\n    NC = [Nc, Nc, Nc, Nc]\n    NV = [Nv, Nv, Nv, Nv]\n\n    # mobilities\n    mun_ZnO = 100 * (cm^2) / (V * s)\n    mup_ZnO = 25 * (cm^2) / (V * s)\n    mun_CIGS = 100.0 * (cm^2) / (V * s)\n    mup_CIGS = 25 * (cm^2) / (V * s)\n\n    μn = [mun_ZnO, mun_CIGS, mun_CIGS, mun_CIGS]\n    μp = [mup_ZnO, mup_CIGS, mup_CIGS, mup_CIGS]\n\n    # relative dielectric permittivity\n    εr_ZnO = 9 * 1.0\n    εr_CIGS = 13.6 * 1.0\n\n    ε = [εr_ZnO, εr_CIGS, εr_CIGS, εr_CIGS]\n\n    # recombination information parameters\n    ni_ZnO = sqrt(Nc * Nv) * exp(-(Ec_ZnO - Ev_ZnO) / (2 * k_B * T))     # intrinsic concentration\n    n0_ZnO = Nc * Boltzmann((Et - Ec_ZnO) / (k_B * T))                   # Boltzmann equilibrium concentration\n    p0_ZnO = ni_ZnO^2 / n0_ZnO                                           # Boltzmann equilibrium concentration\n    ni_CIGS = sqrt(Nc * Nv) * exp(-(Ec_CIGS - Ev_CIGS) / (2 * k_B * T))  # intrinsic concentration\n    n0_CIGS = Nc * Boltzmann((Et - Ec_CIGS) / (k_B * T))                 # Boltzmann equilibrium concentration\n    p0_CIGS = ni_CIGS^2 / n0_CIGS                                        # Boltzmann equilibrium concentration\n\n    p0 = [p0_ZnO, p0_CIGS, p0_CIGS, p0_CIGS]\n    n0 = [n0_ZnO, n0_CIGS, n0_CIGS, n0_CIGS]","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"set the lifetime value high in all other regions, such that SRH recombination can be neglected there","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"    SRH_LifeTime = [1.0e100, 1.0e100, 1.0e-3 * ns, 1.0e100]\n\n    Auger = 1.0e-29 * cm^6 / s\n    Radiative = 1.0e-10 * cm^3 / s\n\n    # Schottky contact information\n    An = 4 * pi * q * m_e * k_B^2 / Planck_constant^3\n    Ap = 4 * pi * q * m_e * k_B^2 / Planck_constant^3\n    vn = An * T^2 / (q * Nc)\n    vp = Ap * T^2 / (q * Nv)\n    barrier = 0.7 * eV\n\n    # doping information\n    Nd = 1.0e18 / (cm^3)\n    Na = 5.5e15 / (cm^3)\n\n    # we will impose this applied voltage on one boundary\n    voltageAcceptor = 1.0 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # initialize Data instance and fill in data\n    data = Data(grid, numberOfCarriers)\n    data.modelType = Stationary\n    data.F .= FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    data.boundaryType[bregionAcceptor] = SchottkyContact\n    data.boundaryType[bregionDonor] = OhmicContact\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # physical parameters\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions           # interior region data\n\n        params.dielectricConstant[ireg] = ε[ireg] * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = NC[ireg]\n        params.densityOfStates[iphip, ireg] = NV[ireg]\n        params.bandEdgeEnergy[iphin, ireg] = EC[ireg]\n        params.bandEdgeEnergy[iphip, ireg] = EV[ireg]\n        params.mobility[iphin, ireg] = μn[ireg]\n        params.mobility[iphip, ireg] = μp[ireg]\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime[ireg]\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = n0[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = p0[ireg]\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping -- since we do not set any doping for the traps it is automatically zero\n    params.doping[iphin, regionDonor] = Nd\n    params.doping[iphip, regionAcceptorLeft] = Na\n    params.doping[iphip, regionAcceptorTrap] = Na\n    params.doping[iphip, regionAcceptorRight] = Na\n\n    # values for the schottky contacts\n    params.SchottkyBarrier[bregionAcceptor] = barrier\n    params.bVelocity[iphin, bregionAcceptor] = vn\n    params.bVelocity[iphip, bregionAcceptor] = vp\n\n    data.params = params\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.tol_round = 1.0e-7\n    control.damp_initial = 0.5\n    control.damp_growth = 1.2\n    control.maxiters = 30\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # solve thermodynamic equilibrium and update initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        # ##### set legend for plotting routines #####\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Stationary bias loop\")\n    end\n    ################################################################################\n\n    endVoltage = voltageAcceptor       # final bias value\n    biasValues = collect(range(0, stop = endVoltage, length = 52))\n\n    IV = zeros(0)\n    chargeDensities = zeros(0)\n\n    for i in eachindex(biasValues)\n\n        Δu = biasValues[i] # bias\n\n        # Apply new voltage: set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"bias: Δu = $(Δu) V\")\n        end\n\n        # solve time step problems with timestep Δt\n        solution = solve(ctsys, inival = inival, control = control)\n        inival = solution\n\n        # save IV data\n        current = get_current_val(ctsys, solution)\n        push!(IV, w_device * z_device * current)\n\n        # store charge density in donor region (ZnO)\n        push!(chargeDensities, charge_density(ctsys, solution)[regionDonor])\n\n\n    end # bias loop\n\n    # compute static capacitance: check this is correctly computed\n    staticCapacitance = diff(chargeDensities) ./ diff(biasValues)\n\n    # plot solution and IV curve\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage) V\", label_solution)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, IV, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, chargeDensities, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.title(\"Charge density in donor region\")\n        Plotter.ylabel(\"Charge density [C]\")\n        Plotter.tight_layout()\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, staticCapacitance, \"bias \\$\\\\Delta u\\$ = $(biasValues[end]) V\", plotGridpoints = true)\n        Plotter.title(\"Static capacitance in donor region\")\n        Plotter.ylabel(\"Static capacitance [C/V]\")\n        Plotter.tight_layout()\n\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.3561479172035813\n\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module has successfully recompiled.\")\nend\n\n\nend # module","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"","category":"page"},{"location":"module_examples/Ex108_CIGS/","page":"CIGS: stationary with Schottky contacts.","title":"CIGS: stationary with Schottky contacts.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"backgroundinfo/#Mathematical-drift-diffusion-models","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"ChargeTransport.jl aims to discretize charge transport models based on drift-diffusion equations. The bipolar case is sometimes referred to as van Roosbroeck system. This nonlinear system of partial differential equations couples Poisson's equation to several continuity equations. The precise type and amount will vary with the specific application.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"In this section, we would like to describe the mathematical theory a bit more in detail. We denote with alpha the charge carrier, with n_alpha its corresponding density in a device region mathbfOmega during a finite time interval 0 t_F.","category":"page"},{"location":"backgroundinfo/#Poisson's-equation","page":"Mathematical drift-diffusion models","title":"Poisson's equation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation for the electric potential psi is given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n- nabla cdot Bigl(varepsilon_s nabla psi(mathbfx t) Bigr) = q sum_alpha z_alpha Bigl( n_alpha(mathbfx t) - C_alpha(mathbfx) Bigr)\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, varepsilon_s denotes the dielectric permittivity and $ q $ the elementary charge. The right-hand side of Poisson's equation, the space charge density, is the sum of charge carrier densities n_alpha multiplied by their respective charge numbers z_alpha and some corresponding fixed charges, the doping $ C_\\alpha $.","category":"page"},{"location":"backgroundinfo/#Continuity-equations","page":"Mathematical drift-diffusion models","title":"Continuity equations","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Poisson's equation is coupled to additional continuity equations for each charge carrier alpha, which describe the motion of free charge carriers in an electric field","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nz_alpha q partial_t n_alpha +  nablacdot mathbfj_alpha\n\t=\n\tz_alpha q\tr_alpha\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Here, the flux mathbfj_alpha refers to the the carrier's current density and r_alpha to some production/reduction rates. These rates may be chosen to represent different recombination or generation models such as Shockley-Read-Hall, Auger or direct recombination.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"The amount and type of charge carriers will be dependent on the specific application. The standard semiconductor equations use electrons alpha=n and holes alpha=p.","category":"page"},{"location":"backgroundinfo/#Drift-diffusion-fluxes","page":"Mathematical drift-diffusion models","title":"Drift-diffusion fluxes","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Our code uses as independent variables the electrostatic potential psi as well as the quasi Fermi potentials varphi_alpha. The charge carrier densities n_alpha are linked to the corresponding quasi Fermi potentials via the state equations","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\nn_alpha = N_alpha mathcalF_alpha Bigl(eta_alpha(psi varphi_alpha) Bigr) quad eta_alpha = z_alpha fracq (varphi_alpha - psi) + E_alphak_B T\nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"where the physical parameters are defined in the list of notations. With this definition we can formulate the carrier current given by","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"beginaligned\n    mathbfj_alpha\n\t=\n    - (z_alpha)^2 q mu_alpha\n    n_alpha\n    nablavarphi_alpha\n    \nendaligned","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"with the negative gradients of the quasi Fermi potentials as driving forces. Using the state equations one may rewrite these fluxes in a drift-diffusion form.","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"note: Note\nThe unknowns in ChargeTransport.jl are always defined as the quasi Fermi potentials $ \\varphi_\\alpha$ and the electric potential psi.","category":"page"},{"location":"backgroundinfo/#Boundary-conditions","page":"Mathematical drift-diffusion models","title":"Boundary conditions","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"Currently, ohmic contacts, Schottky contacts and Schottky barrier lowering boundary conditions are implemented. For further model information, please look closer to the types, constructors and methods section.","category":"page"},{"location":"backgroundinfo/#Background-literature","page":"Mathematical drift-diffusion models","title":"Background literature","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"For a comprehensive overview of drift-diffusion models, semiconductor applications as well as the underlying numerical methods, we recommend the following sources:","category":"page"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"P. Farrell, D. H. Doan, M. Kantner, J. Fuhrmann, T. Koprucki, and N. Rotundo. “Drift-Diffusion Models”. In: Optoelectronic Device Modeling and Simulation: Fundamentals, Materials, Nanostructures, LEDs, and Amplifiers. CRC Press Taylor & Francis Group, 2017, pp. 733–771.\nS. Selberherr. Analysis and Simulation of Semiconductor Devices. Springer-Verlag, 1984.\nS. M. Sze and K. K. Ng. Physics of Semiconductor Devices. Wiley, 2006.","category":"page"},{"location":"backgroundinfo/#notation","page":"Mathematical drift-diffusion models","title":"Notation","text":"","category":"section"},{"location":"backgroundinfo/","page":"Mathematical drift-diffusion models","title":"Mathematical drift-diffusion models","text":"symbol physical quantity     symbol physical quantity\n$ \\alpha $ mobile charge carrier     $ n_\\alpha $ charge carrier density of $ \\alpha $\nvarepsilon_s dielectric permittivity     $ \\psi $ electrostatic potential\n$ q $ elementary charge     $ C_\\alpha $ doping/background charge\n$ z_\\alpha $ charge number for $ \\alpha $     $ r_\\alpha $ production/reaction rate for $ \\alpha $\n$ N_\\alpha $ effective density of states for $ \\alpha $     $ \\mathcal{F}_\\alpha $ statistics function\n$ \\varphi_\\alpha $ quasi Fermi potential for $ \\alpha $     $ E_\\alpha $ band-edge energy for $ \\alpha $\n$ k_B $ Boltzmann constant     $ T $ temperature\n$ \\mu_\\alpha $ mobility of carrier $ \\alpha $      ","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/#GaAs-diode-with-spatially-varying-doping-(1D).","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"section"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Simulating charge transport in a GaAs pin diode. This means the PDE problem corresponds to the van Roosbroeck system of equations. The simulations are performed out of equilibrium and for the stationary problem. A special feature here is that the doping is node-dependent.","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"module Ex102_PIN_nodal_doping\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"function main(; Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage = :sparse)","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"unit factors and constants","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    @local_unitfactors μm cm s ns V K ps\n    constants = ChargeTransport.constants\n\n    eV = constants.q * V\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    # region numbers\n    regionAcceptor = 1          # p doped region\n    regionIntrinsic = 2          # intrinsic region\n    regionDonor = 3          # n doped region\n    regions = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor = 1\n    bregionDonor = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    h_pdoping = 0.1 * μm\n    h_intrinsic = 0.1 * μm\n    h_ndoping = 0.1 * μm\n    h_total = h_pdoping + h_intrinsic + h_ndoping\n    w_device = 0.1 * μm  # width of device\n    z_device = 1.0e-5 * cm  # depth of device\n\n    coord = range(0.0, stop = h_ndoping + h_intrinsic + h_pdoping, length = 25)\n    coord = collect(coord)\n    grid = simplexgrid(coord)\n    numberOfNodes = length(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor, tol = 1.0e-15)    # p-doped region = 1\n    cellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic, tol = 1.0e-15)    # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor, tol = 1.0e-15)    # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], bregionAcceptor)     # outer left boundary\n    bfacemask!(grid, [h_total], [h_total], bregionDonor)  # outer right boundary\n    bfacemask!(grid, [h_pdoping], [h_pdoping], bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # Define the physical data.\n    Ec = 1.424 * eV\n    Ev = 0.0 * eV\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n    mun = 8500.0 * (cm^2) / (V * s)\n    mup = 400.0 * (cm^2) / (V * s)\n    εr = 12.9 * 1.0              # relative dielectric permittivity of GAs\n    T = 300.0 * K\n\n    # recombination parameters\n    SRH_TrapDensity_n = 4.760185435081902e5 / cm^3\n    SRH_TrapDensity_p = 9.996936448738406e6 / cm^3\n    SRH_LifeTime = 1.0 * ps\n\n    # contact voltage\n    voltageAcceptor = 1.4 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    data = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    # Possible choices for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F .= Boltzmann\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = false,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor] = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ScharfetterGummel\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"Define the Params and ParamsNodal struct.","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions           # region data\n\n        params.dielectricConstant[ireg] = εr * constants.ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = mun\n        params.mobility[iphip, ireg] = mup\n\n        # recombination parameters\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity_n\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity_p\n\n    end\n\n    # initialize the space dependent doping (see FarrellPeschka2019, Computers & Mathematics with Applications, 2019).\n    NDoping = 1.0e17 / cm^3\n    κ = 500.0\n    for icoord in 1:numberOfNodes\n        paramsnodal.doping[icoord] = NDoping * 0.5 * (1.0 + tanh((0.1 - coord[icoord] / μm) * κ) - (1.0 + tanh((coord[icoord] / μm - 0.2) * κ)))\n    end\n\n    data.params = params\n    data.paramsnodal = paramsnodal\n\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    if test == false\n        show_params(ctsys)\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot doping\")\n        ################################################################################\n        Plotter.figure()\n        plot_doping(Plotter, grid, paramsnodal)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if plotting\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 41)\n    IV = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu  = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n        # get IV curve\n        factory = TestFunctionFactory(ctsys)\n\n        # testfunction zero in bregionAcceptor and one in bregionDonor\n        tf = testfunction(factory, [bregionAcceptor], [bregionDonor])\n        I = integrate(ctsys, tf, solution)\n\n        push!(IV, abs.(w_device * z_device * (I[iphin] + I[iphip])))\n\n    end # bias loop\n\n\n    if plotting # plot solution and IV curve\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_energy)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density, plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, IV, \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = 1.4676876548796856\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"","category":"page"},{"location":"module_examples/Ex102_PIN_nodal_doping/","page":"GaAs diode with spatially varying doping (1D).","title":"GaAs diode with spatially varying doping (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"allindex/#Overview-–-Constants,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Overview – Constants, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:constant, :type]","category":"page"},{"location":"allindex/#Methods","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Types, Constructors and Methods","title":"Types, Constructors and Methods","text":"Modules = [ChargeTransport]\nOrder=[:function]","category":"page"},{"location":"allindex/#Description-of-Constant,-Types,-Constructors-and-Methods","page":"Types, Constructors and Methods","title":"Description of Constant, Types, Constructors and Methods","text":"","category":"section"},{"location":"allindex/#Constants,-Types-and-Constructors-2","page":"Types, Constructors and Methods","title":"Constants, Types and Constructors","text":"","category":"section"},{"location":"allindex/#ChargeTransport.BarrierLoweringType","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringType","text":"Possible types for barrier lowering model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.BoundaryModelType","text":"Possible types of boundary models.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.CalculationType","page":"Types, Constructors and Methods","title":"ChargeTransport.CalculationType","text":"Possible types for calculation type.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.FluxApproximationType","page":"Types, Constructors and Methods","title":"ChargeTransport.FluxApproximationType","text":"Possible types of flux discretization schemes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationModelType","text":"Possible types for generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceModelType","text":"Possible Types of interface model (interior boundary conditions).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelType","text":"Possible types for the laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.ModelType","text":"Possible types which indicate, if we consider stationary or transient problem.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContactModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContactModelType","text":"Possible mathematical types of ohmic contact boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OuterBoundaryModelType","page":"Types, Constructors and Methods","title":"ChargeTransport.OuterBoundaryModelType","text":"Possible types of outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.QType","page":"Types, Constructors and Methods","title":"ChargeTransport.QType","text":"Type of charge carriers and the electric potential (corresponding to VoronoiFVM.jl).\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SRHWithoutTrapsType","page":"Types, Constructors and Methods","title":"ChargeTransport.SRHWithoutTrapsType","text":"Possible type for SRH recombination without traps. Here, additional SRH model can be included, possibly also with dynamic traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.StandardFuncSet","page":"Types, Constructors and Methods","title":"ChargeTransport.StandardFuncSet","text":"Type of statistics functions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.constants","page":"Types, Constructors and Methods","title":"ChargeTransport.constants","text":"constants\n\nA globally available object containing the default constants\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.pdelib_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.pdelib_constants","text":"pdelib_constants\n\nconstants with slightly modified values as used in pdelib (https://wias-berlin.de/software/index.jsp?id=pdelib)\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.teSCA_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.teSCA_constants","text":"teSCA_constants\n\nconstants with slightly modified values used in WIAS-TeSCA (https://wias-berlin.de/software/index.jsp?id=TeSCA&lang=0&archive=true)\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.unity_constants","page":"Types, Constructors and Methods","title":"ChargeTransport.unity_constants","text":"unity_constants\n\nunit constants\n\n\n\n\n\n","category":"constant"},{"location":"allindex/#ChargeTransport.BarrierLoweringOff","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOff","text":"abstract type BarrierLoweringOff\n\nAbstract type for the neglection of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BarrierLoweringOn","page":"Types, Constructors and Methods","title":"ChargeTransport.BarrierLoweringOn","text":"abstract type BarrierLoweringOn\n\nAbstract type for the choice of Schottky barrier lowering as boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.BulkRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.BulkRecombination","text":"mutable struct BulkRecombination\n\nA struct holding all necessary information for building bulk recombination. With help of this constructor we can read out the indices the user chooses for electron and hole quasi Fermi potentials.\n\niphin::Int64: Index for FVM construction of electron quasi Fermi potential.\n\niphip::Int64: Index for FVM construction of hole quasi Fermi potential.\n\nbulk_recomb_Auger::Bool: Boolean for present Auger recombination in bulk.\n\nbulk_recomb_radiative::Bool: Boolean for present radiative recombination in bulk.\n\nbulk_recomb_SRH::Union{Type{ChargeTransport.SRHOff}, Type{ChargeTransport.SRHStationary}}: DataType for present SRH recombination in bulk. This needs to be a Type due to cases with or without mobile traps.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Constants","page":"Types, Constructors and Methods","title":"ChargeTransport.Constants","text":"Constants\n\nDefault physical constants (dimensionless) from PhysicalConstants.jl via LessUnitful.jl\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"mutable struct Data{TFuncs<:Function, TVoltageFunc<:Function, TGenerationData<:Union{Array{Float64, 3}, Function, VecOrMat{Float64}}}\n\nA struct holding all data information including model and numerics information, but also all physical parameters for a drift-diffusion simulation of a semiconductor device.\n\nF::Vector{TFuncs} where TFuncs<:Function: An array with the corresponding distribution function mathcalF_alpha for all carriers alpha.\n\nqFModel::Union{Type{ContQF}, Type{DiscontQF}}: A datatype containing the information, whether at least on quasi Fermi potential is assumed to be continuous or discontinuous.\n\nboundaryType::Vector{Union{Type{InterfaceNone}, Type{InterfaceRecombination}, Type{MixedOhmicSchottkyContact}, Type{OhmicContact}, Type{SchottkyBarrierLowering}, Type{SchottkyContact}}}: An array of DataTypes with the type of boundary model for each boundary (interior and exterior).\n\ncontactVoltageFunction::Vector{TVoltageFunc} where TVoltageFunc<:Function: An array containing predefined functions for the applied bias in dependence of time at each outer boundary.\n\nbulkRecombination::BulkRecombination: A struct containing information concerning the bulk recombination model.\n\ngenerationData::Union{Array{Float64, 3}, Function, VecOrMat{Float64}}: A function/array containing the user-specific photogeneration rate. It can be a function which is specified in the user example or an array which is read in and calculated with, e.g., an external software.\n\nlaserModel::Union{Type{LaserModelOff}, Type{LaserModelOn}}: A datatype defining whether the user wants to use the laser model or not.\n\nisContinuous::Vector{Bool}: An array containing information on whether charge carriers are continuous or discontinuous. This is needed for building the AbstractQuantities which handle the indices of charge carriers on different regions.\n\nchargeCarrierList::Vector{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}: This list stores all charge carriers with the correct type needed for VoronoiFVM.\n\nelectricCarrierList::Vector{Int64}: This list stores all electric carrier indices, i.e. the one of electrons and holes.\n\nionicCarrierList::Vector{ChargeTransport.IonicCarrier}: This list contains all defined ionic carriers as a struct of Type IonicCarrier with all needed information on the ionic carriers (can be either ions or ion vacancies).\n\nindex_psi::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}: This variable stores the index of the electric potential. Based on the user choice we have with this new type the opportunity to simulate discontinuous unknowns.\n\nbarrierLoweringInfo::ChargeTransport.BarrierLoweringSpecies: This is a struct containing all information necessary to simulate Schottky Barrier Lowering.\n\nfluxApproximation::Vector{Union{Type{DiffusionEnhanced}, Type{DiffusionEnhancedModifiedDrift}, Type{ExcessChemicalPotential}, Type{ExcessChemicalPotentialGraded}, Type{GeneralizedSG}, Type{ScharfetterGummel}, Type{ScharfetterGummelGraded}}}: A DataType for the flux discretization method.\n\ncalculationType::Union{Type{InEquilibrium}, Type{OutOfEquilibrium}}: A DataType for equilibrium or out of equilibrium calculations.\n\nmodelType::Union{Type{Stationary}, Type{Transient}}: A DataType for transient or stationary calculations.\n\ngenerationModel::Union{Type{GenerationBeerLambert}, Type{GenerationNone}, Type{GenerationUniform}, Type{GenerationUserDefined}}: A DataType for for generation model.\n\nλ1::Float64: An embedding parameter used to solve the nonlinear Poisson problem, where for λ1 = 0 the right hand-side is set to zero whereas for for λ1 = 1 we have a full space charge density.\n\nλ2::Float64: An embedding parameter for the generation rate.\n\nλ3::Float64: An embedding parameter for an electrochemical reaction.\n\nohmicContactModel::Union{Type{OhmicContactDirichlet}, Type{OhmicContactRobin}}: Possibility to change the implementation of the ohmic contact boundary model for the electric potential (Dirichlet or Robin)\n\ntempBEE1::Vector{Float64}: Within this template, information concerning the band-edge energy of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempBEE2::Vector{Float64}: See the description of tempBEE1.\n\ntempDOS1::Vector{Float64}: Within this template, information concerning the effective DOS of each carrier is stored locally which saves allocations. We have two of such templates due to the two point flux approximation schemes.\n\ntempDOS2::Vector{Float64}: See the description of tempDOS2.\n\nparams::Params: A struct holding all region dependent parameter information. For more information see struct Params.\n\nparamsnodal::ParamsNodal: A struct holding all space dependent parameter information. For more information see struct ParamsNodal.\n\nparamsoptical::ParamsOptical: A struct holding the physical parameters for the Helmholtz equation simulation in a laser.\n\nconstants::ChargeTransport.Constants: A struct holding the dimensionless physical constants used for the simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Data-Union{Tuple{TFuncs}, Tuple{Any, Any}} where TFuncs","page":"Types, Constructors and Methods","title":"ChargeTransport.Data","text":"Data(\n    grid,\n    numberOfCarriers;\n    constants,\n    contactVoltageFunction,\n    generationData,\n    statfunctions,\n    numberOfEigenvalues\n) -> Data{StandardFuncSet, T, Vector{Float64}} where T<:Function\n\n\nSimplified constructor for Data which only takes the grid and the numberOfCarriers as argument. Here, all necessary information including the physical parameters, but also some numerical information are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.DiffusionEnhanced","page":"Types, Constructors and Methods","title":"ChargeTransport.DiffusionEnhanced","text":"abstract type DiffusionEnhanced\n\nAbstract type for diffusion enhanced flux discretization, check M. Bessemoulin-Chatard, “A finite volume scheme for convection–diffusion equations with nonlinear diffusion derived from the Scharfetter–Gummel scheme”, Numerische Mathematik, vol. 121, pp. 637–670, 2012.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotential","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotential","text":"abstract type ExcessChemicalPotential\n\nAbstract type for excess chemical potential flux discretization, check  Z. Yu, and R. Dutton, “SEDAN III – A one-dimensional device simulator”, http://www-tcad.stanford.edu/tcad/programs/sedan3.html, 1988.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ExcessChemicalPotentialGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ExcessChemicalPotentialGraded","text":"abstract type ExcessChemicalPotentialGraded\n\nAbstract type for excess chemical potential flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GeneralizedSG","page":"Types, Constructors and Methods","title":"ChargeTransport.GeneralizedSG","text":"abstract type GeneralizedSG\n\nAbstract type for generalized Scharfetter-Gummel flux discretization. This flux approximation results in an implicit equation which needs to be solved and is exact for all Blakemore type statistics functions with abritary γ, check T. Koprucki and K. Gärtner. “Discretization scheme for drift-diffusion equations with strong diffusion enhancement”. In: 12th International Conference on Numerical Simulation of Optoelectronic Devices (NUSOD). 2012, pp. 103–104.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationBeerLambert","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationBeerLambert","text":"abstract type GenerationBeerLambert\n\nAbstract type for Beer-Lambert generation. Note that this type is implemented, but not well tested yet.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationNone","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationNone","text":"abstract type GenerationNone\n\nAbstract type for no generation model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUniform","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUniform","text":"abstract type GenerationUniform\n\nAbstract type for uniform generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.GenerationUserDefined","page":"Types, Constructors and Methods","title":"ChargeTransport.GenerationUserDefined","text":"abstract type GenerationUserDefined\n\nAbstract type for user defined generation.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.InEquilibrium","text":"abstract type InEquilibrium\n\nAbstract type for equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceNone","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceNone","text":"abstract type InterfaceNone\n\nAbstract type for no interface model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.InterfaceRecombination","page":"Types, Constructors and Methods","title":"ChargeTransport.InterfaceRecombination","text":"abstract type InterfaceRecombination\n\nAbstract type for surface recombination mechanisms.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelOff","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelOff","text":"abstract type LaserModelOff\n\nAbstract type for no laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.LaserModelOn","page":"Types, Constructors and Methods","title":"ChargeTransport.LaserModelOn","text":"abstract type LaserModelOn\n\nAbstract type for usage of laser model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.MixedOhmicSchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.MixedOhmicSchottkyContact","text":"Abstract type for a mixed Ohmic and Schottky boundary model, resulting in all Dirichlet type conditions for electrons, holes and the electric potential.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OhmicContact","page":"Types, Constructors and Methods","title":"ChargeTransport.OhmicContact","text":"Abstract type for ohmic contacts as outer boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.OutOfEquilibrium","page":"Types, Constructors and Methods","title":"ChargeTransport.OutOfEquilibrium","text":"abstract type OutOfEquilibrium\n\nAbstract type for out of equilibrium calculations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"mutable struct Params\n\nA struct holding the physical region dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\nnumberOfRegions::Int64: Number of subregions mathbfOmega_k within the domain mathbfOmega.\n\nnumberOfBoundaryRegions::Int64: Number of boundary regions (partial mathbfOmega)_k such that partial mathbfOmega = cup_k (partial mathbfOmega)_k. Note that here are inner and outer boundaries calculated.\n\nnumberOfCarriers::Int64: Number of moving charge carriers.\n\ninvertedIllumination::Int64: Parameter for the direction of illumination. If illumination is coming from the left, then set this value to 1. Otherwise, if the illumination comes from the right, set this value to -1.\n\ntemperature::Float64: A given constant temperature.\n\nγ::Float64: The parameter of the Blakemore statistics (needed for the generalizedSG flux).\n\nr0::Float64: Prefactor of electro-chemical reaction of internal boundary conditions.\n\nprefactor_SRH::Float64: Prefactor for stationary SRH recombination.\n\ngenerationPeak::Float64: Parameter for the shift of generation peak of the Beer-Lambert generation profile.\n\nSchottkyBarrier::Vector{Float64}: An array for the given Schottky barriers at present Schottky contacts.\n\ncontactVoltage::Vector{Float64}: An array containing a constant value for the applied voltage.\n\nbψEQ::Vector{Float64}: An array containing a constant value for the electric potential in case of Dirichlet boundary conditions.\n\nchargeNumbers::Vector{Float64}: An array with the corresponding charge numbers z_alpha for all carriers alpha.\n\nbBandEdgeEnergy::Matrix{Float64}: An array with the corresponding boundary band-edge energy values E_alpha in each region for each carrier alpha.\n\nbDensityOfStates::Matrix{Float64}: An array with the corresponding boundary effective density of states values N_alpha for each carrier alpha.\n\nbMobility::Matrix{Float64}: A 2D array with the corresponding boundary mobility values mu_alpha in each boundary region for each carrier alpha.\n\nbDoping::Matrix{Float64}: A 2D array with the corresponding boundary doping values for each carrier alpha.\n\nbVelocity::Matrix{Float64}: A 2D array with the corresponding boundary velocity values for each carrier alpha, when assuming Schottky contacts.\n\nbReactionCoefficient::Matrix{Float64}: An array to define the reaction coefficient at internal boundaries.\n\nrecombinationSRHvelocity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary velocity values for electrons and holes.\n\nbRecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding recombination surface boundary density values for electrons and holes.\n\nbRecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding recombination surface recombination velocities.\n\nbDensityEQ::Matrix{Float64}: A 2D array containing the equilibrium density of electric charge carriers at the boundary.\n\ndoping::Matrix{Float64}: A 2D array with the corresponding doping values for each carrier alpha on each region.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each region.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each region.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each region.\n\nrecombinationSRHLifetime::Matrix{Float64}: A 2D array with the corresponding SRH lifetimes tau_n tau_p for electrons and holes.\n\nrecombinationSRHTrapDensity::Matrix{Float64}: A 2D array with the corresponding time-independent SRH trap densities n_tau p_tau for electrons and holes.\n\nrecombinationAuger::Matrix{Float64}: A 2D array with the corresponding Auger coefficients for electrons and holes.\n\ndielectricConstant::Vector{Float64}: A region dependent dielectric constant.\n\ndielectricConstantImageForce::Vector{Float64}: A region dependent image force dielectric constant.\n\ngenerationIncidentPhotonFlux::Vector{Float64}: A region dependent array for the prefactor in the generation process which is the incident photon flux.\n\ngenerationUniform::Vector{Float64}: A region dependent array for an uniform generation rate.\n\ngenerationAbsorption::Vector{Float64}: A region dependent array for the absorption coefficient in the generation process.\n\nrecombinationRadiative::Vector{Float64}: A region dependent array for the radiative recombination rate.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Params-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(\n    numberOfRegions,\n    numberOfBoundaryRegions,\n    numberOfCarriers\n) -> Params\n\n\nSimplified constructor for Params which only takes the numberOfRegions, numberOfBoundaryRegions and numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{ExtendableGrids.ExtendableGrid, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(\n    grid::ExtendableGrids.ExtendableGrid,\n    numberOfCarriers\n) -> Params\n\n\nDeprecated!\n\nSimplified constructor for Params which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_Laser_simple}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_Laser_simple\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_PSC_PCBM_MAPI_Pedot}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_PSC_PCBM_MAPI_Pedot\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Params-Tuple{Params_PSC_TiO2_MAPI_spiro}","page":"Types, Constructors and Methods","title":"ChargeTransport.Params","text":"Params(p)\n\n\nCreate a ChargeTransport.Params object directly from Params_PSC_TiO2_MAPI_spiro\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsNodal","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"mutable struct ParamsNodal\n\nA struct holding the physical nodal, i.e. space-dependent parameters for a drift-diffusion simulation of a semiconductor device.\n\ndielectricConstant::Vector{Float64}: A node dependent dielectric constant.\n\ndoping::Vector{Float64}: A 1D array with the corresponding doping values on each node.\n\nmobility::Matrix{Float64}: A 2D array with the corresponding mobility values mu_alpha for each carrier alpha on each node.\n\ndensityOfStates::Matrix{Float64}: A 2D array with the corresponding effective density of states values N_alpha for each carrier alpha on each node.\n\nbandEdgeEnergy::Matrix{Float64}: A 2D array with the corresponding band-edge energy values E_alpha for each carrier alpha on each node.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsNodal-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsNodal","text":"ParamsNodal(grid, numberOfCarriers) -> ParamsNodal\n\n\nSimplified constructor for ParamsNodal which only takes the grid and the numberOfCarriers as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ParamsOptical","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsOptical","text":"mutable struct ParamsOptical\n\nA struct holding the physical parameters for the Helmholtz equation simulation in a laser.\n\nlaserWavelength::Float64: The wavelength for the laser on hand.\n\npower::Float64: The laser power.\n\nabsorption_0::Vector{Float64}: A region dependent array for the absorption coefficient in the absorption function in the medium.\n\ngain_0::Vector{Float64}: A region dependent array for the gain model coefficient.\n\nrefractiveIndex_0::Vector{Float64}: A region dependent array for the refractive index coefficient.\n\nrefractiveIndex_d::Vector{Float64}: A region dependent array for the second refractive index coefficient.\n\nrefractiveIndex_γ::Vector{Float64}: A region dependent array for the refractive index exponent.\n\neigenvalues::Vector{ComplexF64}: An array of the eigenvalues.\n\nabsorptionFreeCarriers::Matrix{Float64}: A 2D array with the corresponding free carrier absorption values.\n\neigenvectors::Matrix{ComplexF64}: A 2D array with the corresponding eigenvector for eah eigenvalue.\n\noldSolution::Matrix{Float64}: A 2D array with the calculated solutions varphi_n, varphi_p andpsi in all the nodes.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ParamsOptical-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.ParamsOptical","text":"ParamsOptical(\n    grid,\n    numberOfCarriers,\n    numberOfEigenvalues\n) -> ParamsOptical\n\n\nSimplified constructor for ParamsOptical which only takes the grid, numberOfCarriers and numberOfEigenvalues as argument.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.ScharfetterGummel","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummel","text":"abstract type ScharfetterGummel\n\nAbstract type for Scharfetter-Gummel flux discretization. Choose this one, when the Boltzmann statistics function is chosen as statistics, check D. Scharfetter and H. Gummel, “Large-signal analysis of a silicon Read diode oscillator”, IEEE Trans. Electr. Dev., vol. 16, pp. 64–77, 1969.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.ScharfetterGummelGraded","page":"Types, Constructors and Methods","title":"ChargeTransport.ScharfetterGummelGraded","text":"abstract type ScharfetterGummelGraded\n\nAbstract type for Scharfetter-Gummel flux discretization for graded effective density of states and/or graded band-edge energies. This means, use this flux when at least one of these parameters is assumed to be space-dependent.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.SchottkyContact","page":"Types, Constructors and Methods","title":"ChargeTransport.SchottkyContact","text":"Abstract type for schottky contacts as boundary model.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.Stationary","page":"Types, Constructors and Methods","title":"ChargeTransport.Stationary","text":"abstract type Stationary\n\nAbstract type for stationary simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"mutable struct System\n\nA struct holding all information necessary for a drift-diffusion type system.\n\ndata::Data: A struct holding all data information, see Data\n\nfvmsys::VoronoiFVM.AbstractSystem: A struct holding system information for the finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#ChargeTransport.System-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.System","text":"System(grid, data; kwargs...)\n\n\nSystem constructor which builds all necessary information needed based on the input parameters with special regard to the quasi Fermi potential model. This is the main struct in which all information on the input data, but also on the solving system, are stored.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Transient","page":"Types, Constructors and Methods","title":"ChargeTransport.Transient","text":"abstract type Transient\n\nAbstract type for transient simulations.\n\n\n\n\n\n","category":"type"},{"location":"allindex/#Methods-2","page":"Types, Constructors and Methods","title":"Methods","text":"","category":"section"},{"location":"allindex/#ChargeTransport.Blakemore-Tuple{Real, Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Blakemore","text":"Blakemore(x::Real, γ::Real) -> Any\n\n\nThe Blakemore approximation 1(exp(-x) + γ) with variable real scalar γ, see J. S. Blakemore. “The Parameters of Partially Degenerate Semiconductors”. In: Proceedings of the Physical Society. Section A 65 (1952), pp. 460–461.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.Boltzmann-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.Boltzmann","text":"Boltzmann(x::Real) -> Any\n\n\nThe Boltzmann statistics function exp(x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracMinusOne-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracMinusOne","text":"FermiDiracMinusOne(x::Real) -> Any\n\n\nThe Fermi-Dirac integral of order -1 which reads 1(exp(-x) + 1), see J.S. Blakemore, Approximations for Fermi-Dirac integrals, especially the function F_12 (eta) used to describe electron density in a semiconductor, Solid-State Electronics 25 (11) (1982) 1067 – 1076.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfBednarczyk-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfBednarczyk","text":"FermiDiracOneHalfBednarczyk(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to [Bednarczyk1978, \"The Approximation of the Fermi-Dirac integral F_12(eta)\"].\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.FermiDiracOneHalfTeSCA-Tuple{Real}","page":"Types, Constructors and Methods","title":"ChargeTransport.FermiDiracOneHalfTeSCA","text":"FermiDiracOneHalfTeSCA(x::Real) -> Any\n\n\nThe incomplete Fermi-Dirac integral of order 1/2, implemented according to the software package TeSCA, see https://wias-berlin.de/software/index.jsp?lang=1&id=TeSCA.\n\nModified to use log1p(x)=log(1+x).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSContinuityEquations!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSContinuityEquations!","text":"RHSContinuityEquations!(f, u, node, data)\n\n\nFunction which builds right-hand side of electric charge carriers.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.RHSPoisson!-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.RHSPoisson!","text":"RHSPoisson!(f, u, node, data, ipsi)\n\n\nFunction which builds right-hand side of Poisson equation, i.e. which builds the space charge density.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bflux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bflux!","text":"bflux!(f, u, bedge, data)\n\n\nMaster bflux! function. This is the function which enters VoronoiFVM and hands over for each boundary the flux within the boundary.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data) -> Any\n\n\nMaster breaction! function. This is the function which enters VoronoiFVM and hands over for each boundary the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactDirichlet}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(\n    f,\n    u,\n    bnode,\n    data,\n    _::Type{OhmicContactDirichlet}\n)\n\n\nCreates ohmic boundary conditions via Dirichlet BC for the electrostatic potential psi\n\npsi  = psi_0 + U,\n\nwhere psi_0 contains some given value and U is an applied voltage.\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for electrons and holes are dirichlet conditions, where\n\nvarphi_alpha = U`\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{OhmicContactRobin}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(f, u, bnode, data, _::Type{OhmicContactRobin})\n\n\nCreates ohmic boundary conditions via a penalty approach with penalty parameter delta. For example, the right-hand side for the electrostatic potential psi is implemented as\n\nfpsi  = -qdelta   ( (p - N_a) - (n - N_d) ),\n\nassuming a bipolar semiconductor. In general, we have for some given charge number z_alpha\n\nfpsi =  -qdelta  sum_alpha z_alpha  (n_alpha - C_alpha) \n\nwhere C_alpha corresponds to some doping w.r.t. the species alpha.\n\nThe boundary conditions for electrons and holes are dirichlet conditions, where\n\nvarphi_alpha = U`\n\nwith U as an applied voltage.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.breaction!-Tuple{Any, Any, Any, Any, Type{SchottkyBarrierLowering}}","page":"Types, Constructors and Methods","title":"ChargeTransport.breaction!","text":"breaction!(\n    f,\n    u,\n    bnode,\n    data,\n    _::Type{SchottkyBarrierLowering}\n)\n\n\nCreates Schottky boundary conditions with additional lowering which are modelled as\n\npsi = - phi_Sq  + sqrt -frac q  nabla_boldsymbolnu psi_mathrmR4pi varepsilon_mathrmi + U,\n\nwhere psi_mathrmR denotes the electric potential with standard Schottky contacts and the same space charge density as psi and where varepsilon_mathrmi corresponds to the image force dielectric constant.\n\nTo solve for this additional boundary conditions the projected gradient nabla_boldsymbolnu psi_mathrmR is stored within a boundary species and calculated in the method generic_operator!().\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.bstorage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.bstorage!","text":"bstorage!(f, u, bnode, data) -> Any\n\n\nMaster bstorage! function. This is the function which enters VoronoiFVM and hands over for each boundary the time-dependent part of the chosen boundary model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Type{ContQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    ::Type{ContQF};\n    kwargs...\n) -> System\n\n\nThe core of the system constructor. Here, the system for continuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.build_system-Tuple{Any, Any, Type{DiscontQF}}","page":"Types, Constructors and Methods","title":"ChargeTransport.build_system","text":"build_system(\n    grid,\n    data,\n    ::Type{DiscontQF};\n    kwargs...\n) -> System\n\n\nThe core of the system constructor. Here, the system for discontinuous quasi Fermi potentials is build.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-NTuple{8, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(\n    psi0,\n    phi,\n    temperature,\n    EVector,\n    chargeNumbers,\n    dopingVector,\n    dosVector,\n    FVector\n)\n\n\nCompute the charge density, i.e. the right-hand side of Poisson's equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.charge_density-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.charge_density","text":"charge_density(ctsys, sol) -> Any\n\n\nCompute the charge density for each region separately.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.degenerateLimit-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.degenerateLimit","text":"degenerateLimit(x) -> Any\n\n\nDegenerate limit of incomplete Fermi-Dirac integral of order 1/2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.electroNeutralSolution-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.electroNeutralSolution","text":"electroNeutralSolution(ctsys) -> Any\n\n\nCompute the electro-neutral solution for the Boltzmann approximation. It is obtained by setting the left-hand side in the Poisson equation equal to zero and solving for psi. The charge carriers may obey different statistics functions. Currently, this one is not well tested for the case of charge carriers beyond electrons and holes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.enable_ionic_carrier!-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.enable_ionic_carrier!","text":"enable_ionic_carrier!(data; ionicCarrier, regions)\n\n\nThis method takes the user information concerning present ionic charge carriers, builds a struct of Type IonicCarrier and add this struct to the ionicCarrierList.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nThe argument of the statistics function for boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction!","text":"etaFunction!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nThe argument of the statistics function for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-NTuple{6, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(psi, phi, temperature, E, z, constants) -> Any\n\n\nThe argument of the statistics function for given varphi_alpha and psi\n\nz_alpha  (k_B  T)   ( (varphi_alpha - psi) * q + E_alpha )\n\nThe parameters E_alpha and z_alpha are given as vectors. This function may be used to compute the charge density, i.e. the right-hand side of the Poisson equation.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.etaFunction-Tuple{Any, Int64, Any, Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.etaFunction","text":"etaFunction(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}\n) -> Any\n\n\nThe argument of the statistics function for a given solution on a given interior region.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.flux!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.flux!","text":"flux!(f, u, edge, data)\n\n\nMaster flux functions which enters VoronoiFVM. Flux discretization scheme is chosen in two steps. First, we need to see, if we are in or out of equilibrium. If, InEquilibrium, then no flux is passed. If outOfEquilibrium, we choose the flux approximation which the user chose for each charge carrier. For the displacement flux we use a finite difference approach.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.generic_operator!-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.generic_operator!","text":"generic_operator!(f, u, fvmsys)\n\n\nGeneric operator to save the projected gradient of electric potential (for system with standard Schottky contacts). Note that this currently only working in one dimension!\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_BEE!-Tuple{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_BEE!","text":"get_BEE!(\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n) -> Any\n\n\nDefining locally the band-edge energy for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_DOS!-Tuple{Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}, VoronoiFVM.Node, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_DOS!","text":"get_DOS!(\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}},\n    node::VoronoiFVM.Node,\n    data\n)\n\n\nDefining locally the effective DOS for interior nodes (analogously for boundary nodes and edges).\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for time dependent problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_current_val-Tuple{Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_current_val","text":"Calculates current for stationary problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.BNode, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, bnode::VoronoiFVM.BNode, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Edge, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(\n    u,\n    edge::VoronoiFVM.Edge,\n    data,\n    icc\n) -> Tuple{Any, Any}\n\n\nFor given potentials, compute corresponding densities for edges.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density!-Tuple{Any, VoronoiFVM.Node, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density!","text":"get_density!(u, node::VoronoiFVM.Node, data, icc) -> Any\n\n\nFor given potentials, compute corresponding densities for interior nodes.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(sol, data, icc, ireg; inode) -> Any\n\n\nThe densities for given potentials  varphi_alpha and psi\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.get_density-Tuple{Any, Int64, Any, Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}}","page":"Types, Constructors and Methods","title":"ChargeTransport.get_density","text":"get_density(\n    sol,\n    ireg::Int64,\n    ctsys,\n    icc::Union{Int64, ContinuousQuantity{Int32}, DiscontinuousQuantity{Int32}, InterfaceQuantity{Int32}}\n) -> Any\n\n\nFor given potentials, compute corresponding densities for given interior region corresponding to a homogeneous set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDiffusionEnhancements-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDiffusionEnhancements","text":"plotDiffusionEnhancements(; Plotter)\n\n\nPlot diffusion enhancements.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plotDistributions-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.plotDistributions","text":"plotDistributions(; Plotter)\n\n\nPlot different distribution integrals.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_IV-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_IV","text":"plot_IV(\n    Plotter,\n    biasValues,\n    IV,\n    title;\n    plotGridpoints\n) -> Any\n\n\nMethod for showing the total current. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_densities-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_densities","text":"plot_densities(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_density;\n    plotGridpoints\n) -> Any\n\n\nPlotting routine, where the charge carrier densities are depicted in dependence of space. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"plot_doping(Plotter, ctsys, label_density) -> Any\n\n\nPossibility to plot the considered doping. This is especially useful for making sure that the interior and the boundary doping agree.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_doping-Tuple{Any, ExtendableGrids.ExtendableGrid, ParamsNodal}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_doping","text":"Plot doping for nodal dependent doping.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_electroNeutralSolutionBoltzmann-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_electroNeutralSolutionBoltzmann","text":"plot_electroNeutralSolutionBoltzmann(\n    Plotter,\n    grid,\n    psi0;\n    plotGridpoints\n) -> Any\n\n\nPlotting routine for depicting the electroneutral potential. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_energy;\n    plotGridpoints\n) -> Any\n\n\nWith this method it is possible to plot the energies\n\nE_alpha - q psi quad textwrt space\n\nThe case of heterojunctions is tested, but yet multidimensional plottings are not included.\n\nOne input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_energies-Tuple{Any, Any, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_energies","text":"plot_energies(Plotter, ctsys, label_BEE)\n\n\nWith this method it is possible to depict the band-edge energies E_alpha. This can be useful for debugging when dealing with heterojunctions.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.plot_solution-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.plot_solution","text":"plot_solution(\n    Plotter,\n    ctsys,\n    solution,\n    title,\n    label_solution;\n    plotGridpoints\n) -> Any\n\n\nMethod for plotting the solution vectors: the electrostatic potential psi as well as the charge carriers. The case of heterojunctions is tested, but yet multidimensional plottings are not included. One input parameter is the boolean plotGridpoints which makes it possible to plot markers, which indicate where the nodes are located.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data)\n\n\nMaster reaction! function. This is the function which enters VoronoiFVM and hands over reaction terms for concrete calculation type and bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{InEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{InEquilibrium})\n\n\nReaction in case of equilibrium, i.e. no generation and recombination is considered.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.reaction!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.reaction!","text":"reaction!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nSets up the right-hand sides. Assuming a bipolar semiconductor the right-hand side for the electrostatic potential becomes   fψ  = - q ((p - N_a) - (n - N_d) ) = - q  sum  n_alpha  (n_alpha - C_alpha) for some doping C_alpha w.r.t. to the species alpha. The right-hand sides for the charge carriers read as fn_alpha =  - z_alpha  q (G -  R) for all charge carriers n_alpha. The recombination includes radiative, Auger and Shockley-Read-Hall recombination. For latter recombination process the stationary simplification is implemented. The recombination is only implemented for electron and holes and assumes that the electron index is 1 and the hole index is 2.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_bulk_recombination-Tuple{}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_bulk_recombination","text":"set_bulk_recombination(\n;\n    iphin,\n    iphip,\n    bulk_recomb_Auger,\n    bulk_recomb_radiative,\n    bulk_recomb_SRH\n)\n\n\nCorresponding constructor for the bulk recombination model.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.set_plotting_labels-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.set_plotting_labels","text":"set_plotting_labels(\n    data\n) -> Tuple{Any, Any, Matrix{String}, Any}\n\n\nMethod which can be used to construct the arrays parsed to the plotting routines for labeling. The description for electrons and holes are predefined. If one wishes to extend by labels for, e.g. mobile ionic carriers or traps, this can be done within the main file.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-NTuple{4, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data) -> Any\n\n\nMaster storage! function. This is the function which enters VoronoiFVM and hands over a storage term, if we consider transient problem.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.storage!-Tuple{Any, Any, Any, Any, Type{OutOfEquilibrium}}","page":"Types, Constructors and Methods","title":"ChargeTransport.storage!","text":"storage!(f, u, node, data, _::Type{OutOfEquilibrium})\n\n\nThe storage term for time-dependent problems. Currently, for the time-dependent current densities the implicit Euler scheme is used. Hence, we have fn_alpha =  z_alpha  q _t n_alpha and for the electrostatic potential fψ = 0.\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.trap_density-NTuple{5, Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.trap_density","text":"trap_density(icc, ireg, params, Et, constants)\n\n\nCompute trap densities for a given trap energy. [Currently, only done for the Boltzmann statistics and for region dependent parameters.]\n\n\n\n\n\n","category":"method"},{"location":"allindex/#ChargeTransport.zeroVoltage-Tuple{Any}","page":"Types, Constructors and Methods","title":"ChargeTransport.zeroVoltage","text":"Function in case of an applied voltage equal to zero at one boundary.\n\n\n\n\n\n","category":"method"},{"location":"module_examples/Ex101_PIN/#GaAs-diode-(1D).","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"section"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We simulate charge transport in a GaAs pin diode, where we use the van Roosbroeck system of equations as charge transport model. The unknowns are given by the quasi Fermi potentials of electrons and holes varphi_n, varphi_p and the electric potential psi. The simulations are performed out of equilibrium and for the stationary problem.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"module Ex101_PIN\n\nusing ChargeTransport  # drift-diffusion solver\nusing ExtendableGrids  # grid initializer\nusing PyPlot           # solution visualizer\n\n# This function is used to initialize the grid for a possible extension to other p-i-n devices.\nfunction initialize_pin_grid(refinementfactor, h_ndoping, h_intrinsic, h_pdoping)\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 3 * refinementfactor))\n    coord_intrinsic = collect(range(h_ndoping, stop = (h_ndoping + h_intrinsic), length = 3 * refinementfactor))\n    coord_pdoping = collect(range((h_ndoping + h_intrinsic), stop = (h_ndoping + h_intrinsic + h_pdoping), length = 3 * refinementfactor))\n    coord = glue(coord_ndoping, coord_intrinsic)\n    coord = glue(coord, coord_pdoping)\n\n    return coord\nend","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"function main(; n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage = :sparse)\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"unit factors","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    @local_unitfactors μm cm s ns V K","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"constants","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    constants = ChargeTransport.constants\n    (; q, k_B, ε_0) = constants\n\n    eV = q * V\n\n\n    # region numbers\n    regionAcceptor = 1          # p doped region\n    regionIntrinsic = 2          # intrinsic region\n    regionDonor = 3          # n doped region\n    regions = [regionAcceptor, regionIntrinsic, regionDonor]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    # Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n    # adding additional interior boundaries, continue with 3, 4, ...\n    bregionAcceptor = 1\n    bregionDonor = 2\n    bregionJunction1 = 3\n    bregionJunction2 = 4\n\n    # grid\n    refinementfactor = 2^(n - 1)\n    h_pdoping = 2.0 * μm\n    h_intrinsic = 2.0 * μm\n    h_ndoping = 2.0 * μm\n    h_total = h_pdoping + h_intrinsic + h_ndoping\n    w_device = 0.5 * μm  # width of device\n    z_device = 1.0e-4 * cm  # depth of device\n    coord = initialize_pin_grid(\n        refinementfactor,\n        h_pdoping,\n        h_intrinsic,\n        h_ndoping\n    )\n\n    grid = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0 * μm], [h_pdoping], regionAcceptor)  # p-doped region = 1\n    cellmask!(grid, [h_pdoping], [h_pdoping + h_intrinsic], regionIntrinsic) # intrinsic region = 2\n    cellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n    # bfacemask! for setting different boundary regions. At exterior boundaries they are\n    # automatically set by ExtendableGridsjl. Thus, there the following two lines are actually\n    # unneccesarry, but are only written for completeness.\n    bfacemask!(grid, [0.0], [0.0], bregionAcceptor)     # outer left boundary\n    bfacemask!(grid, [h_total], [h_total], bregionDonor)  # outer right boundary\n    bfacemask!(grid, [h_pdoping], [h_pdoping], bregionJunction1) # first  inner interface\n    bfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    numberOfCarriers = 2","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We define the physical data.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    Ec = 1.424 * eV\n    Ev = 0.0 * eV\n    Nc = 4.35195989587969e17 / (cm^3)\n    Nv = 9.139615903601645e18 / (cm^3)\n    mun = 8500.0 * (cm^2) / (V * s)\n    mup = 400.0 * (cm^2) / (V * s)\n    εr = 12.9 * 1.0              # relative dielectric permittivity of GAs\n    T = 300.0 * K\n\n    # recombination parameters\n    Auger = 1.0e-29 * cm^6 / s\n    SRH_TrapDensity = 1.0e10 / cm^3\n    SRH_LifeTime = 1.0 * ns\n    Radiative = 1.0e-10 * cm^3 / s\n\n    # doping\n    dopingFactorNd = 1.0\n    dopingFactorNa = 0.46\n    Nd = dopingFactorNd * Nc\n    Na = dopingFactorNa * Nv\n\n    # intrinsic concentration\n    ni = sqrt(Nc * Nv) * exp(-(Ec - Ev) / (2 * k_B * T))\n\n    # contact voltage: we impose an applied voltage only on one boundary.\n    # At the other boundary the applied voltage is zero.\n    voltageAcceptor = 1.5 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data = Data(grid, numberOfCarriers)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType = Stationary\n\n    # Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F .= Boltzmann\n\n    # Here, we need to specify which numbers are associated with electron and hole quasi\n    # Fermi potential. Further, the desired recombination processes can be chosen here.\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Following choices are possible for boundary model: For contacts currently only\n    # OhmicContact and SchottkyContact are possible. For inner boundaries we have\n    # InterfaceNone, InterfaceRecombination.\n    data.boundaryType[bregionAcceptor] = OhmicContact\n    data.boundaryType[bregionDonor] = OhmicContact\n\n    # Following choices are possible for the flux discretization scheme: ScharfetterGummel,\n    # ScharfetterGummelGraded, ExcessChemicalPotential, ExcessChemicalPotentialGraded,\n    # DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Define the Params struct. Params contains all necessary physical parameters. If one wants to simulate space-dependent variables, one additionally needs to generate a ParamsNodal struct, see Ex102.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg] = εr * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = mun\n        params.mobility[iphip, ireg] = mup\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor] = Nd     # data.doping   = [0.0  Na;\n    params.doping[iphin, regionIntrinsic] = ni     #                  ni  0.0;\n    params.doping[iphip, regionAcceptor] = Na     #                  Nd  0.0]","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"Region dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    data.params = params","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"In the last step, we initialize our system with previous data which is likewise dependent on the parameters. It is important that this is in the end, otherwise our VoronoiFVMSys is not dependent on the data we initialized but rather on default data.","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        # Here we can show region dependent physical parameters. show_params() only supports\n        # region dependent parameters, but, if one wishes to print nodal dependent parameters,\n        # currently this is possible with println(ctsys.data.paramsnodal). We neglected here,\n        # since in most applications where the numberOfNodes is >> 10 this would results in a\n        # large output in the terminal.\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        # set legend for plotting routines. Either you can use the predefined labels or write your own.\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        psi0 = electroNeutralSolution(ctsys)\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, label_BEE)\n        Plotter.figure()\n        plot_doping(Plotter, ctsys, label_density)\n        Plotter.figure()\n        plot_electroNeutralSolutionBoltzmann(Plotter, grid, psi0, ; plotGridpoints = true)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 50\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.tol_round = 1.0e-8\n    control.damp_initial = 0.5\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 32)\n    IV = zeros(0)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution)\n\n        push!(IV, abs.(w_device * z_device * (current)))\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # plot solution and IV curve\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_energy, plotGridpoints = false)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_solution, plotGridpoints = true)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $(biasValues[end])\", label_density, plotGridpoints = true)\n        Plotter.figure()\n        plot_IV(Plotter, biasValues, IV, \"Applied voltage Δu = $(biasValues[end])\", plotGridpoints = true)\n    end\n\n    testval = solution[15]\n    return testval\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\nend #  main\n\nfunction test()\n    testval = 1.5068426833371802\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when the PIN module has successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"","category":"page"},{"location":"module_examples/Ex101_PIN/","page":"GaAs diode (1D).","title":"GaAs diode (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/#Three-layer-PSC-device-with-graded-interfaces-and-Ohmic-contacts-(1D).","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"section"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Simulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD without mobile ions. The simulations are performed out of equilibrium, stationary and with two junctions between perovskite layer and transport layers, to which we refer as graded interfaces. Hence, a graded flux discretization with space dependent band-edge energies and density of states is tested here. The difference here is that we adjusted the order of indexing the quasi Fermi potentials.","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"The parameters are based on the default parameter set of Ionmonger (with minor adjustments), such that we can likewise compare with the software Driftfusion, see https://github.com/barnesgroupICL/Driftfusion/blob/Methods-IonMonger-Comparison/Inputfiles/IonMongerdefault_bulk.csv","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"module Ex105_PSC_gradedFlux\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot\n\n# function for grading the physical parameters\nfunction grading_parameter!(physicalParameter, coord, regionTransportLayers, regionJunctions, h, heightLayers, lengthLayers, values)\n    for ireg in regionTransportLayers\n\n        xcoord = lengthLayers[ireg]:lengthLayers[ireg + 1]\n        physicalParameter[xcoord] .= values[ireg]\n\n    end\n\n    for ireg in regionJunctions\n\n        xcoord = lengthLayers[ireg]:lengthLayers[ireg + 1]\n        left = lengthLayers[ireg] - 3\n        junction = h[ireg]\n        right = lengthLayers[ireg + 2] - 3\n\n        gradient = (physicalParameter[right] - physicalParameter[left]) / junction\n\n        for index in xcoord\n            physicalParameter[index] = physicalParameter[left] + (coord[index] - heightLayers[ireg - 1]) * gradient\n        end\n\n    end\n\n    return physicalParameter\nend","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"function main(; n = 2, Plotter = PyPlot, plotting = false, verbose = false, test = false, unknown_storage = :sparse)\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n\n    eV = constants.q * V\n\n    # region numbers\n    regionDonor = 1          # n doped region\n    regionJunction1 = 2\n    regionIntrinsic = 3          # intrinsic region\n    regionJunction2 = 4\n    regionAcceptor = 5          # p doped region\n    regions = [regionDonor, regionJunction1, regionIntrinsic, regionJunction2, regionAcceptor]\n    regionTransportLayers = [regionDonor, regionIntrinsic, regionAcceptor]\n    regionJunctions = [regionJunction1, regionJunction2]\n    numberOfRegions = length(regions)\n\n    # boundary region numbers\n    bregionDonor = 1\n    bregionAcceptor = 2\n    bregionDJ1 = 3\n    bregionJ1I = 4\n    bregionIJ2 = 5\n    bregionJ2A = 6\n\n    # grid\n    h_ndoping = 9.9e-6 * cm\n    h_junction1 = 1.0e-7 * cm\n    h_intrinsic = 4.0e-5 * cm\n    h_junction2 = 1.0e-7 * cm\n    h_pdoping = 1.99e-5 * cm\n    h_total = h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping\n    h = [h_ndoping, h_junction1, h_intrinsic, h_junction2, h_pdoping]\n    heightLayers = [\n        h_ndoping,\n        h_ndoping + h_junction1,\n        h_ndoping + h_junction1 + h_intrinsic,\n        h_ndoping + h_junction1 + h_intrinsic + h_junction2,\n        h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping,\n    ]\n    refinementfactor = 2^(n - 1)\n\n    coord_ndoping = collect(range(0.0, stop = h_ndoping, length = 4 * refinementfactor))\n    length_n = length(coord_ndoping)\n    coord_junction1 = collect(\n        range(\n            h_ndoping,\n            stop = h_ndoping + h_junction1,\n            length = 3 * refinementfactor\n        )\n    )\n    coord_intrinsic = collect(\n        range(\n            h_ndoping + h_junction1,\n            stop = (h_ndoping + h_junction1 + h_intrinsic),\n            length = 10 * refinementfactor\n        )\n    )\n    coord_junction2 = collect(\n        range(\n            h_ndoping + h_junction1 + h_intrinsic,\n            stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n            length = 3 * refinementfactor\n        )\n    )\n    coord_pdoping = collect(\n        range(\n            (h_ndoping + h_junction1 + h_intrinsic + h_junction2),\n            stop = (h_ndoping + h_junction1 + h_intrinsic + h_junction2 + h_pdoping),\n            length = 4 * refinementfactor\n        )\n    )\n\n    coord = glue(coord_ndoping, coord_junction1)\n    length_j1 = length(coord)\n    coord = glue(coord, coord_intrinsic)\n    length_i = length(coord)\n    coord = glue(coord, coord_junction2)\n    length_j2 = length(coord)\n    coord = glue(coord, coord_pdoping)\n\n    grid = simplexgrid(coord)\n    numberOfNodes = length(coord)\n    lengthLayers = [1, length_n, length_j1, length_i, length_j2, numberOfNodes]\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [heightLayers[1]], regionDonor)      # n-doped region   = 1\n    cellmask!(grid, [heightLayers[1]], [heightLayers[2]], regionJunction1)  # first junction   = 2\n    cellmask!(grid, [heightLayers[2]], [heightLayers[3]], regionIntrinsic)  # intrinsic region = 3\n    cellmask!(grid, [heightLayers[3]], [heightLayers[4]], regionJunction2)  # sec. junction    = 4\n    cellmask!(grid, [heightLayers[4]], [heightLayers[5]], regionAcceptor)   # p-doped region   = 5","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"inner interfaces","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"    bfacemask!(grid, [heightLayers[1]], [heightLayers[1]], bregionDJ1)\n    bfacemask!(grid, [heightLayers[2]], [heightLayers[2]], bregionJ1I)\n    bfacemask!(grid, [heightLayers[3]], [heightLayers[3]], bregionIJ2)\n    bfacemask!(grid, [heightLayers[4]], [heightLayers[4]], bregionJ2A)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 2 # electron quasi Fermi potential\n    iphip = 1 # hole quasi Fermi potential\n    numberOfCarriers = 2\n\n    # temperature\n    T = 300.0 * K\n\n    # band edge energies\n    Ec_d = -4.0 * eV\n    Ev_d = -6.0 * eV\n\n    Ec_i = -3.7 * eV\n    Ev_i = -5.4 * eV\n\n    Ec_a = -3.1 * eV\n    Ev_a = -5.1 * eV\n\n    # these parameters at the junctions for E_\\alpha and N_\\alpha will be overwritten.\n    Ec_j1 = Ec_d;     Ec_j2 = Ec_i\n    Ev_j1 = Ev_d;     Ev_j2 = Ev_i\n\n    EC = [Ec_d, Ec_j1, Ec_i, Ec_j2, Ec_a]\n    EV = [Ev_d, Ev_j1, Ev_i, Ev_j2, Ev_a]\n\n    # effective densities of state\n    Nc_d = 5.0e19 / (cm^3)\n    Nv_d = 5.0e19 / (cm^3)\n\n    Nc_i = 8.1e18 / (cm^3)\n    Nv_i = 5.8e18 / (cm^3)\n\n    Nc_a = 5.0e19 / (cm^3)\n    Nv_a = 5.0e19 / (cm^3)\n\n    Nc_j1 = Nc_d;     Nc_j2 = Nc_i\n    Nv_j1 = Nv_d;     Nv_j2 = Nv_i\n\n    NC = [Nc_d, Nc_j1, Nc_i, Nc_j2, Nc_a]\n    NV = [Nv_d, Nv_j1, Nv_i, Nv_j2, Nv_a]\n\n    # mobilities\n    μn_d = 3.89 * (cm^2) / (V * s)\n    μp_d = 3.89 * (cm^2) / (V * s)\n\n    μn_i = 6.62e1 * (cm^2) / (V * s)\n    μp_i = 6.62e1 * (cm^2) / (V * s)\n\n    μn_a = 3.89e-1 * (cm^2) / (V * s)\n    μp_a = 3.89e-1 * (cm^2) / (V * s)\n\n    μn_j1 = μn_d;     μn_j2 = μn_i\n    μp_j1 = μp_d;     μp_j2 = μp_i\n\n    μn = [μn_d, μn_j1, μn_i, μn_j2, μn_a]\n    μp = [μp_d, μp_j1, μp_i, μp_j2, μp_a]\n\n    # relative dielectric permittivity\n    ε_d = 10.0 * 1.0\n    ε_i = 24.1 * 1.0\n    ε_a = 3.0 * 1.0\n\n    ε_j1 = ε_d;       ε_j2 = ε_a\n\n    ε = [ε_d, ε_j1, ε_i, ε_j2, ε_a]\n\n    # radiative recombination\n    r0_d = 0.0e+0 * cm^3 / s\n    r0_i = 1.0e-12 * cm^3 / s\n    r0_a = 0.0e+0 * cm^3 / s\n\n    r0_j1 = r0_i;      r0_j2 = r0_i\n\n    r0 = [r0_d, r0_j1, r0_i, r0_j2, r0_a]\n\n    # life times and trap densities\n    τn_d = 1.0e100 * s\n    τp_d = 1.0e100 * s\n\n    τn_i = 3.0e-10 * s\n    τp_i = 3.0e-8 * s\n    τn_a = τn_d\n    τp_a = τp_d\n\n    τn_j1 = τn_i;     τn_j2 = τn_a\n    τp_j1 = τp_i;     τp_j2 = τp_a\n\n    τn = [τn_d, τn_j1, τn_i, τn_j2, τn_a]\n    τp = [τp_d, τp_j1, τp_i, τp_j2, τp_a]\n\n    # SRH trap energies (needed for calculation of trap_density (SRH))","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Eid             = -5.0                 * eV Eii             = -4.55                * eV Ei_a             = -4.1                 * eV","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"Eij1            = Eid;      Eij2     = Eii","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"EI               = [Eid, Eij1, Eii, Eij2, Ei_a]","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"    # reference densities\n    nτ_d = 7.94e8 / m^3\n    pτ_d = 7.94e8 / m^3\n\n    nτ_i = 4.26e10 / m^3\n    pτ_i = 3.05e10 / m^3\n    nτ_a = nτ_d\n    pτ_a = pτ_d\n\n    nτ_j1 = nτ_i;     nτ_j2 = nτ_a\n    pτ_j1 = pτ_i;     pτ_j2 = pτ_a\n\n    nτ = [nτ_d, nτ_j1, nτ_i, nτ_j2, nτ_a]\n    pτ = [pτ_d, pτ_j1, pτ_i, pτ_j2, pτ_a]\n\n    # Auger recombination\n    Auger = 0.0\n\n    # doping (doping values are from Driftfusion)\n    Nd = 1.03e18 / (cm^3)\n    Na = 1.03e18 / (cm^3)\n    Ni_acceptor = 8.32e7 / (cm^3)\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data = Data(grid, numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F .= Boltzmann\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[bregionDonor] = OhmicContact\n    data.boundaryType[bregionAcceptor] = OhmicContact\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ScharfetterGummelGraded\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    # for region dependent parameters\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n    # for space dependent parameters\n    paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n\n    # nodal band-edge energies\n    paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(\n        paramsnodal.bandEdgeEnergy[iphin, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, EC\n    )\n    paramsnodal.bandEdgeEnergy[iphip, :] = grading_parameter!(\n        paramsnodal.bandEdgeEnergy[iphip, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, EV\n    )\n    # nodal effective density of states\n    paramsnodal.densityOfStates[iphin, :] = grading_parameter!(\n        paramsnodal.densityOfStates[iphin, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, NC\n    )\n    paramsnodal.densityOfStates[iphip, :] = grading_parameter!(\n        paramsnodal.densityOfStates[iphip, :],\n        coord, regionTransportLayers, regionJunctions, h,\n        heightLayers, lengthLayers, NV\n    )\n\n    for ireg in 1:numberOfRegions  ## region dependent data\n\n        # mobility\n        params.mobility[iphin, ireg] = μn[ireg]\n        params.mobility[iphip, ireg] = μp[ireg]\n\n        params.dielectricConstant[ireg] = ε[ireg] * constants.ε_0\n        # recombination parameters\n        params.recombinationRadiative[ireg] = r0[ireg]\n        params.recombinationSRHLifetime[iphin, ireg] = τn[ireg]\n        params.recombinationSRHLifetime[iphip, ireg] = τp[ireg]\n        params.recombinationSRHTrapDensity[iphin, ireg] = nτ[ireg]\n        params.recombinationSRHTrapDensity[iphip, ireg] = pτ[ireg]\n        params.recombinationAuger[iphin, ireg] = Auger\n        params.recombinationAuger[iphip, ireg] = Auger\n\n    end\n\n    # doping\n    params.doping[iphin, regionDonor] = Nd\n    params.doping[iphip, regionIntrinsic] = Ni_acceptor\n    params.doping[iphip, regionAcceptor] = Na\n\n    data.params = params\n    data.paramsnodal = paramsnodal\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    # print data\n    if test == false\n        show_params(ctsys)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 200\n    control.abstol = 1.0e-13\n    control.reltol = 1.0e-13\n    control.tol_round = 1.0e-13\n    control.damp_initial = 0.5\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 13)\n\n    for Δu in biasValues\n        if test == false\n            println(\"Bias value: Δu = $(Δu) V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival = solution\n\n    end # bias loop\n\n    # plotting\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Applied voltage Δu = $maxBias\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = solution[data.index_psi, 20]\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -3.982748467515117\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"","category":"page"},{"location":"module_examples/Ex105_PSC_gradedFlux/","page":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","title":"Three-layer PSC device with graded interfaces & Ohmic contacts (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"PSC/#Perovskite-solar-cell","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We simulate charge transport in perovskite solar cells (PSCs), where we have apart from holes and electrons also ionic charge carriers. Here, we assume to have three domains, denoted by mathbfOmega = mathbfOmega_textHTL cup mathbfOmega_textintr cup mathbfOmega_textETL   The unknowns are the quasi Fermi potentials of electrons holes and anion vacancies varphi_n varphi_p varphi_a as well as the electric potential psi. The underlying PDEs are given by","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - C_p ) - (n(psi varphi_n) - C_n) Big)\n\tq partial_t n(psi varphi_n) - nabla cdot mathbfj_n = qBigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for mathbfx in mathbfOmega_textHTL cup  mathbfOmega_textETL  t in 0 t_F. In the middle, intrinsic region ($ \\mathbf{x} \\in \\mathbf{\\Omega}_{\\text{intr}} $), we have","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( p(psi varphi_p)  - n(psi varphi_n) + a(psi varphi_a) - C_a Big)\nq partial_t n(psi varphi_n)\t- nabla cdot mathbfj_n = Bigl(G(mathbfx) - R(np) Bigr) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = Bigl(G(mathbfx) - R(np) Bigr)\n\tq partial_t a(psi varphi_a) + nabla cdot mathbfj_a = 0\nendaligned","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"see Abdel2021.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Differences to the previous example include","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"an additional charge carrier (the anion vacancy)\nparameter jumps across heterojunctions\nthe transient case\na generation rate G\nhigher dimensional problem.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"A quick survey on how to use ChargeTransport.jl to adjust the input parameters such that these features can be simulated will be given in the following.","category":"page"},{"location":"PSC/#Example-1:-Graded-interfaces","page":"Perovskite solar cell","title":"Example 1: Graded interfaces","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"By default, we assume abrupt inner interfaces. If one wishes to simulate graded interfaces, where for example the effective density of states and the band-edge energy may vary, we refer to this or this example.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"We sketch the relevant parts here. First, we need to define two additional thin interface layers","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"# unit factors\n@local_unitfactors V s\n\n# region numbers\nregionDonor     = 1       # n doped region\nregionJunction1 = 2\nregionIntrinsic = 3       # intrinsic region\nregionJunction2 = 4\nregionAcceptor  = 5       # p doped region","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"which need to be taken into account by the initialization of the grid.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Second, since we allow varying parameters within the thin interface layers, the flux discretization scheme needs to be chosen accordingly and we need to construct a nodally dependent parameter struct","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.fluxApproximation = ScharfetterGummelGraded\n\nparamsnodal            = ParamsNodal(grid, numberOfCarriers)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Finally, we introduce graded parameters. Currently, only a linear grading is implemented.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"paramsnodal.bandEdgeEnergy[iphin, :] = grading_parameter!(paramsnodal.bandEdgeEnergy[iphin, :],\n                                                         coord, regionTransportLayers, regionJunctions,\n                                                         h, heightLayers, lengthLayers, EC)","category":"page"},{"location":"PSC/#Example-2:-Linear-IV-scan-protocol","page":"Perovskite solar cell","title":"Example 2: Linear IV scan protocol","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Here, we summarize the main parts of this example. Define three charge carriers.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"iphin                    = 2 # electrons\niphip                    = 1 # holes\niphia                    = 3 # anion vacancies\nnumberOfCarriers         = 3","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Consider the transient problem and enable the ionic charge carriers only in the active layer:","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.modelType           = Transient\nenable_ionic_carrier!(data, ionicCarrier = iphia, regions = [regionIntrinsic])","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Following specification is needed for a linear I-V scan protocol.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"scanrate                 = 1.0 * V/s\nnumber_tsteps            = 31\nendVoltage               = voltageAcceptor # bias goes until the given voltage at acceptor boundary\ntend                     = endVoltage/scanrate","category":"page"},{"location":"PSC/#Variant-A:-Solve-the-transient-problem-manually","page":"Perovskite solar cell","title":"Variant A: Solve the transient problem manually","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"## with fixed timestep sizes we can calculate the times a priori\ntvalues                    = range(0, stop = tend, length = number_tsteps)\n\nfor istep = 2:number_tsteps\n\n    t  = tvalues[istep]                  # current time\n    Δu = t * scanrate                    # applied voltage\n    Δt = t - tvalues[istep-1]            # time step\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu)\n    solution = solve(ctsys, inival = inival, control = control, tstep = Δt) # provide time step\n    inival   = solution\n\nend","category":"page"},{"location":"PSC/#Variant-B:-Use-internal-time-stepping","page":"Perovskite solar cell","title":"Variant B: Use internal time stepping","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"To make use of internal time stepping, the scan protocol need to be previously defined, e.g.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"function linearScanProtocol(t)\n    if t == Inf\n        0.0\n    else\n        scanrate * t\n    end\nend\n\n## Apply zero voltage on left boundary and a linear scan protocol on right boundary\ncontactVoltageFunction = [zeroVoltage, linearScanProtocol]","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"And then, need to be parsed into the data construction method","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"This makes it possible to use the internal time solving method","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"sol = solve(ctsys, inival = inival, times=(0.0, tend), control = control)","category":"page"},{"location":"PSC/#Example-3:-Illumination","page":"Perovskite solar cell","title":"Example 3: Illumination","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Add uniform illumination to the previous code by setting","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel = GenerationUniform","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"and specify the uniform generation rate in each region, i.e.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for ireg in 1:numberOfRegions\n    params.generationUniform[ireg] = generationUniform[ireg]\nend","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"for given data stored in generationUniform. If one wishes to use the Beer-Lambert generation, then the corresponding code would be","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"data.generationModel                          = GenerationBeerLambert\n\nfor ireg in 1:numberOfRegions\n    params.generationIncidentPhotonFlux[ireg] = incidentPhotonFlux[ireg]\n    params.generationAbsorption[ireg]         = absorption[ireg]\nend\n\nparams.generationPeak                         = generationPeak","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"If one wishes to invert the illumination, one needs to define","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"params.invertedIllumination                   = -1","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"where this value is by default set to one (for light entering from the left). Furthermore, we recommend performing a time loop while increasing the generation rate and afterwards applying the scan protocol with a full generation due to numerical stability, see this example.","category":"page"},{"location":"PSC/#Example-4:-Multi-dimensional-problems","page":"Perovskite solar cell","title":"Example 4: Multi-dimensional problems","text":"","category":"section"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"It is also possible to perform multi-dimensional simulations.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"For a 2D mesh you may use a structured grid via ExtendableGrids.jl or an unstructured mesh via the Julia wrapper Triangulate.jl for Jonathan Richard Shewchuk's Triangle mesh generator. Respective examples can be likewise found within this package.","category":"page"},{"location":"PSC/","page":"Perovskite solar cell","title":"Perovskite solar cell","text":"Lastly, with help of the TetGen.jl wrapper, three dimensional tetrahedral meshes can be generated, see this example.","category":"page"},{"location":"plot/#Plotting-Routines","page":"Plotting Routines","title":"Plotting Routines","text":"","category":"section"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"The same design as in VoronoiFVM.jl is used: To avoid dependencies for this package, the plot methods defined in this package have as their first argument the module of the plotting package used.","category":"page"},{"location":"plot/","page":"Plotting Routines","title":"Plotting Routines","text":"Currently, only PyPlot was tested.","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/#PSC-device-on-2D-domain-(Tensor-grid).","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"section"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"(source code)","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"Simulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions. The simulations are performed in 2D on a tensor grid, out of equilibrium and with abrupt interfaces.","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"module Ex201_PSC_tensorGrid\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"function main(;\n        n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false,\n        parameter_set = Params_PSC_PCBM_MAPI_Pedot, # choose the parameter set\n    )\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"parameter","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"    p = parameter_set()\n\n    bregionNoFlux = 3\n    height = 5.0e-6 * cm\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 0.4 * V / s\n    number_tsteps = 31\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tend = endVoltage / scanrate\n    tvalues = range(0, stop = tend, length = number_tsteps)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.6 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (5.1 * δ), p.h_intrinsic / (1.0 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (1.0 * δ), p.h_intrinsic / (5.1 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.3 * δ), p.h_pdoping / (0.3 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (0.6 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord_length = glue(coord, coord_p_u, tol = 10 * t)\n\n    height_L = geomspace(0.0, height / 2, height / (0.4 * δ), height / (0.4 * δ))\n    height_R = geomspace(height / 2, height, height / (0.4 * δ), height / (0.4 * δ))\n    coord_height = glue(height_L, height_R, tol = 10 * t)\n\n    grid = simplexgrid(coord_length, coord_height)\n\n    # specify inner regions\n    cellmask!(grid, [0.0, 0.0], [p.h_ndoping, height], p.regionDonor, tol = 1.0e-18)\n    cellmask!(grid, [p.h_pdoping, 0.0], [p.h_ndoping + p.h_intrinsic, height], p.regionIntrinsic, tol = 1.0e-18)\n    cellmask!(grid, [p.h_ndoping + p.h_intrinsic, 0.0], [p.h_total, height], p.regionAcceptor, tol = 1.0e-18)\n\n    # specify outer regions\n    # metal interfaces\n    bfacemask!(grid, [0.0, 0.0], [0.0, height], p.bregionDonor)            # BregionNumber = 1\n    bfacemask!(grid, [p.h_total, 0.0], [p.h_total, height], p.bregionAcceptor) # BregionNumber = 2\n\n    # no flux interfaces [xmin, ymin], [xmax, ymax]\n    bfacemask!(grid, [0.0, 0.0], [p.h_total, 0.0], bregionNoFlux)          # BregionNumber = 3\n    bfacemask!(grid, [0.0, height], [p.h_total, height], bregionNoFlux)    # BregionNumber = 3\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, resolution = (600, 400), linewidth = 0.5, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.max_round = 5\n    control.damp_initial = 0.1\n    control.damp_growth = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if plotting # currently, plotting the solution was only tested with PyPlot.\n        ipsi = data.index_psi\n        X = grid[Coordinates][1, :]\n        Y = grid[Coordinates][2, :]\n\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin, :])\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ (Equilibrium)\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IV = zeros(0) # for IV values\n    biasValues = zeros(0) # for bias values\n\n    for istep in 2:number_tsteps\n\n        t = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep - 1] # Time step size\n\n        # Apply new voltage; set non equilibrium boundary conditions\n        set_contact!(ctsys, p.bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        inival = solution\n    end # time loop\n\n    if plotting\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[ipsi, :])\n        Plotter.title(\"Electrostatic potential \\$ \\\\psi \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        ################\n        Plotter.figure()\n        Plotter.surf(X[:], Y[:], solution[iphin, :])\n        Plotter.title(\"quasi Fermi potential \\$ \\\\varphi_n \\$ at end time\")\n        Plotter.xlabel(\"length [m]\")\n        Plotter.ylabel(\"height [m]\")\n        Plotter.zlabel(\"potential [V]\")\n        ################\n        Plotter.figure()\n        Plotter.plot(biasValues, IV .* (cm)^2 / height, label = \"\", linewidth = 3, marker = \"o\")\n        Plotter.grid()\n        Plotter.ylabel(\"total current [A]\") #\n        Plotter.xlabel(\"Applied Voltage [V]\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -0.5818799192233242\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"","category":"page"},{"location":"module_examples/Ex201_PSC_tensorGrid/","page":"PSC device on 2D domain (Tensor grid).","title":"PSC device on 2D domain (Tensor grid).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/#PSC-device-with-surface-recombination-(1D).","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"section"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"Simulating a three layer PSC device PCBM | MAPI | Pedot with mobile ions with a linear scan protocol.","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"Here, the surface recombination at internal boundaries is tested.","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"module Ex106_PSC_SurfaceRecombination\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"you can also use other Plotters, if you add them to the example file","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"function main(;\n        n = 6, Plotter = PyPlot, plotting = false,\n        verbose = false, test = false,\n        parameter_set = Params_PSC_PCBM_MAPI_Pedot, # choose the parameter set\n    )\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm s ns V K ps Hz W","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"parameter","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 1.0 * V / s\n    ntsteps = 31\n    vend = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = vend / scanrate\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues = range(0, stop = tend, length = ntsteps)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (5.1 * δ), p.h_intrinsic / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (1.1 * δ), p.h_intrinsic / (5.1 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.3 * δ), p.h_pdoping / (0.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (0.8 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], p.bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [p.h_total], [p.h_total], p.bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionJ1] = InterfaceRecombination\n    data.boundaryType[p.bregionJ2] = InterfaceRecombination\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # Present ionic vacancies in perovskite layer\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.damp_initial = 0.9\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"I-V Measurement Loop\")\n    end\n    ################################################################################\n\n    # for saving I-V data\n    IV = zeros(0) # for IV values\n    biasValues = zeros(0) # for bias values\n\n    for istep in 2:ntsteps\n\n        t = tvalues[istep]       # Actual time\n        Δu = t * scanrate         # Applied voltage\n        Δt = t - tvalues[istep - 1] # Time step size\n\n        # Apply new voltage (set non-equilibrium values)\n        set_contact!(ctsys, p.bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: Δt = $(t)\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control, tstep = Δt)\n        inival = solution\n\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n\n        push!(IV, current)\n        push!(biasValues, Δu)\n\n        if plotting\n            label_solution, label_density, label_energy = set_plotting_labels(data)\n            label_solution[iphia] = \"\\$ \\\\varphi_a\\$\"\n\n            Plotter.clf()\n            plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(Δu)\", label_solution)\n            Plotter.pause(0.5)\n        end\n\n    end # time loop\n\n    ##res = [biasValues, IV]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\n\nend # main\n\nfunction test()\n    testval = -0.5963272869004673\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"","category":"page"},{"location":"module_examples/Ex106_PSC_SurfaceRecombination/","page":"PSC device with surface recombination (1D).","title":"PSC device with surface recombination (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/#MoS2-with-moving-defects-and-Schottky-Barrier-Lowering.","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"","category":"section"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"(source code)","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Memristor simulation with additional moving positively charged defects and Schottky barrier lowering at the contacts.","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"module Ex107_MoS2_withIons_BarrierLowering\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"function main(; Plotter = PyPlot, plotting = false, verbose = false, test = false, barrierLowering = true)\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid, regions and time mesh\")\n    end\n    ################################################################################\n\n    @local_unitfactors μm cm eV s ns V K ps Hz W m\n\n    constants = ChargeTransport.constants\n    (; q, k_B, ε_0, Planck_constant, m_e) = constants\n\n\n    # region numbers\n    regionflake = 1\n\n    # boundary region numbers\n    bregionLeft = 1\n    bregionRight = 2\n\n    # grid\n    h_flake = 1.0 * μm # length of the conducting channel","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"non-uniform grid","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    coord1 = geomspace(0.0, h_flake / 2, 5.0e-4 * h_flake, 2.0e-2 * h_flake)\n    coord2 = geomspace(h_flake / 2, h_flake, 2.0e-2 * h_flake, 5.0e-4 * h_flake)\n    coord = glue(coord1, coord2)\n\n    grid = simplexgrid(coord)\n\n    # set region in grid\n    cellmask!(grid, [0.0], [h_flake], regionflake, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of unknowns\n    iphin = 1 # electron quasi Fermi potential\n    iphip = 2 # hole quasi Fermi potential\n    iphix = 3\n\n    numberOfCarriers = 3 # electrons, holes and ions","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"We define the physical data","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    T = 300.0 * K\n    εr = 9.0 * 1.0                   # relative dielectric permittivity\n    εi = 1.0 * εr                                   # image force dielectric permittivity\n\n    Ec = - 4.0 * eV\n    Ev = - 5.3 * eV\n    Ex = - 4.38 * eV\n\n    Nc = 2 * (2 * pi * 0.55 * m_e * k_B * T / (Planck_constant^2))^(3 / 2) / m^3\n    Nv = 2 * (2 * pi * 0.71 * m_e * k_B * T / (Planck_constant^2))^(3 / 2) / m^3\n    Nx = 1.0e28 / (m^3)\n\n    μn = 1.0e-4 * (m^2) / (V * s)\n    μp = 1.0e-4 * (m^2) / (V * s)\n    μx = 0.8e-13 * (m^2) / (V * s)\n\n    # Schottky contact\n    barrierLeft = 0.225 * eV\n    barrierRight = 0.215 * eV\n    An = 4 * pi * q * 0.55 * m_e * k_B^2 / Planck_constant^3\n    Ap = 4 * pi * q * 0.71 * m_e * k_B^2 / Planck_constant^3\n    vn = An * T^2 / (q * Nc)\n    vp = Ap * T^2 / (q * Nv)\n\n    Nd = 1.0e17 / (m^3) # doping\n\n    Area = 2.1e-11 * m^2                # Area of electrode","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Scan protocol information","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    endTime = 9.6 * s\n    amplitude = 12.0 * V\n    scanrate = 4 * amplitude / endTime\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if 0.0 <= t  && t <= endTime / 4\n            biasVal = 0.0 + scanrate * t\n        elseif t >= endTime / 4  && t <= 3 * endTime / 4\n            biasVal = amplitude .- scanrate * (t - endTime / 4)\n        elseif t >= 3 * endTime / 4 && t <= endTime\n            biasVal = - amplitude .+ scanrate * (t - 3 * endTime / 4)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"Apply zero voltage on left boundary and a linear scan protocol on right boundary","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    data = Data(grid, numberOfCarriers, contactVoltageFunction = contactVoltageFunction)\n    data.modelType = Transient\n    data.F = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = false,\n        bulk_recomb_SRH = false\n    )\n    if barrierLowering\n        data.boundaryType[bregionLeft] = SchottkyBarrierLowering\n        data.boundaryType[bregionRight] = SchottkyBarrierLowering\n    else\n        data.boundaryType[bregionLeft] = SchottkyContact\n        data.boundaryType[bregionRight] = SchottkyContact\n    end\n\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    enable_ionic_carrier!(data, ionicCarrier = iphix, regions = [regionflake])\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = -1\n    params.chargeNumbers[iphip] = 1\n    params.chargeNumbers[iphix] = 2\n\n    for ireg in 1:length([regionflake])           # region data\n\n        params.dielectricConstant[ireg] = εr * ε_0\n        params.dielectricConstantImageForce[ireg] = εi * ε_0\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nc\n        params.densityOfStates[iphip, ireg] = Nv\n        params.bandEdgeEnergy[iphin, ireg] = Ec\n        params.bandEdgeEnergy[iphip, ireg] = Ev\n        params.mobility[iphin, ireg] = μn\n        params.mobility[iphip, ireg] = μp\n        params.densityOfStates[iphix, ireg] = Nx\n        params.bandEdgeEnergy[iphix, ireg] = Ex\n        params.mobility[iphix, ireg] = μx\n    end\n\n    params.SchottkyBarrier[bregionLeft] = barrierLeft\n    params.SchottkyBarrier[bregionRight] = barrierRight\n    params.bVelocity[iphin, bregionLeft] = vn\n    params.bVelocity[iphin, bregionRight] = vn\n    params.bVelocity[iphip, bregionLeft] = vp\n    params.bVelocity[iphip, bregionRight] = vp\n\n    # interior doping\n    params.doping[iphin, regionflake] = Nd\n\n    data.params = params\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.damp_initial = 0.9\n    control.damp_growth = 1.61 # >= 1\n    control.max_round = 5\n\n    control.abstol = 1.0e-9\n    control.reltol = 1.0e-9\n    control.tol_round = 1.0e-9\n\n    control.Δu_opt = Inf\n    control.Δt = 1.0e-4\n    control.Δt_min = 1.0e-5\n    control.Δt_max = 5.0e-2\n    control.Δt_grow = 1.05\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # initialize solution and starting vectors\n    solEQ = equilibrium_solve!(ctsys, control = control, nonlinear_steps = 0)\n    inival = solEQ\n\n    if plotting\n        label_solution, label_density, label_energy = set_plotting_labels(data)\n        label_energy[1, iphix] = \"\\$E_x-q\\\\psi\\$\"; label_energy[2, iphix] = \"\\$ - q \\\\varphi_x\\$\"\n        label_density[iphix] = \"\\$ n_x\\$\";       label_solution[iphix] = \"\\$ \\\\varphi_x\\$\"\n\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solEQ, \"Equilibrium\", label_density)\n        Plotter.legend()\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solEQ, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    sol = solve(ctsys, inival = inival, times = (0.0, endTime), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    #########  IV curve calculation\n    ################################################################################\n\n    IV = zeros(0) # for saving I-V data\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n    biasValues = scanProtocol.(tvalues)\n\n    factory = TestFunctionFactory(ctsys)\n    tf = testfunction(factory, [bregionLeft], [bregionRight])\n\n    push!(IV, 0.0)\n    for istep in 2:number_tsteps\n        Δt = tvalues[istep] - tvalues[istep - 1] # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot(tvalues, biasValues, marker = \"x\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"voltage [V]\")\n        Plotter.grid()\n\n        Plotter.figure()\n        Plotter.semilogy(biasValues, abs.(Area .* IV), linewidth = 5, color = \"black\")\n        Plotter.grid()\n        Plotter.xlabel(\"applied bias [V]\")\n        Plotter.ylabel(\"total current [A]\")\n    end\n\n\n    testval = sum(filter(!isnan, solEQ)) / length(solEQ)\n    return testval\n\nend #  main\n\nfunction test()\n    return main(test = true, barrierLowering = true) ≈ -1692.2303837883194\nend\n\n\nend # module","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"","category":"page"},{"location":"module_examples/Ex107_MoS2_withIons_BarrierLowering/","page":"MoS2 with moving defects and Schottky Barrier Lowering.","title":"MoS2 with moving defects and Schottky Barrier Lowering.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/#PSC-device-with-ions-and-different-I-V-scan-protocols-(1D).","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"","category":"section"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"Simulating a three layer PSC device Ti02| MAPI | spiro-OMeTAD with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"The time-dependent simulations are performed with abrupt interfaces. Two different I-V measurement protocols are included and the corresponding solution vectors and the I-V curve after the scan can be depicted.","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"module Ex103_PSC_IVMeasurement\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/#you-can-also-use-other-Plotters,-if-you-add-them-to-the-example-file","page":"PSC device with ions and different I-V scan protocols (1D).","title":"you can also use other Plotters, if you add them to the example file","text":"","category":"section"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"function main(;\n        n = 3, Plotter = PyPlot, plotting = false, verbose = false, test = false,\n        parameter_set = Params_PSC_TiO2_MAPI_spiro, # choose the parameter set\n        otherScanProtocol = false\n    ) # you can choose between two scan protocols\n\n    @local_unitfactors μm cm s ns V K ps Hz\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"parameters","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 1.0 * V / s\n    number_tsteps = 31\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = endVoltage / scanrate\n\n    # Define scan protocol function\n    function linearScanProtocol(t)\n        return if t == Inf\n            0.0\n        else\n            scanrate * t\n        end\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, linearScanProtocol]\n\n    # Instead of a linear scan protocol, we can also apply other scan protocols which we\n    # define by our own and parse to the model generator via the struct Data\n    if otherScanProtocol\n        # scan protocol parameter\n        number_tsteps = 40\n        frequency = 10.0 * Hz\n        amplitude = 0.2 * V\n        tend = 1 / frequency\n\n        # Define sinusoidal applied voltage\n        function sinusoidalScanProtocol(t)\n            return if t == Inf\n                0.0\n            else\n                amplitude * sin(2.0 * pi * frequency * t)\n            end\n        end\n\n        # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n        contactVoltageFunction = [zeroVoltage, sinusoidalScanProtocol]\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2, p.h_ndoping,\n        p.h_ndoping / (0.7 * δ), p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping, p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (2.8 * δ), p.h_intrinsic / (2.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k, p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (2.1 * δ), p.h_intrinsic / (2.8 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic, p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.6 * δ), p.h_pdoping / (1.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (1.3 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18)     # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18)  # p-doped region   = 3\n\n    # bfacemask! for setting different boundary regions\n    bfacemask!(grid, [0.0], [0.0], p.bregionDonor, tol = 1.0e-18)     # outer left boundary\n    bfacemask!(grid, [p.h_total], [p.h_total], p.bregionAcceptor, tol = 1.0e-18)  # outer right boundary\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18) # first  inner interface\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18) # second inner interface\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    # Currently, the way to go is to pass a contact voltage function exactly here.\n    data = Data(grid, p.numberOfCarriers)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Transient\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore\n    data.F = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    # Possible choices: OhmicContact, SchottkyContact (outer boundary) and InterfaceNone,\n    # InterfaceRecombination (inner boundary).\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n\n    # With this method, the user enable the ionic carrier parsed to ionicCarrier and gives\n    # gives the information on which regions this ionic carrier is defined.\n    # In this application ion vacancies only live in active perovskite layer.\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    # Choose flux discretization scheme: ScharfetterGummel, ScharfetterGummelGraded,\n    # ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    if plotting == true\n        ################################################################################\n        println(\"Plot electroneutral potential, band-edge energies and doping\")\n        ################################################################################\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia] = \"\\$ n_a \\$\";      label_solution[iphia] = \"\\$ \\\\varphi_a\\$\"\n\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.max_round = 5\n    control.damp_initial = 0.1\n    control.damp_growth = 1.21 # >= 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"Equilibrium\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Equilibrium\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Equilibrium\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # with fixed timestep sizes we can calculate the times a priori\n    tvalues = range(0, stop = tend, length = number_tsteps)\n\n    # for saving I-V data\n    IV = zeros(0)                   # for IV values\n    ISRHn = zeros(0); ISRHp = zeros(0) # for SRH recombination current\n    IRadn = zeros(0); IRadp = zeros(0) # for radiative recombination current\n\n    for istep in 2:number_tsteps\n\n        t = tvalues[istep]                                    # Actual time\n        Δu = contactVoltageFunction[p.bregionAcceptor](t) # Applied voltage\n        Δt = t - tvalues[istep - 1]                              # Time step size\n\n        # Apply new voltage by setting non equilibrium boundary conditions\n        set_contact!(ctsys, p.bregionAcceptor, Δu = Δu)\n\n        if test == false\n            println(\"time value: t = $(t) s\")\n        end\n\n        # Solve time step problems with timestep Δt. inival plays the role of the solution\n        # from last timestep\n        solution = solve(ctsys; inival = inival, control = control, tstep = Δt)\n        # get I-V data\n        current = get_current_val(ctsys, solution, inival, Δt)\n        IntSRH = integrate(ctsys, SRHRecombination!, solution)\n        IntRad = integrate(ctsys, RadiativeRecombination!, solution)\n\n        IntSRHnSum = 0.0; IntRadnSum = 0.0\n        IntSRHpSum = 0.0; IntRadpSum = 0.0\n\n        for ii in 1:p.numberOfRegions\n            IntSRHnSum = IntSRHnSum - IntSRH[p.iphin, ii]\n            IntRadnSum = IntRadnSum - IntRad[p.iphin, ii]\n\n            IntSRHpSum = IntSRHpSum + IntSRH[p.iphip, ii]\n            IntRadpSum = IntRadpSum + IntRad[p.iphip, ii]\n        end\n\n        push!(IV, current)\n        push!(ISRHn, IntSRHnSum); push!(ISRHp, IntSRHpSum)\n        push!(IRadn, IntRadnSum); push!(IRadp, IntRadpSum)\n\n        inival = solution\n\n    end # time loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    # here in res the biasValues and the corresponding current are stored.\n    # res = [biasValues IV];\n\n    if plotting\n        Plotter.figure()\n        plot_energies(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_energy)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\", label_solution)\n    end\n\n    biasValues = contactVoltageFunction[p.bregionAcceptor].(tvalues)\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot(tvalues, biasValues, marker = \"o\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"bias [V]\")\n        Plotter.figure()\n        plot_IV(Plotter, biasValues[2:end], IV, \"bias \\$\\\\Delta u\\$ = $(endVoltage)\")\n        ###############\n        Plotter.figure()\n        semilogy(biasValues[2:end], ISRHn .* (cm^2) .* 1.0e3, linewidth = 5, color = \"darkblue\", label = \"SRH recombination\")\n        semilogy(biasValues[2:end], ISRHp .* (cm^2) .* 1.0e3, linewidth = 5, color = \"lightblue\", linestyle = \":\")\n        semilogy(biasValues[2:end], IRadn .* (cm^2) .* 1.0e3, linewidth = 5, color = \"darkgreen\", label = \"Radiative recombination\")\n        semilogy(biasValues[2:end], IRadp .* (cm^2) .* 1.0e3, linewidth = 5, color = \"lightgreen\", linestyle = \":\")\n\n        PyPlot.grid()\n        PyPlot.legend()\n        PyPlot.xlabel(\"bias [V]\")\n        PyPlot.ylabel(\"current density [mAcm\\$^{-2} \\$]\")\n    end\n\n    testval = sum(filter(!isnan, solution)) / length(solution) # when using sparse storage, we get NaN values in solution\n    return testval\n\n\nend #  main\n\nfunction test()\n    testval = -0.6302819608784171; testvalOther = -1.123710261723505\n    return main(test = true, otherScanProtocol = false) ≈ testval && main(test = true, otherScanProtocol = true) ≈ testvalOther\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"","category":"page"},{"location":"module_examples/Ex103_PSC_IVMeasurement/","page":"PSC device with ions and different I-V scan protocols (1D).","title":"PSC device with ions and different I-V scan protocols (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"module_examples/Ex202_Laser_simple/#Simple-laser-structure-with-5-layers.","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"","category":"section"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"(source code)","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"Simulating a simple laser structure with 5 layers. The layers are defined by their material properties and thicknesses. The simulation will solve the charge transport equations across the layers, taking into account the stimulated recombination in the active region of the laser structure.","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"module Ex202_Laser_simple\n\nusing ChargeTransport\nusing ExtendableGrids\nusing GridVisualize\nusing PyPlot\n\n###########################################################################\nnumberOfColoumns = Dict(\n    \"ref1\" => [2, 4],\n    \"ref2\" => [4, 8],\n    \"ref3\" => [8, 16],\n    \"ref4\" => [16, 32],\n    \"ref5\" => [32, 64]\n)\n\nnumberOfRows = Dict(\n    \"ref1\" => [4, 8, 2, 8, 4],\n    \"ref2\" => [8, 16, 4, 16, 8],\n    \"ref3\" => [16, 32, 8, 32, 16],\n    \"ref4\" => [32, 64, 16, 64, 32],\n    \"ref5\" => [64, 128, 32, 128, 64]\n)\n###################################################################\n\n\"\"\" Initializing X and Y coords for the tesca grid\"\"\"\nfunction tesca_grid(; refinement = 1, showplot = false, airbox = false)\n\n    @local_unitfactors μm\n\n    ncol = numberOfColoumns[\"ref$(refinement)\"]\n    nrow = numberOfRows[\"ref$(refinement)\"]\n\n    widths_columns = [1.0  10.0] * μm\n    heights_rows = [1.0  0.5  0.05  0.5  1.0] * μm\n\n    coord_x1 = collect(range(0.0, widths_columns[1], length = ncol[1] + 1))\n    coord_x2 = collect(range(widths_columns[1], sum(widths_columns[1:2]), length = ncol[2] + 1))\n    X = glue(coord_x1, coord_x2)\n    X = glue(reverse(-X), X)\n\n    coord_y1 = collect(range(0.0, heights_rows[1], length = nrow[1] + 1))\n    coord_y2 = collect(range(heights_rows[1], sum(heights_rows[1:2]), length = nrow[2] + 1))\n    coord_y3 = collect(range(sum(heights_rows[1:2]), sum(heights_rows[1:3]), length = nrow[3] + 1))\n    coord_y4 = collect(range(sum(heights_rows[1:3]), sum(heights_rows[1:4]), length = nrow[4] + 1))\n    coord_y5 = collect(range(sum(heights_rows[1:4]), sum(heights_rows[1:5]), length = nrow[5] + 1))\n    Y = glue(glue(glue(glue(coord_y1, coord_y2), coord_y3), coord_y4), coord_y5)\n\n    grid = simplexgrid(X, Y)\n\n    cellmask!(grid, [X[1], 0.0], [sum(widths_columns), heights_rows[1]], 1)\n    cellmask!(grid, [X[1], heights_rows[1]], [sum(widths_columns), sum(heights_rows[1:2])], 2)\n    cellmask!(grid, [X[1], sum(heights_rows[1:2])], [sum(widths_columns), sum(heights_rows[1:3])], 3)\n    cellmask!(grid, [X[1], sum(heights_rows[1:3])], [sum(widths_columns), sum(heights_rows[1:4])], 4)\n    cellmask!(grid, [X[1], sum(heights_rows[1:4])], [sum(widths_columns), sum(heights_rows[1:5])], 5)","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"AIR","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"    cellmask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [sum(widths_columns), sum(heights_rows[1:5])], 6)\n    cellmask!(grid, [X[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows[1:5])], 6)\n\n    bregionDonor1 = 1      # bottom boundary\n    bregionAcceptor2 = 2   # top boundary\n    bregionNoFlux = 3\n    bregionAirBox = 4\n    bfacemask!(grid, [-widths_columns[1], sum(heights_rows)], [widths_columns[1], sum(heights_rows)], bregionAcceptor2)\n    bfacemask!(grid, [X[1], 0.0], [X[end], 0.0], bregionDonor1)\n\n    bfacemask!(grid, [X[1], 0.0], [X[1], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [X[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [-widths_columns[1], sum(heights_rows[1:4])], [-widths_columns[1], sum(heights_rows)], bregionNoFlux)\n\n    bfacemask!(grid, [X[end], 0.0], [X[end], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [X[end], sum(heights_rows[1:4])], bregionNoFlux)\n    bfacemask!(grid, [widths_columns[1], sum(heights_rows[1:4])], [widths_columns[1], sum(heights_rows)], bregionNoFlux)\n\n    bfacemask!(grid, [X[1], sum(heights_rows[1:4])], [X[1], Y[end]], bregionAirBox)\n    bfacemask!(grid, [X[1], Y[end]], [-widths_columns[1], Y[end]], bregionAirBox)\n    bfacemask!(grid, [widths_columns[1], Y[end]], [X[end], Y[end]], bregionAirBox)\n    bfacemask!(grid, [X[end], sum(heights_rows[1:4])], [X[end], Y[end]], bregionAirBox)\n\n    if airbox == false\n        grid = subgrid(grid, [1, 2, 3, 4, 5])\n    end\n\n    if showplot == true\n        GridVisualize.gridplot(\n            grid, Plotter = PyPlot, linewidth = 1, fontsize = 35, size = (1200, 900),\n            legend = :best, show = true, aspect = 4, colorbar = false, title = \"Device Geometry, values in [m]\", xlabel = \"x-coordinates\", ylabel = \"y-coordinates\"\n        )\n    end\n\n    return grid\nend\n\nfunction main(;\n        refinement = 1, plotting = false, verbose = false, test = false, unknown_storage = :sparse,\n        numberOfEigenvalues = 1,\n        parameter_set = Params_Laser_simple # choose the parameter set\n    )","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"parameter","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"    p = parameter_set()\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid.\")\n    end\n    ################################################################################\n\n    grid = tesca_grid(refinement = refinement, showplot = plotting, airbox = false)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in data\n    data = Data(grid, p.numberOfCarriers, numberOfEigenvalues = numberOfEigenvalues)\n\n    # Possible choices: Stationary, Transient\n    data.modelType = Stationary\n\n    # Possible choices: Boltzmann, FermiDiracOneHalfBednarczyk, FermiDiracOneHalfTeSCA,\n    # FermiDiracMinusOne, Blakemore.\n    # Can be a vector with different statistics (for n and p).\n    data.F .= FermiDiracOneHalfTeSCA\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = true,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n\n    data.boundaryType[p.bregionAcceptor2] = OhmicContact  # top boundary Dirichlet condition\n    data.boundaryType[p.bregionDonor1] = OhmicContact     # bottom boundary Dirichlet condition","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"                                                # rest is set to Neumann by default","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"    data.fluxApproximation .= ExcessChemicalPotential\n    #data.fluxApproximation .= ScharfetterGummel          # if F=Boltzmann\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    \"\"\" Data from Params_Laser_simple.jl: temperature T, band edge energies EC, EV, effective density of states NC, NV\n        mobilities μn, μp, dielectricConstant εs, radiative recombination r0, life times τn, τp,\n        Auger recombination coefficients Auger_Cn, Auger_Cp\n        doping doping (or vcat(Nd,Na) = doping).\n    \"\"\"\n    paramsoptical = ParamsOptical(grid, p.numberOfCarriers, numberOfEigenvalues)\n    paramsoptical.laserWavelength = p.λ\n\n    paramsoptical.absorption_0[:] = p.α0\n    paramsoptical.gain_0[:] = p.gain0\n    paramsoptical.refractiveIndex_0[:] = p.nTilde\n    paramsoptical.refractiveIndex_d[:] = p.nTilde_d\n    paramsoptical.refractiveIndex_γ[:] = p.γn\n    paramsoptical.absorptionFreeCarriers[p.iphin, :] = p.fcnalf\n    paramsoptical.absorptionFreeCarriers[p.iphip, :] = p.fcpalf\n\n    paramsoptical.eigenvalues .= 1 + 1 * im   # dummy value for initializing\n\n    data.params = Params(p)\n    data.paramsoptical = paramsoptical\n\n    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    if test == false\n        show_params(ctsys)\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.abstol = 1.0e-7\n    control.reltol = 1.0e-7\n    control.tol_round = 1.0e-7\n    control.max_round = 3\n    control.damp_initial = 0.8   # < 1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium for Boltzmann\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and set as initial guess\n    psi0Vector = electroNeutralSolution(ctsys)\n\n    inival = unknowns(ctsys)\n    inival[1, :] = inival[2, :] .= 0.0\n    inival[3, :] = psi0Vector\n\n    solution = equilibrium_solve!(ctsys, inival = inival, control = control, nonlinear_steps = 20.0)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Bias loop\")\n    end\n    ################################################################################\n\n    maxBias = p.U[end]  # = 1.81 = topVoltageAcceptor2 # bias goes until the given voltage at acceptor boundary\n    biasValues = range(0, stop = maxBias, length = 40)\n\n    for Δu in biasValues\n\n        if test == false\n            println(\"bias value: Δu = \", Δu, \" V\")\n        end\n\n        # set non equilibrium boundary conditions\n        set_contact!(ctsys, p.bregionAcceptor2, Δu = Δu)\n\n        solution = solve(ctsys; inival = inival, control = control)\n        inival .= solution\n\n    end # bias loop\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    #########################################################\n\n    ctsys.data.paramsoptical.oldSolution = solution\n    currentSolution = solution\n    inival = solution\n\n    ############################\n    ctsys.data.paramsoptical.eigenvalues = p.λ1\n    ctsys.data.paramsoptical.eigenvectors = reshape(p.v1, length(p.v1), 1)  # reshaping because in system it must be a 2D array\n    ctsys.data.paramsoptical.power = p.P[2]\n\n    solution = solve(ctsys; inival = inival, control = control)\n    ctsys.data.paramsoptical.oldSolution = solution\n    currentSolution = solution\n    inival = solution\n\n    if plotting\n        vis = GridVisualizer(; Plotter = PyPlot, fignumber = 2, resolution = (1200, 900))\n\n        scalarplot!(\n            vis, grid, solution[1, :], Plotter = PyPlot, legend = :best, clear = false, title = \"Applied voltage Δu = $maxBias V\",\n            xlabel = \"cross section space along \\$x=0\\$ [m]\", ylabel = \"potentials [V]\", fontsize = 55, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\varphi_n \\$\", color = \"blue\"\n        )\n\n        scalarplot!(\n            vis, grid, solution[2, :], Plotter = PyPlot, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\varphi_p \\$\", clear = false, color = \"mediumvioletred\"\n        )\n\n        scalarplot!(\n            vis, grid, solution[3, :], Plotter = PyPlot, linewidth = 5,\n            slice = :x => 0, label = \"\\$ \\\\psi \\$\", clear = false, color = \"darkorange\"\n        )\n    end\n\n\n    testval = sum(solution) / length(solution)\n    return testval\n\nend # main\n\nfunction test()\n    testval = 0.5122451923673309\n    return main(test = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"","category":"page"},{"location":"module_examples/Ex202_Laser_simple/","page":"Simple laser structure with 5 layers.","title":"Simple laser structure with 5 layers.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"GaAs/#van-Roosbroeck-system","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"In both of the following examples, we solve the van Roosbroeck equations, a system of partial differential equations which describe current flow in a bipolar multi layer device:","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"beginaligned\n\t- nabla cdot (varepsilon_s nabla psi) = q Big( (p(psi varphi_p) - C_p ) - (n(psi varphi_n) - C_n) Big)\n\tq partial_t n(psi varphi_n) -nabla cdot mathbfj_n = -qR(np) \n\tq partial_t p(psi varphi_p) + nabla cdot mathbfj_p = -qR(np)\nendaligned","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Ohmic contacts will be used as boundary conditions. We will proceed as follows","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 1: Initialize grid","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 2: Initialize physical model","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 3: Solve the problem in equilibrium","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Step 4: Solve the problem for an applied bias","category":"page"},{"location":"GaAs/#Example-1:-Stationary-1D-problem-(region-doping)","page":"van Roosbroeck system","title":"Example 1: Stationary 1D problem (region doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We consider a three-layer GaAs p-i-n device in one dimension. We will explain the PIN example in greater detail.","category":"page"},{"location":"GaAs/#Step-1:-Initialize-grid","page":"van Roosbroeck system","title":"Step 1: Initialize grid","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"We have three layers and two external boundaries. We would like to solve the van Roosbroeck system on a uniform mesh with local grid refinement. We declare subregions and external boundaries.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# unit factors and constants\n@local_unitfactors μm cm s ns V K\neV = q * V\n\n## region numbers\nregionAcceptor   = 1          # p doped region\nregionIntrinsic  = 2          # intrinsic region\nregionDonor      = 3          # n doped region\nregions          = [regionAcceptor, regionIntrinsic, regionDonor]\nnumberOfRegions  = length(regions)\n\n## boundary region numbers\n# Note that by convention we have 1 for the left boundary and 2 for the right boundary. If\n# adding additional interior boundaries, continue with 3, 4, ...\nbregionAcceptor  = 1\nbregionDonor     = 2\nbregionJunction1 = 3\nbregionJunction2 = 4\n\n## grid\nrefinementfactor = 2^(n-1)\nh_pdoping        = 2.0    * μm\nh_intrinsic      = 2.0    * μm\nh_ndoping        = 2.0    * μm\nh_total          = h_pdoping + h_intrinsic + h_ndoping\nw_device         = 0.5    * μm  # width of device\nz_device         = 1.0e-4 * cm  # depth of device\ncoord            = initialize_pin_grid(refinementfactor,\n                                        h_pdoping,\n                                        h_intrinsic,\n                                        h_ndoping)\n\ngrid             = simplexgrid(coord)\n\n## cellmask! for defining the subregions and assigning region number\ncellmask!(grid, [0.0 * μm],                [h_pdoping],                           regionAcceptor)  # p-doped region = 1\ncellmask!(grid, [h_pdoping],               [h_pdoping + h_intrinsic],             regionIntrinsic) # intrinsic region = 2\ncellmask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic + h_ndoping], regionDonor)     # n-doped region = 3\n\n## bfacemask! for setting different boundary regions. At exterior boundaries they are automatically set by\n## ExtendableGridsjl. Thus, there the following two lines are actually unneccesarry, but are only written for completeness.\nbfacemask!(grid, [0.0],                     [0.0],                     bregionAcceptor)     # outer left boundary\nbfacemask!(grid, [h_total],                 [h_total],                 bregionDonor)  # outer right boundary\nbfacemask!(grid, [h_pdoping],               [h_pdoping],               bregionJunction1) # first  inner interface\nbfacemask!(grid, [h_pdoping + h_intrinsic], [h_pdoping + h_intrinsic], bregionJunction2) # second inner interface","category":"page"},{"location":"GaAs/#Step-2:-Initialize-physical-model","page":"van Roosbroeck system","title":"Step 2: Initialize physical model","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we choose relevant physical models such as the underlying statistics function or the recombination model. Additional options are stated in the comments. Furthermore, we define the charge carrier indices. The index for the electrostatic potential is set automatically to numberOfCarriers + 1.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# Set indices for the quasi Fermi potentials\niphin                  = 1    # electrons\niphip                  = 2    # holes\nnumberOfCarriers       = 2\n\n# Initialize Data instance\ndata                   = Data(grid, numberOfCarriers)\n\n# Solve the stationary problem instead of the transient one\ndata.modelType         = Stationary\n\n# Choose statistical relation between density and qF potential\n# options: Boltzmann, FermiDiracOneHalfBednarczyk,\n#          FermiDiracOneHalfTeSCA FermiDiracMinusOne, Blakemore\ndata.F                .= Boltzmann\n\n# Enable/Disable recombination processes, the default is stationary SRH recombination.\ndata.bulkRecombination = set_bulk_recombination(;iphin = iphin, iphip = iphip,\n                                                 bulk_recomb_Auger = true,\n                                                 bulk_recomb_radiative = true,\n                                                 bulk_recomb_SRH = true)\n\n# choose boundary models\n# exterior boundaries: OhmicContact and SchottkyContact\n# interior boundaries: InterfaceModelNone, InterfaceModelSurfaceReco.\ndata.boundaryType[bregionAcceptor] = OhmicContact\ndata.boundaryType[bregionDonor]    = OhmicContact\n\n# choose flux discretization scheme: ScharfetterGummel ScharfetterGummelGraded,\n# ExcessChemicalPotential, ExcessChemicalPotentialGraded, DiffusionEnhanced, GeneralizedSG\ndata.fluxApproximation            .= ExcessChemicalPotential","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Next, we fill in pre-defined or externally read in parameter values.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"# params contains all necessary physical parameters\nparams                                              = Params(grid, numberOfCarriers)\nparams.temperature                                  = T\nparams.chargeNumbers[iphin]                         = -1\nparams.chargeNumbers[iphip]                         =  1\n\nfor ireg in 1:numberOfRegions           # region data\n\n    params.dielectricConstant[ireg]                 = εr  * ε_0\n\n    # effective DOS, band-edge energy and mobilities\n    params.densityOfStates[iphin, ireg]             = Nc\n    params.densityOfStates[iphip, ireg]             = Nv\n    params.bandEdgeEnergy[iphin, ireg]              = Ec\n    params.bandEdgeEnergy[iphip, ireg]              = Ev\n    params.mobility[iphin, ireg]                    = mun\n    params.mobility[iphip, ireg]                    = mup\n\n    # recombination parameters\n    params.recombinationRadiative[ireg]             = Radiative\n    params.recombinationSRHLifetime[iphin, ireg]    = SRH_LifeTime\n    params.recombinationSRHLifetime[iphip, ireg]    = SRH_LifeTime\n    params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n    params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n    params.recombinationAuger[iphin, ireg]          = Auger\n    params.recombinationAuger[iphip, ireg]          = Auger\n\nend\n\n# doping\nparams.doping[iphin, regionDonor]                   = Nd\nparams.doping[iphin, regionIntrinsic]               = ni\nparams.doping[iphip, regionIntrinsic]               = 0.0\nparams.doping[iphip, regionAcceptor]                = Na\n\n# Initialize a ChargeTransport struct\ndata.params   = params\nctsys         = System(grid, data, unknown_storage=unknown_storage)","category":"page"},{"location":"GaAs/#Step-3:-Solve-the-problem-in-equilibrium","page":"van Roosbroeck system","title":"Step 3: Solve the problem in equilibrium","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Solve the equilibrium. Note that control refers to the SolverControl parameters given in VoronoiFVM.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"solution = equilibrium_solve!(ctsys, control = control)\ninival   = solution","category":"page"},{"location":"GaAs/#Step-4:-Solve-the-problem-for-an-applied-bias","page":"van Roosbroeck system","title":"Step 4: Solve the problem for an applied bias","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Starting from the equilibrium solution, we increase the applied voltage.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"maxBias    = voltageAcceptor # bias at acceptor boundary\nbiasValues = range(0, stop = maxBias, length = 32)\n\nfor Δu in biasValues\n    set_contact!(ctsys, bregionAcceptor, Δu = Δu) # non equilibrium bc\n    solution  = solve(ctsys; inival = inival, control = control)\n    inival   .= solution\nend","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"note: Note\nTo be consistent with the latest changes of VoronoiFVM, please do not use the solve!() function anymore. Otherwise, you will get deprecation warnings.","category":"page"},{"location":"GaAs/#Step-5:-Postprocessing","page":"van Roosbroeck system","title":"Step 5: Postprocessing","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"By adding the following line to the previous loop","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"current = get_current_val(ctsys, solution)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"we have the possibility to calculate the total current.","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Moreover, there are several different plotting routines, see ct_plotting.jl.","category":"page"},{"location":"GaAs/#Example-2:-Stationary-1D-problem-(nodal-doping)","page":"van Roosbroeck system","title":"Example 2: Stationary 1D problem (nodal doping)","text":"","category":"section"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"Now, instead of using regionwise doping it is possible to apply a nodal doping. (This is indeed also possible for other physical parameters, see the description of ParamsNodal.) For this, go to previous Step 2, where you build your parameter set and adjust the doping initialization (code snippet is from this example)","category":"page"},{"location":"GaAs/","page":"van Roosbroeck system","title":"van Roosbroeck system","text":"paramsnodal = ParamsNodal(grid, numberOfCarriers)\n\n# initialize the space dependent doping\nNDoping = 1.0e17  / cm^3; κ = 500.0\nfor icoord = 1:numberOfNodes\n    t1 = tanh( (0.1 - coord[icoord]/μm) *κ )\n    t2 = 1.0 + tanh( (coord[icoord]/μm - 0.2) * κ )\n    paramsnodal.doping[icoord] = NDoping * 0.5 * ( 1.0  +  t1  - t2 )\nend\n\ndata.paramsnodal  = paramsnodal","category":"page"},{"location":"changes/","page":"Changelog","title":"Changelog","text":"using Markdown\nMarkdown.parse(read(\"../../CHANGELOG.md\",String))","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/#PSC-device-with-photogeneration-rate-(1D).","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"","category":"section"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"(source code)","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"Simulating a three layer PSC device TiO2 | MAPI | Pedot with mobile ions where the ion vacancy accumulation is limited by the Fermi-Dirac integral of order -1.","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"We perform a linear scan protocol and try out different photogeneration rates.","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"module Ex104_PSC_Photogeneration\n\nusing ChargeTransport\nusing ExtendableGrids\nusing PyPlot","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"for convenience","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"parametersdir = ChargeTransport.parametersdir","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"you can also use other Plotters, if you add them to the example file you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"function main(;\n        n = 5,\n        Plotter = PyPlot,\n        plotting = false, verbose = false, test = false,\n        ########################\n        parameter_set = Params_PSC_TiO2_MAPI_spiro, # choose the parameter set\n        ########################\n        userdefinedGeneration = false\n    ) # you can choose between predefined and user-defined generation profiles\n\n    @local_unitfactors μm cm s ns V K ps Hz W m\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"parameters","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"    p = parameter_set()\n\n    # contact voltage\n    voltageAcceptor = 1.2 * V\n\n    # primary data for I-V scan protocol\n    scanrate = 0.04 * V / s\n    number_tsteps = 31\n    endVoltage = voltageAcceptor # bias goes until the given voltage at acceptor boundary\n    tend = endVoltage / scanrate\n\n    # Define scan protocol function\n    function scanProtocol(t)\n\n        if 0.0 <= t  && t <= tend\n            biasVal = 0.0 + scanrate * t\n        elseif t > tend  && t <= 2 * tend\n            biasVal = scanrate * tend .+ scanrate * (tend - t)\n        else\n            biasVal = 0.0\n        end\n\n        return biasVal\n\n    end\n\n    # Apply zero voltage on left boundary and a linear scan protocol on right boundary\n    contactVoltageFunction = [zeroVoltage, scanProtocol]\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################\n\n    δ = 4 * n        # the larger, the finer the mesh\n    t = 0.5 * (cm) / δ # tolerance for geomspace and glue (with factor 10)\n    k = 1.5        # the closer to 1, the closer to the boundary geomspace\n\n    coord_n_u = collect(range(0.0, p.h_ndoping / 2, step = p.h_ndoping / (0.8 * δ)))\n    coord_n_g = geomspace(\n        p.h_ndoping / 2,\n        p.h_ndoping,\n        p.h_ndoping / (0.7 * δ),\n        p.h_ndoping / (1.1 * δ),\n        tol = t\n    )\n    coord_i_g1 = geomspace(\n        p.h_ndoping,\n        p.h_ndoping + p.h_intrinsic / k,\n        p.h_intrinsic / (2.8 * δ),\n        p.h_intrinsic / (2.1 * δ),\n        tol = t\n    )\n    coord_i_g2 = geomspace(\n        p.h_ndoping + p.h_intrinsic / k,\n        p.h_ndoping + p.h_intrinsic,\n        p.h_intrinsic / (2.1 * δ),\n        p.h_intrinsic / (2.8 * δ),\n        tol = t\n    )\n    coord_p_g = geomspace(\n        p.h_ndoping + p.h_intrinsic,\n        p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2,\n        p.h_pdoping / (1.6 * δ),\n        p.h_pdoping / (1.6 * δ),\n        tol = t\n    )\n    coord_p_u = collect(range(p.h_ndoping + p.h_intrinsic + p.h_pdoping / 2, p.h_ndoping + p.h_intrinsic + p.h_pdoping, step = p.h_pdoping / (1.3 * δ)))\n\n    coord = glue(coord_n_u, coord_n_g, tol = 10 * t)\n    coord = glue(coord, coord_i_g1, tol = 10 * t)\n    coord = glue(coord, coord_i_g2, tol = 10 * t)\n    coord = glue(coord, coord_p_g, tol = 10 * t)\n    coord = glue(coord, coord_p_u, tol = 10 * t)\n    grid = ExtendableGrids.simplexgrid(coord)\n\n    # set different regions in grid\n    cellmask!(grid, [0.0 * μm], [p.heightLayers[1]], p.regionDonor, tol = 1.0e-18) # n-doped region   = 1\n    cellmask!(grid, [p.heightLayers[1]], [p.heightLayers[2]], p.regionIntrinsic, tol = 1.0e-18) # intrinsic region = 2\n    cellmask!(grid, [p.heightLayers[2]], [p.heightLayers[3]], p.regionAcceptor, tol = 1.0e-18) # p-doped region   = 3\n\n    bfacemask!(grid, [p.heightLayers[1]], [p.heightLayers[1]], p.bregionJ1, tol = 1.0e-18)\n    bfacemask!(grid, [p.heightLayers[2]], [p.heightLayers[2]], p.bregionJ2, tol = 1.0e-18)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter, legend = :lt)\n        Plotter.title(\"Grid\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################\n\n    # Initialize Data instance and fill in predefined data\n    if userdefinedGeneration\n\n        subg1 = subgrid(grid, [p.regionDonor]); subg2 = subgrid(grid, [p.regionIntrinsic]); subg3 = subgrid(grid, [p.regionAcceptor])\n\n        gen1 = zeros(length(subg1[Coordinates]) - 1); gen3 = zeros(length(subg3[Coordinates]) - 1)\n        gen2 = p.incidentPhotonFlux[p.regionIntrinsic] .* p.absorption[p.regionIntrinsic] .* exp.(- p.absorption[p.regionIntrinsic] .* (subg2[Coordinates] .- p.generationPeak))\n\n        # we want to get agreement with the region-wise defined photogeneration\n        X1 = subg1[Coordinates]; X2 = subg2[Coordinates]; X3 = subg3[Coordinates]\n\n        h1end = X1[end] - X1[end - 1]; h2beg = X2[2] - X2[1]\n        h2end = X2[end] - X2[end - 1]; h3beg = X3[2] - X3[1]","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"region reaction multiplies with h2beg/2 ( = | ωk ∩ region2|) it visits the node only from region2 node reaction multiplies with (h1end+h2beg)/2 ( = | ωk|)  as it visits the node from region 1 and region 2 therefore, we need the following weights However, note that | ω_k ∩ region2| is not calculate explicitly but via the simplex components (if we have cellwise loops)","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"        weight1 = h2beg / (h1end + h2beg) # ( = | ω_k ∩ region2| / | ω_k| )\n        weight2 = h2end / (h2end + h3beg)\n\n        gen2[1] = weight1 * gen2[1]; gen2[end] = weight2 * gen2[end]\n\n        generationData = [gen1; gen2'; gen3]\n\n        data = Data(\n            grid, p.numberOfCarriers,\n            contactVoltageFunction = contactVoltageFunction,\n            generationData = generationData\n        )\n    else\n\n        data = Data(\n            grid, p.numberOfCarriers,\n            contactVoltageFunction = contactVoltageFunction\n        )\n\n    end\n\n    data.modelType = Transient\n    data.F = [FermiDiracOneHalfTeSCA, FermiDiracOneHalfTeSCA, FermiDiracMinusOne]\n\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = p.iphin, iphip = p.iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )\n    data.boundaryType[p.bregionAcceptor] = OhmicContact\n    data.boundaryType[p.bregionDonor] = OhmicContact\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    enable_ionic_carrier!(data, ionicCarrier = p.iphia, regions = [p.regionIntrinsic])\n\n    if userdefinedGeneration\n        data.generationModel = GenerationUserDefined\n    else\n        data.generationModel = GenerationBeerLambert\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################\n\n    data.params = Params(p)\n    ctsys = System(grid, data, unknown_storage = :sparse)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = SolverControl()\n    control.verbose = verbose\n    control.maxiters = 300\n    control.max_round = 5\n    control.damp_initial = 0.5\n    control.damp_growth = 1.21 # >= 1\n    control.Δt_max = 5.0e-1\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n    ################################################################################\n    if test == false\n        println(\"Compute solution in thermodynamic equilibrium\")\n    end\n    ################################################################################\n\n    # calculate equilibrium solution and as initial guess\n    solution = equilibrium_solve!(ctsys, control = control)\n    inival = solution\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Loop for generation\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"these values are needed for putting the generation slightly on","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"    I = collect(20:-1:0.0)\n    LAMBDA = 10 .^ (-I)\n\n    # since the constant which represents the constant quasi Fermi potential of anion vacancies is undetermined, we need\n    # to fix it in the bias loop, since we have no applied bias. Otherwise we get convergence errors\n    ctsys.fvmsys.boundary_factors[p.iphia, p.bregionJ2] = 1.0e30\n    ctsys.fvmsys.boundary_values[p.iphia, p.bregionJ2] = 0.0\n\n    for istep in 1:(length(I) - 1)\n\n        # turn slowly generation on\n        ctsys.data.λ2 = LAMBDA[istep + 1]\n\n        if test == false\n            println(\"increase generation with λ2 = $(data.λ2)\")\n        end\n\n        solution = solve(ctsys, inival = inival, control = control)\n        inival = solution\n\n    end # generation loop\n\n    solutionEQ = inival\n\n    if plotting\n        label_solution, label_density, label_energy, label_BEE = set_plotting_labels(data)\n\n        # add labels for anion vacancy\n        label_energy[1, iphia] = \"\\$E_a-q\\\\psi\\$\"; label_energy[2, iphia] = \"\\$ - q \\\\varphi_a\\$\"; label_BEE[iphia] = \"\\$E_a\\$\"\n        label_density[iphia] = \"\\$ n_a \\$\";      label_solution[iphia] = \"\\$ \\\\varphi_a\\$\"\n\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, solution, \"Initial condition\", label_density)\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, solution, \"Initial condition\", label_solution)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Measurement loop\")\n    end\n    ################################################################################\n\n    # put here back the homogeneous Neumann boundary conditions.\n    ctsys.fvmsys.boundary_factors[p.iphia, p.bregionJ2] = 0.0\n    ctsys.fvmsys.boundary_values[p.iphia, p.bregionJ2] = 0.0\n\n    sol = solve(ctsys, inival = inival, times = (0.0, tend), control = control)\n\n    if plotting\n        tsol = sol(tend)\n        Plotter.figure()\n        plot_densities(Plotter, ctsys, tsol, \"Densities at end time\", label_density)\n        Plotter.tight_layout()\n        Plotter.figure()\n        plot_solution(Plotter, ctsys, tsol, \"Solution at end time\", label_solution)\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Reverse scan protocol\")\n    end\n    ################################################################################\n    inivalReverse = sol(tend)\n    solReverse = solve(ctsys, inival = inivalReverse, times = (tend, 2 * tend), control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"IV Curve calculation\")\n    end\n    ################################################################################\n\n    factory = TestFunctionFactory(ctsys)\n    tf = testfunction(factory, [p.bregionDonor], [p.bregionAcceptor])\n\n    tvalues = sol.t\n    number_tsteps = length(tvalues)\n    biasValues = scanProtocol.(tvalues)\n    IV = zeros(0)\n\n    for istep in 2:number_tsteps\n        Δt = tvalues[istep] - tvalues[istep - 1] # Time step size\n        inival = sol.u[istep - 1]\n        solution = sol.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(p.numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IV, current)\n\n    end\n\n    tvaluesReverse = solReverse.t\n    number_tstepsReverse = length(tvaluesReverse)\n    biasValuesReverse = scanProtocol.(tvaluesReverse)\n    IVReverse = zeros(0)\n\n    for istep in 2:number_tstepsReverse\n        Δt = tvaluesReverse[istep] - tvaluesReverse[istep - 1] # Time step size\n        inival = solReverse.u[istep - 1]\n        solution = solReverse.u[istep]\n\n        I = integrate(ctsys, tf, solution, inival, Δt)\n\n        current = 0.0\n        for ii in 1:(p.numberOfCarriers + 1)\n            current = current + I[ii]\n        end\n\n        push!(IVReverse, current)\n\n    end\n\n    if plotting\n        Plotter.figure()\n        Plotter.plot([tvalues tvaluesReverse], [biasValues biasValuesReverse], marker = \"x\")\n        Plotter.xlabel(\"time [s]\")\n        Plotter.ylabel(\"voltage [V]\")\n        Plotter.grid()\n\n        Plotter.figure()\n        Plotter.plot(biasValues[2:end], -IV, linewidth = 5, label = \"forward\")\n        Plotter.plot(biasValuesReverse[2:end], -IVReverse, linewidth = 5, label = \"reverse\")\n        Plotter.grid()\n        Plotter.legend()\n        Plotter.xlabel(\"applied bias [V]\")\n        Plotter.ylabel(\"total current [A]\")\n\n        Plotter.figure()\n        if userdefinedGeneration\n            Plotter.plot(coord, data.generationData)\n        else\n            for ireg in 1:p.numberOfRegions\n                subg = subgrid(grid, [ireg])\n                Plotter.plot(subg[Coordinates]', BeerLambert(ctsys, ireg, subg[Coordinates])', label = \"region $ireg\")\n            end\n\n        end\n        Plotter.legend()\n        Plotter.grid()\n        Plotter.xlabel(\"space [\\$m\\$]\")\n        Plotter.ylabel(\"photogeneration [\\$\\\\frac{1}{cm^3s}\\$]\")\n        Plotter.tight_layout()\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Compute fill factor and efficiency\")\n    end\n    ################################################################################\n\n    bias = biasValues[2:end]\n    IV = -IV\n\n    powerDensity = bias .* (IV)           # power density function\n    MaxPD, indexPD = findmax(powerDensity)\n\n    open_circuit = compute_open_circuit_voltage(bias, IV)\n\n    IncidentLightPowerDensity = 1000.0 * W / m^2\n\n    efficiency = bias[indexPD] * IV[indexPD] / IncidentLightPowerDensity\n    fillfactor = (bias[indexPD] * IV[indexPD]) / (IV[1] * open_circuit)\n\n    if test == false\n        println(\"The fill factor is $fillfactor %.\")\n        println(\"The efficiency  is $efficiency %.\")\n        println(\"The open circuit voltage  is $open_circuit.\")\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    testval = sum(filter(!isnan, solutionEQ)) / length(solutionEQ) # when using sparse storage, we get NaN values in solution\n    return testval\n\nend #  main\n\nfunction test()\n    testval = -1.052813874410313\n    return main(test = true, userdefinedGeneration = false) ≈ testval && main(test = true, userdefinedGeneration = true) ≈ testval\nend\n\nif test == false\n    println(\"This message should show when this module is successfully recompiled.\")\nend\n\nend # module","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"","category":"page"},{"location":"module_examples/Ex104_PSC_Photogeneration/","page":"PSC device with photogeneration rate (1D).","title":"PSC device with photogeneration rate (1D).","text":"This page was generated using Literate.jl.","category":"page"},{"location":"general/#ChargeTransport.jl-–-Simulating-charge-transport-in-semiconductors","page":"Home","title":"ChargeTransport.jl – Simulating charge transport in semiconductors","text":"","category":"section"},{"location":"general/","page":"Home","title":"Home","text":"(Image: Build status) (Image: ) (Image: )","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"ChargeTransport.jl simulates charge transport in semiconductors. To this end, it discretizes the semiconductor drift-diffusion equations via the Voronoi finite volume method as implemented in VoronoiFVM.jl.","category":"page"},{"location":"general/#Special-features","page":"Home","title":"Special features","text":"","category":"section"},{"location":"general/","page":"Home","title":"Home","text":"heterostructures\n1D, 2D and 3D simulations\nstationary and transient simulations\nIV curves and scan protocols\nan arbitrary amount of charge carriers (electrons, heavy holes, light holes, ions, ...)\nthermodynamically consistent, physics preserving numerical methods\ndifferent charge carrier statistics per species (Boltzmann, Blakemore, Fermi-Dirac)\nAuger, radiative, Shockley-Read-Hall recombination\nuniform and Beer-Lambert generation","category":"page"},{"location":"general/#Installation-and-first-steps","page":"Home","title":"Installation and first steps","text":"","category":"section"},{"location":"general/","page":"Home","title":"Home","text":"The installation can easily be done via the Julia REPL with the following commands","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ChargeTransport\")","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"We recommend have a look at the example files:","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"Pages = [\n    \"GaAs.md\",\n    \"PSC.md\",\n    ]\nDepth = 2","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"You can load an example as follows","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"julia> include(\"Ex103_PSC.jl\")\njulia> Ex103_PSC.main()\njulia> Ex103_PSC.main(plotting = true) # show plots","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"Since the examples are encapsulated into modules, you can load as many examples as you wish. If you would like to modify one of the examples, consider using Revise.jl and includet.","category":"page"},{"location":"general/#Literature","page":"Home","title":"Literature","text":"","category":"section"},{"location":"general/","page":"Home","title":"Home","text":"The simulations in the following papers are based on ChargeTransport.jl:","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[1.] D. Abdel, P. Farrell and J. Fuhrmann. Assessing the quality of the excess chemical potential flux scheme for degenerate semiconductor device simulation. Optical and Quantum Electronics 53, 163 (2021).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[2.] D. Abdel, P. Vágner, J. Fuhrmann and P. Farrell. Modelling charge transport in perovskite solar cells: Potential-based and limiting ion depletion. Electrochimica Acta 390 (2021).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[3.] D. Abdel, C. Chainais-Hillairet, P. Farrell and M. Herda. Numerical analysis of a finite volume scheme for charge transport in perovskite solar cells. IMA Journal of Numerical Analysis (2023).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[4.] D. Abdel, N. E. Courtier and P. Farrell. Volume exclusion effects in perovskite charge transport modeling. Optical and Quantum Electronics 55, 884 (2023).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[5.] B. Spetzler, D. Abdel, F. Schwierz, M. Ziegler and P. Farrell. The Role of Vacancy Dynamics in Two-Dimensional Memristive Devices. Advanced Electronic Materials (2023).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[6.] D. Abdel, A. Glitzky and M. Liero. Analysis of a drift-diffusion model for perovskite solar cells. Discrete and Continuous Dynamical Systems - Series B (2024).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[7.] D. Abdel, M. Herda, M. Ziegler, C. Chainais-Hillairet, B. Spetzler, P. Farrell. Numerical analysis and simulation of lateral memristive devices: Schottky, ohmic, and multi-dimensional electrode models. submitted (2024).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[8.] B. Spetzler, E. Spetzler, S. Zamankhani, D. Abdel, P. Farrell, K.-U. Sattler, M. Ziegler. Physics-Guided Sequence Modeling for Fast Simulation and Design Exploration of 2D Memristive Devices. (2025).","category":"page"},{"location":"general/","page":"Home","title":"Home","text":"[9.] D. Abdel, J. Relle, T. Kirchartz, P. Jaap, J. Fuhrmann, S. Burger, C. Becker, K. Jäger, P. Farrell. Unravelling the mystery of enhanced open-circuit voltages in nanotextured perovskite solar cells. submitted (2025).","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/#Nondimensionalized-perovskite-solar-cell.","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"","category":"section"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"(source code)","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"Simulation of charge transport in a non-dimensionalized three-layer perovskite solar cell. All physical parameters and constants are set to 1 besides the energies which are set to zero. This example serves an academic purpose.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"module Ex109_PSC_NonDimensional\n\nusing ChargeTransport\nusing VoronoiFVM\nusing ExtendableGrids  # grid initializer\nusing PyPlot           # solution visualizer","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"you can set verbose also to true to display some solver information","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"function main(;\n        n = 3,               # for number of nodes in each layer\n        Cn = 10, Cp = 10,    # doping\n        λ = 1.0,             # Debye length\n        DirichletVal = 1.0,  # Dirichlet value\n        G0 = 1.0,            # photogeneration prefactor\n        Plotter = PyPlot, plotting = false,\n        verbose = false, test = false, unknown_storage = :sparse\n    )\n\n    if plotting\n        Plotter.close(\"all\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Set up grid and regions\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"constants Here, we set the constants to unityconstants. In particular, we set: q = kB = ε_0 = 1 When defining `ChargeTransport.constants\" the constants based on CODATA2022 are used.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    constants = ChargeTransport.unity_constants","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"region numbers","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    region1 = 1\n    region2 = 2\n    region3 = 3\n    regions = [region1, region2, region3]\n    numberOfRegions = length(regions)","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"boundary region numbers","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    bregion1 = 1\n    bregion2 = 2\n\n    # grid\n    h1 = 1.0; h2 = 4.0; h3 = 2.0\n    h_total = h1 + h2 + h3\n\n    coord1 = collect(range(0.0; stop = h1, length = n))\n    coord2 = collect(range(h1; stop = h1 + h2, length = 4 * n))\n    coord3 = collect(range(h1 + h2; stop = h_total, length = 2 * n))\n    coord = glue(coord1, coord2)\n    coord = glue(coord, coord3)\n\n    grid = simplexgrid(coord)\n\n    # cellmask! for defining the subregions and assigning region number\n    cellmask!(grid, [0.0], [h1], region1)\n    cellmask!(grid, [h1], [h1 + h2], region2)\n    cellmask!(grid, [h1 + h2], [h_total], region3)\n\n    # bfacemask! for setting different boundary regions.\n    bfacemask!(grid, [0.0], [0.0], bregion1)\n    bfacemask!(grid, [h_total], [h_total], bregion2)\n\n    if plotting\n        gridplot(grid, Plotter = Plotter)\n    end\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define physical parameters and model\")\n    end\n    ################################################################################\n\n    # set indices of the quasi Fermi potentials\n    iphin = 1              # electron quasi Fermi potential\n    iphip = 2              # hole quasi Fermi potential\n    ipsi = 3               # electric potential\n    numberOfCarriers = 2","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"We define the physical data.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    zn = -1; zp = 1\n    En = 0.0; Ep = 0.0     # set the energies to 0\n    Nn = 1.0; Np = 1.0     # set the effective DOS to 1\n    μn = 1.0; μp = 1.0     # set the mobilities to 1\n    λ = λ                  # Debye length, entering model as `DielectricConstant`, i.e., prefactor in the displacement flux.\n    T = 1.0                # set temperature to 1\n\n    # recombination parameters\n    SRH_TrapDensity = 0.0\n    SRH_LifeTime = 1.0\n    Radiative = 1.0\n\n    # doping\n    Cn = Cn\n    Cp = Cp\n    Ca = 0.0","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"boundary value","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    DirichletVal = DirichletVal","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"photogeneration","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    G(x) = G0 .* exp.(- (x .- h1))\n    genData = zeros(length(coord))\n    genData[length(coord1):(length(coord1) + length(coord2) - 1)] = G.(coord2)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define System and fill in information about model\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"We initialize the Data instance and fill in predefined data.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    data = Data(grid, numberOfCarriers, generationData = genData, constants = constants)\n\n    # Following variable declares, if we want to solve stationary or transient problem\n    data.modelType = Stationary\n\n    # Following choices are possible for F: Boltzmann, FermiDiracOneHalfBednarczyk,\n    # FermiDiracOneHalfTeSCA, FermiDiracMinusOne, Blakemore\n    data.F .= Boltzmann\n\n    # The desired recombination processes can be chosen here.\n    data.bulkRecombination = set_bulk_recombination(;\n        iphin = iphin, iphip = iphip,\n        bulk_recomb_Auger = false,\n        bulk_recomb_radiative = true,\n        bulk_recomb_SRH = true\n    )","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"generation model","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    data.generationModel = GenerationUserDefined\n\n    # flux discretization scheme\n    data.fluxApproximation .= ExcessChemicalPotential\n\n    # Define the unity constants also in the discrete counterpart of the model\n    data.constants = constants\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define Params and fill in physical parameters\")\n    end\n    ################################################################################","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"Define the Params struct","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    params = Params(grid[NumCellRegions], grid[NumBFaceRegions], numberOfCarriers)\n\n    params.temperature = T\n    params.chargeNumbers[iphin] = zn\n    params.chargeNumbers[iphip] = zp\n\n    for ireg in 1:numberOfRegions # region data\n\n        params.dielectricConstant[ireg] = λ^2\n\n        # effective DOS, band-edge energy and mobilities\n        params.densityOfStates[iphin, ireg] = Nn\n        params.densityOfStates[iphip, ireg] = Np\n        params.bandEdgeEnergy[iphin, ireg] = En\n        params.bandEdgeEnergy[iphip, ireg] = Ep\n        params.mobility[iphin, ireg] = μn\n        params.mobility[iphip, ireg] = μp\n\n        # recombination parameters\n        params.recombinationRadiative[ireg] = Radiative\n        params.recombinationSRHLifetime[iphin, ireg] = SRH_LifeTime\n        params.recombinationSRHLifetime[iphip, ireg] = SRH_LifeTime\n        params.recombinationSRHTrapDensity[iphin, ireg] = SRH_TrapDensity\n        params.recombinationSRHTrapDensity[iphip, ireg] = SRH_TrapDensity\n\n    end\n\n    # doping\n    params.doping[iphin, region1] = Cn\n    params.doping[iphin, region2] = Ca\n    params.doping[iphip, region3] = Cp","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"Region dependent params is now a substruct of data which is again a substruct of the system and will be parsed in next step.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    data.params = params","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"In the last step, we initialize our system with previous data which is likewise dependent on the parameters.","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"    ctsys = System(grid, data, unknown_storage = unknown_storage)\n\n    # boundary model\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphin, bregion1, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphip, bregion1, 0.0)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, ipsi, bregion1, asinh(Cn / 2))\n\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphin, bregion2, DirichletVal)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, iphip, bregion2, DirichletVal)\n    VoronoiFVM.boundary_dirichlet!(ctsys.fvmsys, ipsi, bregion2, asinh(-Cp / 2) + DirichletVal)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Define control parameters for Solver\")\n    end\n    ################################################################################\n\n    control = VoronoiFVM.SolverControl()\n    control.verbose = verbose\n    control.maxiters = 50\n    control.abstol = 1.0e-14\n    control.reltol = 1.0e-14\n    control.tol_round = 1.0e-8\n    control.damp_initial = 0.5\n    control.max_round = 3\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false\n        println(\"Solving the nonlinear system of equations\")\n    end\n    ################################################################################\n\n    inival = ChargeTransport.unknowns(ctsys)\n    inival[iphin, :] = 0.0 .+ DirichletVal ./ h_total .* coord\n    inival[iphip, :] = 0.0 .+ DirichletVal ./ h_total .* coord\n    inival[ipsi, :] = asinh(Cn / 2) .+ ((asinh(-Cp / 2) + DirichletVal) - asinh(Cn / 2)) ./ h_total .* coord\n\n    sol = ChargeTransport.solve(ctsys, inival = inival, control = control)\n\n    if test == false\n        println(\"*** done\\n\")\n    end\n\n    ################################################################################\n    if test == false && plotting\n        println(\"Plotting\")\n    end\n    ################################################################################\n\n    nn = exp.(zn * (sol[iphin, :] - sol[ipsi, :]))\n    np = exp.(zp * (sol[iphip, :] - sol[ipsi, :]))\n\n    if plotting\n\n        figure()\n        PyPlot.plot(coord, sol[iphin, :], color = \"green\", linewidth = 5, label = \"\\$ \\\\varphi_{\\\\mathrm{n}}}\\$\")\n        PyPlot.plot(coord, sol[iphip, :], color = \"red\", linewidth = 5, linestyle = \"--\", label = \"\\$ \\\\varphi_{\\\\mathrm{p}}}\\$\")\n        PyPlot.plot(coord, sol[ipsi, :], color = \"blue\", linewidth = 5, label = \"\\$ \\\\psi\\$\")\n        axvspan(0.0, 1.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        axvspan(5.0, 7.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        xlabel(\"\\$ x \\$\", fontsize = 17)\n        ylabel(\"Potential\", fontsize = 17)\n        tight_layout()\n        PyPlot.legend(loc = \"center right\", fontsize = 14)\n        ########################################################\n\n        figure()\n        PyPlot.semilogy(coord, nn, color = \"green\", linewidth = 5, label = \"\\$ n_{\\\\mathrm{n}}}\\$\")\n        PyPlot.semilogy(coord, np, color = \"red\", linewidth = 5, label = \"\\$ n_{\\\\mathrm{p}}}\\$\")\n        PyPlot.legend(loc = \"center right\", fontsize = 14)\n        axvspan(0.0, 1.0, facecolor = [211 / 255 232 / 255 208 / 255])\n        axvspan(1.0, 5.0, facecolor = [233 / 255 226 / 255 215 / 255])\n        axvspan(5.0, 7.0, facecolor = [243 / 255 192 / 255 192 / 255])\n        xlabel(\"\\$ x \\$\", fontsize = 17)\n        ylabel(\"Density\", fontsize = 17)\n        tight_layout()\n\n    end\n\n    if test == false && plotting\n        println(\"*** done\\n\")\n    end\n\n    return sum(filter(!isnan, sol)) / length(sol)\n\nend #  main\n\nfunction test()\n    testval = 0.4760637366166469\n    return main(test = true, unknown_storage = :dense) ≈ testval && main(test = true, unknown_storage = :sparse) ≈ testval\nend\n\n\nend # module","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"","category":"page"},{"location":"module_examples/Ex109_PSC_NonDimensional/","page":"Nondimensionalized perovskite solar cell.","title":"Nondimensionalized perovskite solar cell.","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"-","title":"-","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"}]
}
